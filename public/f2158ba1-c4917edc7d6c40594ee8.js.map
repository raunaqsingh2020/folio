{"version":3,"sources":["webpack://gatsby-starter-default/./node_modules/react-curtains/dist/index.esm.js"],"names":["precisionMedium$1","replace","defaultAttributes$1","defaultVaryings$1","Mat4","elements","arguments","length","undefined","Float32Array","this","type","key","value","array","i","matrix","copy","a","b","result","te","out","oe","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b00","b01","b02","b03","b04","b05","b06","b07","b08","b09","b10","b11","det","vector","x","y","z","translation","quaternion","scale","w","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","sx","sy","sz","origin","ox","oy","oz","out0","out1","out2","out4","out5","out6","out8","out9","out10","Vec2","_x","_y","get","set","changed","_onChangeCallback","callback","isNaN","parseFloat","Math","max","min","len","sqrt","Vec3","_z","mArray","qx","qy","qz","qw","ix","iy","iz","iw","camera","applyMat4","viewMatrix","projectionMatrix","getInverse","worldMatrix","Quat","axisOrder","toUpperCase","ax","ay","az","cosx","cos","cosy","cosz","sinx","sin","siny","sinz"],"mappings":"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","file":"f2158ba1-c4917edc7d6c40594ee8.js","sourcesContent":["import _assertThisInitialized from \"/Users/raunaqsingh/Documents/folio/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/raunaqsingh/Documents/folio/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/raunaqsingh/Documents/folio/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/raunaqsingh/Documents/folio/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/raunaqsingh/Documents/folio/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/Users/raunaqsingh/Documents/folio/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/raunaqsingh/Documents/folio/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { createContext, useReducer, useContext, useRef, useLayoutEffect, useEffect, useState, Children, isValidElement, cloneElement } from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar initialState = {\n  curtains: null,\n  // subscriptions to hook on curtains class events\n  subscriptions: {\n    onAfterResize: [],\n    onContextLost: [],\n    onContextRestored: [],\n    onError: [],\n    onSuccess: [],\n    onRender: [],\n    onScroll: []\n  }\n};\nvar CurtainsContext = /*#__PURE__*/createContext(initialState);\n\nfunction CurtainsProvider(_ref) {\n  var children = _ref.children;\n\n  var _useReducer = useReducer(function (state, action) {\n    switch (action.type) {\n      case \"SET_CURTAINS\":\n        return _extends({}, state, {\n          curtains: action.curtains\n        });\n\n      case \"ADD_SUBSCRIPTION\":\n        // get store state and subscription action\n        var addSubscriptionState = _extends({}, state);\n\n        var addSubscription = action.addSubscription; // is it already in our subscription event array?\n\n        var existingSubscription = addSubscriptionState.subscriptions[addSubscription.event].find(function (el) {\n          return el.id === addSubscription.id;\n        }); // if not we'll add it\n\n        if (!existingSubscription) {\n          addSubscriptionState.subscriptions[addSubscription.event].push(addSubscription);\n        } // return updated store state\n\n\n        return addSubscriptionState;\n\n      case \"REMOVE_SUBSCRIPTION\":\n        // get store state and subscription action\n        var removeSubscriptionState = _extends({}, state);\n\n        var removeSubscription = action.removeSubscription; // remove from our subscription event array\n\n        removeSubscriptionState.subscriptions[removeSubscription.event] = removeSubscriptionState.subscriptions[removeSubscription.event].filter(function (el) {\n          return el.id !== removeSubscription.id;\n        }); // return updated store state\n\n        return removeSubscriptionState;\n\n      default:\n        throw new Error();\n    }\n  }, initialState),\n      state = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  return /*#__PURE__*/React.createElement(CurtainsContext.Provider, {\n    value: {\n      state: state,\n      dispatch: dispatch\n    }\n  }, children);\n}\n/***\r\n Throw a console warning with the passed arguments\r\n ***/\n\n\nvar warningThrown = 0;\n\nfunction throwWarning() {\n  if (warningThrown > 100) {\n    return;\n  } else if (warningThrown === 100) {\n    console.warn(\"Curtains: too many warnings thrown, stop logging.\");\n  } else {\n    var args = Array.prototype.slice.call(arguments);\n    console.warn.apply(console, args);\n  }\n\n  warningThrown++;\n}\n/***\r\n Throw a console error with the passed arguments\r\n ***/\n\n\nfunction throwError() {\n  var args = Array.prototype.slice.call(arguments);\n  console.error.apply(console, args);\n}\n/***\r\n Generates an universal unique identifier\r\n ***/\n\n\nfunction generateUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16).toUpperCase();\n  });\n}\n/***\r\n Check whether a number is power of 2\r\n\r\n params:\r\n @value (float): number to check\r\n ***/\n\n\nfunction isPowerOf2(value) {\n  return (value & value - 1) === 0;\n}\n/***\r\n Linear interpolation between two numbers\r\n\r\n params:\r\n @start (float): value to lerp\r\n @end (float): end value to use for lerp\r\n @amount (float): amount of lerp\r\n ***/\n\n\nfunction _lerp(start, end, amount) {\n  return (1 - amount) * start + amount * end;\n}\n/***\r\n Here we create our Scene object\r\n The Scene will stack all the objects that will be drawn (planes and shader passes) in different arrays, and call them in the right order to be drawn.\r\n\r\n Based on the concept exposed here https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html\r\n The idea is to optimize the order of the rendered object so that the WebGL calls are kept to a strict minimum\r\n\r\n Here's the whole draw process order:\r\n - first we draw the ping pong planes\r\n - if needed, we bind the first scene pass frame buffer\r\n - draw all the planes that are rendered onto a render target (render pass)\r\n - draw the planes from the first render target created, ordered by their renderOrder then indexes (first added first drawn) order\r\n - draw the planes from the second render target created, etc.\r\n - draw the render passes content (depth buffer is cleared after each pass)\r\n - draw the transparent planes ordered by renderOrder, Z positions, geometry IDs and then indexes (first added first drawn)\r\n - draw the opaque planes ordered by renderOrder, geometry IDs and then indexes (first added first drawn)\r\n - draw the scene passes content\r\n\r\n params:\r\n @renderer (Renderer class object): our renderer class object\r\n\r\n returns :\r\n @this: our Scene\r\n ***/\n\n\nvar Scene = /*#__PURE__*/function () {\n  function Scene(renderer) {\n    _classCallCheck(this, Scene);\n\n    this.type = \"Scene\";\n\n    if (!renderer || renderer.type !== \"Renderer\") {\n      throwError(this.type + \": Renderer not passed as first argument\", renderer);\n    } else if (!renderer.gl) {\n      throwError(this.type + \": Renderer WebGL context is undefined\", renderer); // return if no gl context\n\n      return;\n    }\n\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n    this.initStacks();\n  }\n  /***\r\n   Init our Scene stacks object\r\n   ***/\n\n\n  _createClass(Scene, [{\n    key: \"initStacks\",\n    value: function initStacks() {\n      this.stacks = {\n        // planes\n        \"pingPong\": [],\n        \"renderTargets\": [],\n        \"opaque\": [],\n        \"transparent\": [],\n        // post processing\n        \"renderPasses\": [],\n        \"scenePasses\": []\n      };\n    }\n    /*** RESET STACKS ***/\n\n    /***\r\n     Reset the plane stacks (used when disposing a plane)\r\n     ***/\n\n  }, {\n    key: \"resetPlaneStacks\",\n    value: function resetPlaneStacks() {\n      // clear the plane stacks\n      this.stacks.pingPong = [];\n      this.stacks.renderTargets = [];\n      this.stacks.opaque = [];\n      this.stacks.transparent = []; // rebuild them with the new plane indexes\n\n      for (var i = 0; i < this.renderer.planes.length; i++) {\n        this.addPlane(this.renderer.planes[i]);\n      }\n    }\n    /***\r\n     Reset the shader pass stacks (used when disposing a shader pass)\r\n     ***/\n\n  }, {\n    key: \"resetShaderPassStacks\",\n    value: function resetShaderPassStacks() {\n      // now rebuild the drawStacks\n      // start by clearing all drawstacks\n      this.stacks.scenePasses = [];\n      this.stacks.renderPasses = []; // restack our planes with new indexes\n\n      for (var i = 0; i < this.renderer.shaderPasses.length; i++) {\n        this.renderer.shaderPasses[i].index = i;\n\n        if (this.renderer.shaderPasses[i]._isScenePass) {\n          this.stacks.scenePasses.push(this.renderer.shaderPasses[i]);\n        } else {\n          this.stacks.renderPasses.push(this.renderer.shaderPasses[i]);\n        }\n      } // reset the scenePassIndex if needed\n\n\n      if (this.stacks.scenePasses.length === 0) {\n        this.renderer.state.scenePassIndex = null;\n      }\n    }\n    /*** ADDING PLANES ***/\n\n    /***\r\n     Add a plane to our renderTargets stack\r\n       params:\r\n     @plane (Plane object): plane to add to our stack\r\n     ***/\n\n  }, {\n    key: \"addToRenderTargetsStack\",\n    value: function addToRenderTargetsStack(plane) {\n      // find all planes that are rendered onto a render target\n      var renderTargetsPlanes = this.renderer.planes.filter(function (el) {\n        return el.type !== \"PingPongPlane\" && el.target && el.uuid !== plane.uuid;\n      }); // is there any plane that is already rendered onto that plane's render target?\n\n      var siblingPlaneIndex = -1;\n\n      if (plane.target._depth) {\n        // findLastIndex\n        for (var i = renderTargetsPlanes.length - 1; i >= 0; i--) {\n          if (renderTargetsPlanes[i].target.uuid === plane.target.uuid) {\n            siblingPlaneIndex = i + 1;\n            break;\n          }\n        }\n      } else {\n        // findIndex\n        siblingPlaneIndex = renderTargetsPlanes.findIndex(function (el) {\n          return el.target.uuid === plane.target.uuid;\n        });\n      } // if findIndex returned -1, just push the plane\n\n\n      siblingPlaneIndex = Math.max(0, siblingPlaneIndex);\n      renderTargetsPlanes.splice(siblingPlaneIndex, 0, plane); // sort by index (order of addition) then render order, depending on whether the render target handle depth or not\n\n      if (plane.target._depth) {\n        renderTargetsPlanes.sort(function (a, b) {\n          return a.index - b.index;\n        });\n        renderTargetsPlanes.sort(function (a, b) {\n          return b.renderOrder - a.renderOrder;\n        });\n      } else {\n        renderTargetsPlanes.sort(function (a, b) {\n          return b.index - a.index;\n        });\n        renderTargetsPlanes.sort(function (a, b) {\n          return a.renderOrder - b.renderOrder;\n        });\n      } // sort by render targets order\n\n\n      renderTargetsPlanes.sort(function (a, b) {\n        return a.target.index - b.target.index;\n      });\n      this.stacks.renderTargets = renderTargetsPlanes;\n    }\n    /***\r\n     Rebuilds our regular stack (transparent or opaque) with our plane added, geometry IDs and then indexes (first added first drawn)\r\n       params:\r\n     @plane (Plane object): plane to add to our stack\r\n       returns:\r\n     @planeStack (array): our transparent or opaque stack ready to be applied custom sorting filter\r\n     ***/\n\n  }, {\n    key: \"addToRegularPlaneStack\",\n    value: function addToRegularPlaneStack(plane) {\n      // get all planes that have same transparency\n      var planeStack = this.renderer.planes.filter(function (el) {\n        return el.type !== \"PingPongPlane\" && !el.target && el._transparent === plane._transparent && el.uuid !== plane.uuid;\n      }); // find if there's already a plane with the same geometry with a findLastIndex function\n\n      var siblingPlaneIndex = -1;\n\n      for (var i = planeStack.length - 1; i >= 0; i--) {\n        if (planeStack[i]._geometry.definition.id === plane._geometry.definition.id) {\n          siblingPlaneIndex = i + 1;\n          break;\n        }\n      } // if findIndex returned -1 (no matching geometry or program)\n\n\n      siblingPlaneIndex = Math.max(0, siblingPlaneIndex); // add it to our stack plane array\n\n      planeStack.splice(siblingPlaneIndex, 0, plane); // sort by indexes\n\n      planeStack.sort(function (a, b) {\n        return a.index - b.index;\n      });\n      return planeStack;\n    }\n    /***\r\n     This function will add a plane into one of our 4 stacks : pingPong, renderTargets, transparent and opaque\r\n     - pingPong is just a simple array (ordered by order of creation)\r\n     - renderTargets array is ordered by render target creation order, planes renderOrder value and then planes indexes (order of creation)\r\n     - transparent array is ordered by renderOrder, Z positions, geometry IDs and then indexes (first added first drawn)\r\n     - opaque array is ordered by renderOrder, geometry IDs and then indexes (first added first drawn)\r\n       This is done to improve speed and reduce GL calls\r\n       params:\r\n     @plane (Plane object): plane to add to our scene\r\n     ***/\n\n  }, {\n    key: \"addPlane\",\n    value: function addPlane(plane) {\n      if (plane.type === \"PingPongPlane\") {\n        this.stacks.pingPong.push(plane);\n      } else if (plane.target) {\n        this.addToRenderTargetsStack(plane);\n      } else {\n        if (plane._transparent) {\n          // rebuild a stack of all transparent planes\n          var planeStack = this.addToRegularPlaneStack(plane); // sort by their depth position\n\n          planeStack.sort(function (a, b) {\n            return b.relativeTranslation.z - a.relativeTranslation.z;\n          }); // then sort by their render order\n\n          planeStack.sort(function (a, b) {\n            return b.renderOrder - a.renderOrder;\n          });\n          this.stacks.transparent = planeStack;\n        } else {\n          // rebuild a stack of all opaque planes\n          var _planeStack = this.addToRegularPlaneStack(plane); // then sort by their render order\n\n\n          _planeStack.sort(function (a, b) {\n            return b.renderOrder - a.renderOrder;\n          });\n\n          this.stacks.opaque = _planeStack;\n        }\n      }\n    }\n    /***\r\n     This function will remove a plane from our scene. This just reset the plane stacks for now.\r\n     Useful if we'd want to change the way our draw stacks work and keep the logic separated from our renderer\r\n       params:\r\n     @plane (Plane object): plane to remove from our scene\r\n     ***/\n\n  }, {\n    key: \"removePlane\",\n    value: function removePlane(plane) {\n      if (plane.type === \"PingPongPlane\") {\n        this.stacks.pingPong = this.stacks.pingPong.filter(function (el) {\n          return el.uuid !== plane.uuid;\n        });\n      } else if (plane.target) {\n        this.stacks.renderTargets = this.stacks.renderTargets.filter(function (el) {\n          return el.uuid !== plane.uuid;\n        });\n      } else {\n        if (plane._transparent) {\n          this.stacks.transparent = this.stacks.transparent.filter(function (el) {\n            return el.uuid !== plane.uuid;\n          });\n        } else {\n          this.stacks.opaque = this.stacks.opaque.filter(function (el) {\n            return el.uuid !== plane.uuid;\n          });\n        }\n      }\n    }\n    /***\r\n     Changing the position of a plane inside the correct plane stack to render it on above or behind the other planes\r\n       params:\r\n     @plane (Plane object): the plane that had its renderOrder property updated\r\n     ***/\n\n  }, {\n    key: \"setPlaneRenderOrder\",\n    value: function setPlaneRenderOrder(plane) {\n      if (plane.type === \"ShaderPass\") {\n        this.sortShaderPassStack(plane._isScenePass ? this.stacks.scenePasses : this.stacks.renderPasses);\n      } else if (plane.type === \"PingPongPlane\") {\n        // this does not makes any sense for ping pong planes\n        return;\n      }\n\n      if (plane.target) {\n        // sort by index (order of addition) then render order, depending on whether the render target handle depth or not\n        if (plane.target._depth) {\n          this.stacks.renderTargets.sort(function (a, b) {\n            return a.index - b.index;\n          });\n          this.stacks.renderTargets.sort(function (a, b) {\n            return b.renderOrder - a.renderOrder;\n          });\n        } else {\n          this.stacks.renderTargets.sort(function (a, b) {\n            return b.index - a.index;\n          });\n          this.stacks.renderTargets.sort(function (a, b) {\n            return a.renderOrder - b.renderOrder;\n          });\n        } // then sort by render targets order\n\n\n        this.stacks.renderTargets.sort(function (a, b) {\n          return a.target.index - b.target.index;\n        });\n      } else {\n        var planeStack = plane._transparent ? this.stacks.transparent : this.stacks.opaque; // if the first drawn scene pass does not handle depth, we'll have to sort them in the inverse order\n\n        var scenePassWithoutDepth = this.stacks.scenePasses.find(function (pass, index) {\n          return pass._isScenePass && !pass._depth && index === 0;\n        });\n\n        if (!this.renderer.depth || scenePassWithoutDepth) {\n          // inverted sorting\n          // sort by indexes\n          planeStack.sort(function (a, b) {\n            return b.index - a.index;\n          });\n\n          if (plane._transparent) {\n            // if plane is transparent, sort by their depth position\n            planeStack.sort(function (a, b) {\n              return a.relativeTranslation.z - b.relativeTranslation.z;\n            });\n          } // then sort by render order\n\n\n          planeStack.sort(function (a, b) {\n            return a.renderOrder - b.renderOrder;\n          });\n        } else {\n          // regular sorting\n          // sort by indexes\n          planeStack.sort(function (a, b) {\n            return a.index - b.index;\n          });\n\n          if (plane._transparent) {\n            // if plane is transparent, sort by their depth position\n            planeStack.sort(function (a, b) {\n              return b.relativeTranslation.z - a.relativeTranslation.z;\n            });\n          } // then sort by render order\n\n\n          planeStack.sort(function (a, b) {\n            return b.renderOrder - a.renderOrder;\n          });\n        }\n      }\n    }\n    /*** ADDING POST PROCESSING ***/\n\n    /***\r\n     Add a shader pass to the stack\r\n       params:\r\n     @shaderPass (ShaderPass object): shaderPass to add to our scene\r\n     ***/\n\n  }, {\n    key: \"addShaderPass\",\n    value: function addShaderPass(shaderPass) {\n      if (!shaderPass._isScenePass) {\n        this.stacks.renderPasses.push(shaderPass);\n        this.sortShaderPassStack(this.stacks.renderPasses);\n      } else {\n        this.stacks.scenePasses.push(shaderPass);\n        this.sortShaderPassStack(this.stacks.scenePasses);\n      }\n    }\n    /***\r\n     This function will remove a shader pass from our scene. This just reset the shaderPass stacks for now.\r\n     Useful if we'd want to change the way our draw stacks work and keep the logic separated from our renderer\r\n       params:\r\n     @shaderPass (ShaderPass object): shader pass to remove from our scene\r\n     ***/\n\n  }, {\n    key: \"removeShaderPass\",\n    value: function removeShaderPass(shaderPass) {\n      this.resetShaderPassStacks();\n    }\n    /***\r\n     Sorts the shader pass stack by index then by renderOrder property\r\n       params:\r\n     @passStack (array): which shader pass stack (scenePasses or renderPasses) to sort\r\n     ***/\n\n  }, {\n    key: \"sortShaderPassStack\",\n    value: function sortShaderPassStack(passStack) {\n      passStack.sort(function (a, b) {\n        return a.index - b.index;\n      });\n      passStack.sort(function (a, b) {\n        return a.renderOrder - b.renderOrder;\n      });\n    }\n    /*** DRAWING SCENE ***/\n\n    /***\r\n     Enable the first Shader pass scene pass\r\n     ***/\n\n  }, {\n    key: \"enableShaderPass\",\n    value: function enableShaderPass() {\n      if (this.stacks.scenePasses.length && this.stacks.renderPasses.length === 0 && this.renderer.planes.length) {\n        this.renderer.state.scenePassIndex = 0;\n        this.renderer.bindFrameBuffer(this.stacks.scenePasses[0].target);\n      }\n    }\n    /***\r\n     Draw the render passes\r\n     ***/\n\n  }, {\n    key: \"drawRenderPasses\",\n    value: function drawRenderPasses() {\n      // if we got one or multiple scene passes after the render passes, bind the first scene pass here\n      if (this.stacks.scenePasses.length && this.stacks.renderPasses.length && this.renderer.planes.length) {\n        this.renderer.state.scenePassIndex = 0;\n        this.renderer.bindFrameBuffer(this.stacks.scenePasses[0].target);\n      }\n\n      for (var i = 0; i < this.stacks.renderPasses.length; i++) {\n        this.stacks.renderPasses[i]._startDrawing(); // we need to clear our depth buffer to display previously drawn render passes\n\n\n        this.renderer.clearDepth();\n      }\n    }\n    /***\r\n     Draw the scene passes\r\n     ***/\n\n  }, {\n    key: \"drawScenePasses\",\n    value: function drawScenePasses() {\n      // then the scene passes\n      for (var i = 0; i < this.stacks.scenePasses.length; i++) {\n        this.stacks.scenePasses[i]._startDrawing();\n      }\n    }\n    /***\r\n     Loop through the special ping pong planes stack and draw its planes\r\n     ***/\n\n  }, {\n    key: \"drawPingPongStack\",\n    value: function drawPingPongStack() {\n      for (var i = 0; i < this.stacks.pingPong.length; i++) {\n        var plane = this.stacks.pingPong[i]; // be sure the plane exists\n\n        if (plane) {\n          // draw the plane\n          plane._startDrawing();\n        }\n      }\n    }\n    /***\r\n     Loop through one of our stack (renderTargets, opaque or transparent objects) and draw its planes\r\n     ***/\n\n  }, {\n    key: \"drawStack\",\n    value: function drawStack(stackType) {\n      for (var i = 0; i < this.stacks[stackType].length; i++) {\n        var plane = this.stacks[stackType][i]; // be sure the plane exists\n\n        if (plane) {\n          // draw the plane\n          plane._startDrawing();\n        }\n      }\n    }\n    /***\r\n     Draw our scene content\r\n     ***/\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      // always draw our ping pong planes first!\n      this.drawPingPongStack(); // enable first frame buffer for shader passes if needed\n\n      this.enableShaderPass(); // our planes that are drawn onto a render target\n\n      this.drawStack(\"renderTargets\"); // then draw the content of our render targets render passes\n\n      this.drawRenderPasses(); // disable blending for the opaque planes\n\n      this.renderer.setBlending(false); // loop on our stacked planes\n\n      this.drawStack(\"opaque\"); // set blending and draw transparents planes only if we have some\n\n      if (this.stacks.transparent.length) {\n        this.renderer.setBlending(true); // draw the transparent planes\n\n        this.drawStack(\"transparent\");\n      } // now draw the render targets scene passes\n\n\n      this.drawScenePasses();\n    }\n  }]);\n\n  return Scene;\n}();\n/***\r\n Here we create a CacheManager class object\r\n This will store geometries attributes arrays, textures and WebGL programs in arrays\r\n This helps speed up slow synchronous CPU operations such as WebGL shaders compilations, images decoding, etc.\r\n\r\n returns :\r\n @this: our CacheManager class object\r\n ***/\n\n\nvar CacheManager = /*#__PURE__*/function () {\n  function CacheManager() {\n    _classCallCheck(this, CacheManager);\n\n    // never clear cached geometries\n    this.geometries = [];\n    this.clear();\n  }\n  /***\r\n   Clear WebGL context depending cache arrays (used on init and context restoration)\r\n   ***/\n\n\n  _createClass(CacheManager, [{\n    key: \"clear\",\n    value: function clear() {\n      // only cache images textures for now\n      this.textures = []; // cached programs\n\n      this.programs = [];\n    }\n    /*** GEOMETRIES ***/\n\n    /***\r\n     Check if this geometry is already in our cached geometries array\r\n       params:\r\n     @definitionID (integer): the geometry ID\r\n     ***/\n\n  }, {\n    key: \"getGeometryFromID\",\n    value: function getGeometryFromID(definitionID) {\n      return this.geometries.find(function (element) {\n        return element.id === definitionID;\n      });\n    }\n    /***\r\n     Add a geometry to our cache if not already in it\r\n       params:\r\n     @definitionID  (integer): the geometry ID to add to our cache\r\n     @vertices (array): vertices coordinates array to add to our cache\r\n     @uvs (array): uvs coordinates array to add to our cache\r\n     ***/\n\n  }, {\n    key: \"addGeometry\",\n    value: function addGeometry(definitionID, vertices, uvs) {\n      this.geometries.push({\n        id: definitionID,\n        vertices: vertices,\n        uvs: uvs\n      });\n    }\n    /*** PROGRAMS ***/\n\n    /***\r\n     Compare two shaders strings to detect whether they are equal or not\r\n       params:\r\n     @firstShader (string): shader code\r\n     @secondShader (string): shader code\r\n       returns:\r\n     @isSameShader (bool): whether both shaders are equal or not\r\n     ***/\n\n  }, {\n    key: \"isSameShader\",\n    value: function isSameShader(firstShader, secondShader) {\n      return firstShader.localeCompare(secondShader) === 0;\n    }\n    /***\r\n     Returns a program from our cache if this program's vertex and fragment shaders code are the same as the one provided\r\n       params:\r\n     @vsCode (string): vertex shader code\r\n     @fsCode (string): fragment shader code\r\n       returns:\r\n     @program (Program class object or null): our program if it has been found\r\n     ***/\n\n  }, {\n    key: \"getProgramFromShaders\",\n    value: function getProgramFromShaders(vsCode, fsCode) {\n      var _this = this;\n\n      return this.programs.find(function (element) {\n        return _this.isSameShader(element.vsCode, vsCode) && _this.isSameShader(element.fsCode, fsCode);\n      });\n    }\n    /***\r\n     Add a program to our cache\r\n       params :\r\n     @program (Program class object) : program to add to our cache\r\n     ***/\n\n  }, {\n    key: \"addProgram\",\n    value: function addProgram(program) {\n      this.programs.push(program);\n    }\n    /*** TEXTURES ***/\n\n    /***\r\n     Check if this source is already in our cached textures array\r\n       params :\r\n     @source (HTML element) : html image, video or canvas element (only images for now)\r\n     ***/\n\n  }, {\n    key: \"getTextureFromSource\",\n    value: function getTextureFromSource(source) {\n      var src = typeof source === \"string\" ? source : source.src; // return the texture if the source is the same and if it's not the same texture\n\n      return this.textures.find(function (element) {\n        return element.source && element.source.src === src;\n      });\n    }\n    /***\r\n     Add a texture to our cache if not already in it\r\n       params :\r\n     @texture (Texture class object) : texture to add to our cache\r\n     ***/\n\n  }, {\n    key: \"addTexture\",\n    value: function addTexture(texture) {\n      var cachedTexture = this.getTextureFromSource(texture.source);\n\n      if (!cachedTexture) {\n        this.textures.push(texture);\n      }\n    }\n    /***\r\n     Removes a texture from the cache array\r\n       params :\r\n     @texture (Texture class object) : texture to remove from our cache\r\n     ***/\n\n  }, {\n    key: \"removeTexture\",\n    value: function removeTexture(texture) {\n      // remove from our textures array\n      this.textures = this.textures.filter(function (element) {\n        return element.uuid !== texture.uuid;\n      });\n    }\n  }]);\n\n  return CacheManager;\n}();\n/***\r\n Here we create a CallbackQueueManager class object\r\n This allows to store callbacks in a queue array with a timeout of 0 to be executed on next render call\r\n\r\n returns:\r\n @this: our CallbackQueueManager class object\r\n ***/\n\n\nvar CallbackQueueManager = /*#__PURE__*/function () {\n  function CallbackQueueManager() {\n    _classCallCheck(this, CallbackQueueManager);\n\n    this.clear();\n  }\n  /***\r\n   Clears our queue array (used on init)\r\n   ***/\n\n\n  _createClass(CallbackQueueManager, [{\n    key: \"clear\",\n    value: function clear() {\n      this.queue = [];\n    }\n    /***\r\n     Adds a callback to our queue list with a timeout of 0\r\n       params:\r\n     @callback (function): the callback to execute on next render call\r\n     @keep (bool): whether to keep calling that callback on each rendering call or not (act as a setInterval). Default to false\r\n       returns:\r\n     @queueItem: the queue item. Allows to keep a track of it and set its keep property to false when needed\r\n     ***/\n\n  }, {\n    key: \"add\",\n    value: function add(callback) {\n      var _this2 = this;\n\n      var keep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var queueItem = {\n        callback: callback,\n        keep: keep,\n        timeout: null // keep a reference to the timeout so we can safely delete if afterwards\n\n      };\n      queueItem.timeout = setTimeout(function () {\n        _this2.queue.push(queueItem);\n      }, 0);\n      return queueItem;\n    }\n    /***\r\n     Executes all callbacks in the queue and remove the ones that have their keep property set to false.\r\n     Called at the beginning of each render call\r\n     ***/\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this3 = this;\n\n      // execute queue callbacks list\n      this.queue.map(function (entry) {\n        if (entry.callback) {\n          entry.callback();\n        } // clear our timeout\n\n\n        clearTimeout(_this3.queue.timeout);\n      }); // remove all items that have their keep property set to false\n\n      this.queue = this.queue.filter(function (entry) {\n        return entry.keep;\n      });\n    }\n  }]);\n\n  return CallbackQueueManager;\n}();\n/***\r\n Here we create our Renderer object\r\n It will create our WebGL context and handle everything that relates to it\r\n Will create a container, append a canvas, handle WebGL extensions, context lost/restoration events\r\n Will create a Scene class object that will keep tracks of all added objects\r\n Will also handle all global WebGL commands, like clearing scene, binding frame buffers, setting depth, blend func, etc.\r\n Will use a state object to handle all those commands and keep a track of what is being drawned to avoid redundant WebGL calls.\r\n\r\n params:\r\n @Curtainsparams see Curtains class object\r\n\r\n @onError (function): called when there has been an error while initiating the WebGL context\r\n @onSuccess (function): called when the WebGL context has been successfully created\r\n @onContextLost (function): called when the WebGL context is lost\r\n @onContextRestored (function): called when the WebGL context is restored\r\n @onSceneChange (function): called every time an object has been added/removed from the scene\r\n\r\n returns :\r\n @this: our Renderer\r\n ***/\n\n\nvar Renderer = /*#__PURE__*/function () {\n  function Renderer(_ref2) {\n    var alpha = _ref2.alpha,\n        antialias = _ref2.antialias,\n        premultipliedAlpha = _ref2.premultipliedAlpha,\n        depth = _ref2.depth,\n        failIfMajorPerformanceCaveat = _ref2.failIfMajorPerformanceCaveat,\n        preserveDrawingBuffer = _ref2.preserveDrawingBuffer,\n        stencil = _ref2.stencil,\n        container = _ref2.container,\n        pixelRatio = _ref2.pixelRatio,\n        renderingScale = _ref2.renderingScale,\n        production = _ref2.production,\n        onError = _ref2.onError,\n        onSuccess = _ref2.onSuccess,\n        onContextLost = _ref2.onContextLost,\n        onContextRestored = _ref2.onContextRestored,\n        onDisposed = _ref2.onDisposed,\n        onSceneChange = _ref2.onSceneChange;\n\n    _classCallCheck(this, Renderer);\n\n    this.type = \"Renderer\"; // context attributes\n\n    this.alpha = alpha;\n    this.antialias = antialias;\n    this.premultipliedAlpha = premultipliedAlpha;\n    this.depth = depth;\n    this.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;\n    this.preserveDrawingBuffer = preserveDrawingBuffer;\n    this.stencil = stencil;\n    this.container = container;\n    this.pixelRatio = pixelRatio;\n    this._renderingScale = renderingScale;\n    this.production = production; // callbacks\n\n    this.onError = onError;\n    this.onSuccess = onSuccess;\n    this.onContextLost = onContextLost;\n    this.onContextRestored = onContextRestored;\n    this.onDisposed = onDisposed; // keep sync between Curtains objects arrays and renderer objects arrays\n\n    this.onSceneChange = onSceneChange; // managing our webgl draw states\n\n    this.initState(); // create the canvas\n\n    this.canvas = document.createElement(\"canvas\"); // set our webgl context\n\n    var glAttributes = {\n      alpha: this.alpha,\n      premultipliedAlpha: this.premultipliedAlpha,\n      antialias: this.antialias,\n      depth: this.depth,\n      failIfMajorPerformanceCaveat: this.failIfMajorPerformanceCaveat,\n      preserveDrawingBuffer: this.preserveDrawingBuffer,\n      stencil: this.stencil\n    }; // try webgl2 context first\n\n    this.gl = this.canvas.getContext(\"webgl2\", glAttributes);\n    this._isWebGL2 = !!this.gl; // fallback to webgl1\n\n    if (!this.gl) {\n      this.gl = this.canvas.getContext(\"webgl\", glAttributes) || this.canvas.getContext(\"experimental-webgl\", glAttributes);\n    } // WebGL context could not be created\n\n\n    if (!this.gl) {\n      if (!this.production) throwWarning(this.type + \": WebGL context could not be created\");\n      this.state.isActive = false;\n\n      if (this.onError) {\n        this.onError();\n      }\n\n      return;\n    } else if (this.onSuccess) {\n      this.onSuccess();\n    }\n\n    this.initRenderer();\n  }\n  /***\r\n   Set/reset our context state object\r\n   ***/\n\n\n  _createClass(Renderer, [{\n    key: \"initState\",\n    value: function initState() {\n      this.state = {\n        // if we are currently rendering\n        isActive: true,\n        isContextLost: true,\n        drawingEnabled: true,\n        forceRender: false,\n        // current program ID\n        currentProgramID: null,\n        // current geometry drawn\n        currentGeometryID: null,\n        // whether we should force buffer bindings update\n        forceBufferUpdate: false,\n        // if we're using depth test or not\n        depthTest: null,\n        // blending\n        blending: null,\n        // face culling\n        cullFace: null,\n        // current frame buffer ID\n        frameBufferID: null,\n        // current scene pass ID\n        scenePassIndex: null,\n        // textures\n        activeTexture: null,\n        unpackAlignment: null,\n        flipY: null,\n        premultiplyAlpha: null\n      };\n    }\n    /***\r\n     Add a callback queueing manager (execute functions on the next render call, see CallbackQueueManager class object)\r\n     ***/\n\n  }, {\n    key: \"initCallbackQueueManager\",\n    value: function initCallbackQueueManager() {\n      this.nextRender = new CallbackQueueManager();\n    }\n    /***\r\n     Init our renderer\r\n     ***/\n\n  }, {\n    key: \"initRenderer\",\n    value: function initRenderer() {\n      this.planes = [];\n      this.renderTargets = [];\n      this.shaderPasses = []; // context is not lost\n\n      this.state.isContextLost = false; // callback queue\n\n      this.initCallbackQueueManager(); // set blend func\n\n      this.setBlendFunc(); // enable depth by default\n\n      this.setDepthFunc();\n      this.setDepthTest(true); // texture cache\n\n      this.cache = new CacheManager(); // init our scene\n\n      this.scene = new Scene(this); // get webgl extensions\n\n      this.getExtensions(); // handling context\n\n      this._contextLostHandler = this.contextLost.bind(this);\n      this.canvas.addEventListener(\"webglcontextlost\", this._contextLostHandler, false);\n      this._contextRestoredHandler = this.contextRestored.bind(this);\n      this.canvas.addEventListener(\"webglcontextrestored\", this._contextRestoredHandler, false);\n    }\n    /***\r\n     Get all available WebGL extensions based on WebGL used version\r\n     Called on init and on context restoration\r\n     ***/\n\n  }, {\n    key: \"getExtensions\",\n    value: function getExtensions() {\n      this.extensions = [];\n\n      if (this._isWebGL2) {\n        this.extensions['EXT_color_buffer_float'] = this.gl.getExtension('EXT_color_buffer_float');\n        this.extensions['OES_texture_float_linear'] = this.gl.getExtension('OES_texture_float_linear');\n        this.extensions['EXT_texture_filter_anisotropic'] = this.gl.getExtension('EXT_texture_filter_anisotropic');\n        this.extensions['WEBGL_lose_context'] = this.gl.getExtension('WEBGL_lose_context');\n      } else {\n        this.extensions['OES_vertex_array_object'] = this.gl.getExtension('OES_vertex_array_object');\n        this.extensions['OES_texture_float'] = this.gl.getExtension('OES_texture_float');\n        this.extensions['OES_texture_float_linear'] = this.gl.getExtension('OES_texture_float_linear');\n        this.extensions['OES_texture_half_float'] = this.gl.getExtension('OES_texture_half_float');\n        this.extensions['OES_texture_half_float_linear'] = this.gl.getExtension('OES_texture_half_float_linear');\n        this.extensions['EXT_texture_filter_anisotropic'] = this.gl.getExtension('EXT_texture_filter_anisotropic');\n        this.extensions['OES_element_index_uint'] = this.gl.getExtension('OES_element_index_uint');\n        this.extensions['OES_standard_derivatives'] = this.gl.getExtension('OES_standard_derivatives');\n        this.extensions['EXT_sRGB'] = this.gl.getExtension('EXT_sRGB');\n        this.extensions['WEBGL_depth_texture'] = this.gl.getExtension('WEBGL_depth_texture');\n        this.extensions['WEBGL_draw_buffers'] = this.gl.getExtension('WEBGL_draw_buffers');\n        this.extensions['WEBGL_lose_context'] = this.gl.getExtension('WEBGL_lose_context');\n      }\n    }\n    /*** HANDLING CONTEXT LOST/RESTORE ***/\n\n    /***\r\n     Called when the WebGL context is lost\r\n     ***/\n\n  }, {\n    key: \"contextLost\",\n    value: function contextLost(event) {\n      var _this4 = this;\n\n      this.state.isContextLost = true; // do not try to restore the context if we're disposing everything!\n\n      if (!this.state.isActive) return;\n      event.preventDefault();\n      this.nextRender.add(function () {\n        return _this4.onContextLost && _this4.onContextLost();\n      });\n    }\n    /***\r\n     Call this method to restore your context\r\n     ***/\n\n  }, {\n    key: \"restoreContext\",\n    value: function restoreContext() {\n      // do not try to restore the context if we're disposing everything!\n      if (!this.state.isActive) return;\n      this.initState();\n\n      if (this.gl && this.extensions['WEBGL_lose_context']) {\n        this.extensions['WEBGL_lose_context'].restoreContext();\n      } else {\n        if (!this.gl && !this.production) {\n          throwWarning(this.type + \": Could not restore the context because the context is not defined\");\n        } else if (!this.extensions['WEBGL_lose_context'] && !this.production) {\n          throwWarning(this.type + \": Could not restore the context because the restore context extension is not defined\");\n        }\n\n        if (this.onError) {\n          this.onError();\n        }\n      }\n    }\n    /***\r\n     Check that all objects and textures have been restored\r\n       returns:\r\n     @isRestored (bool): whether everything has been restored or not\r\n     ***/\n\n  }, {\n    key: \"isContextexFullyRestored\",\n    value: function isContextexFullyRestored() {\n      var isRestored = true;\n\n      for (var i = 0; i < this.renderTargets.length; i++) {\n        if (!this.renderTargets[i].textures[0]._canDraw) {\n          isRestored = false;\n        }\n\n        break;\n      }\n\n      if (isRestored) {\n        for (var _i = 0; _i < this.planes.length; _i++) {\n          if (!this.planes[_i]._canDraw) {\n            isRestored = false;\n            break;\n          } else {\n            for (var j = 0; j < this.planes[_i].textures.length; j++) {\n              if (!this.planes[_i].textures[j]._canDraw) {\n                isRestored = false;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      if (isRestored) {\n        for (var _i2 = 0; _i2 < this.shaderPasses.length; _i2++) {\n          if (!this.shaderPasses[_i2]._canDraw) {\n            isRestored = false;\n            break;\n          } else {\n            for (var _j = 0; _j < this.shaderPasses[_i2].textures.length; _j++) {\n              if (!this.shaderPasses[_i2].textures[_j]._canDraw) {\n                isRestored = false;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      return isRestored;\n    }\n    /***\r\n     Called when the WebGL context is restored\r\n     ***/\n\n  }, {\n    key: \"contextRestored\",\n    value: function contextRestored() {\n      var _this5 = this;\n\n      this.getExtensions(); // set blend func\n\n      this.setBlendFunc(); // enable depth by default\n\n      this.setDepthFunc();\n      this.setDepthTest(true); // clear texture and programs cache\n\n      this.cache.clear(); // reset draw stacks\n\n      this.scene.initStacks(); // we need to reset everything : planes programs, shaders, buffers and textures !\n\n      for (var i = 0; i < this.renderTargets.length; i++) {\n        this.renderTargets[i]._restoreContext();\n      }\n\n      for (var _i3 = 0; _i3 < this.planes.length; _i3++) {\n        this.planes[_i3]._restoreContext();\n      } // same goes for shader passes\n\n\n      for (var _i4 = 0; _i4 < this.shaderPasses.length; _i4++) {\n        this.shaderPasses[_i4]._restoreContext();\n      } // callback if everything is restored\n\n\n      var isRestoredQueue = this.nextRender.add(function () {\n        var isRestored = _this5.isContextexFullyRestored();\n\n        if (isRestored) {\n          isRestoredQueue.keep = false; // start drawing again\n\n          _this5.state.isContextLost = false;\n\n          if (_this5.onContextRestored) {\n            _this5.onContextRestored();\n          } // we've changed the objects, keep Curtains class in sync with our renderer\n\n\n          _this5.onSceneChange(); // force next frame render whatever our drawing flag value\n\n\n          _this5.needRender();\n        }\n      }, true);\n    }\n    /*** SIZING ***/\n\n    /***\r\n     Updates pixelRatio property\r\n     ***/\n\n  }, {\n    key: \"setPixelRatio\",\n    value: function setPixelRatio(pixelRatio) {\n      this.pixelRatio = pixelRatio;\n    }\n    /***\r\n     Set/reset container sizes and WebGL viewport sizes\r\n     ***/\n\n  }, {\n    key: \"setSize\",\n    value: function setSize() {\n      if (!this.gl) return; // get our container bounding client rectangle\n\n      var containerBoundingRect = this.container.getBoundingClientRect(); // use the bounding rect values\n\n      this._boundingRect = {\n        width: containerBoundingRect.width * this.pixelRatio,\n        height: containerBoundingRect.height * this.pixelRatio,\n        top: containerBoundingRect.top * this.pixelRatio,\n        left: containerBoundingRect.left * this.pixelRatio\n      }; // iOS Safari > 8+ has a known bug due to navigation bar appearing/disappearing\n      // this causes wrong bounding client rect calculations, especially negative top value when it shouldn't\n      // to fix this we'll use a dirty but useful workaround\n      // first we check if we're on iOS Safari\n\n      var isSafari = !!navigator.userAgent.match(/Version\\/[\\d\\.]+.*Safari/);\n      var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n      if (isSafari && iOS) {\n        // if we are on iOS Safari we'll need a custom function to retrieve our container absolute top position\n        function getTopOffset(el) {\n          var topOffset = 0;\n\n          while (el && !isNaN(el.offsetTop)) {\n            topOffset += el.offsetTop - el.scrollTop;\n            el = el.offsetParent;\n          }\n\n          return topOffset;\n        } // use it to update our top value\n\n\n        this._boundingRect.top = getTopOffset(this.container) * this.pixelRatio;\n      }\n\n      this.canvas.style.width = Math.floor(this._boundingRect.width / this.pixelRatio) + \"px\";\n      this.canvas.style.height = Math.floor(this._boundingRect.height / this.pixelRatio) + \"px\";\n      this.canvas.width = Math.floor(this._boundingRect.width * this._renderingScale);\n      this.canvas.height = Math.floor(this._boundingRect.height * this._renderingScale);\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n    /***\r\n     Resize all our elements: planes, shader passes and render targets\r\n     Their textures will be resized as well\r\n     ***/\n\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      // resize the planes only if they are fully initiated\n      for (var i = 0; i < this.planes.length; i++) {\n        if (this.planes[i]._canDraw) {\n          this.planes[i].resize();\n        }\n      } // resize the shader passes only if they are fully initiated\n\n\n      for (var _i5 = 0; _i5 < this.shaderPasses.length; _i5++) {\n        if (this.shaderPasses[_i5]._canDraw) {\n          this.shaderPasses[_i5].resize();\n        }\n      } // resize the render targets\n\n\n      for (var _i6 = 0; _i6 < this.renderTargets.length; _i6++) {\n        this.renderTargets[_i6].resize();\n      } // be sure we'll update the scene even if drawing is disabled\n\n\n      this.needRender();\n    }\n    /*** CLEAR SCENE ***/\n\n    /***\r\n     Clear our WebGL scene colors and depth\r\n     ***/\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n    }\n    /***\r\n     Clear our WebGL scene depth\r\n     ***/\n\n  }, {\n    key: \"clearDepth\",\n    value: function clearDepth() {\n      this.gl.clear(this.gl.DEPTH_BUFFER_BIT);\n    }\n    /***\r\n     Clear our WebGL scene colors and depth\r\n     ***/\n\n  }, {\n    key: \"clearColor\",\n    value: function clearColor() {\n      this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    }\n    /*** FRAME BUFFER OBJECTS ***/\n\n    /***\r\n     Called to bind or unbind a FBO\r\n       params:\r\n     @frameBuffer (frameBuffer): if frameBuffer is not null, bind it, unbind it otherwise\r\n     @cancelClear (bool / undefined): if we should cancel clearing the frame buffer (typically on init & resize)\r\n     ***/\n\n  }, {\n    key: \"bindFrameBuffer\",\n    value: function bindFrameBuffer(frameBuffer, cancelClear) {\n      var bufferId = null;\n\n      if (frameBuffer) {\n        bufferId = frameBuffer.index; // new frame buffer, bind it\n\n        if (bufferId !== this.state.frameBufferID) {\n          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, frameBuffer._frameBuffer);\n          this.gl.viewport(0, 0, frameBuffer._size.width, frameBuffer._size.height); // if we should clear the buffer content\n\n          if (frameBuffer._shouldClear && !cancelClear) {\n            this.clear();\n          }\n        }\n      } else if (this.state.frameBufferID !== null) {\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n      }\n\n      this.state.frameBufferID = bufferId;\n    }\n    /*** DEPTH ***/\n\n    /***\r\n     Called to set whether the renderer will handle depth test or not\r\n     Depth test is enabled by default\r\n       params:\r\n     @setDepth (boolean): if we should enable or disable the depth test\r\n     ***/\n\n  }, {\n    key: \"setDepthTest\",\n    value: function setDepthTest(depthTest) {\n      if (depthTest && !this.state.depthTest) {\n        this.state.depthTest = depthTest; // enable depth test\n\n        this.gl.enable(this.gl.DEPTH_TEST);\n      } else if (!depthTest && this.state.depthTest) {\n        this.state.depthTest = depthTest; // disable depth test\n\n        this.gl.disable(this.gl.DEPTH_TEST);\n      }\n    }\n    /***\r\n     Called to set the depth buffer behavior\r\n     Only available option is gl.LEQUAL at the moment\r\n     (see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/depthFunc)\r\n     ***/\n\n  }, {\n    key: \"setDepthFunc\",\n    value: function setDepthFunc() {\n      this.gl.depthFunc(this.gl.LEQUAL);\n    }\n    /*** BLENDING ***/\n\n    /***\r\n     Whether we should enable or disable the blending state\r\n     Used to draw transparent planes\r\n       params:\r\n     @enableBlending (boolean): if we should enable or disable the blending (default to false)\r\n     ***/\n\n  }, {\n    key: \"setBlending\",\n    value: function setBlending() {\n      var enableBlending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (enableBlending && !this.state.blending) {\n        this.state.blending = enableBlending; // enable blending\n\n        this.gl.enable(this.gl.BLEND);\n      } else if (!enableBlending && this.state.blending) {\n        this.state.blending = enableBlending; // disable blending\n\n        this.gl.disable(this.gl.BLEND);\n      }\n    }\n    /***\r\n     Called to set the blending function (transparency)\r\n     ***/\n\n  }, {\n    key: \"setBlendFunc\",\n    value: function setBlendFunc() {\n      // allows transparency\n      // based on how three.js solves this\n      this.gl.enable(this.gl.BLEND);\n\n      if (this.premultipliedAlpha) {\n        this.gl.blendFuncSeparate(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);\n      } else {\n        this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);\n      }\n    }\n    /*** FACE CULLING ***/\n\n    /***\r\n     Called to set whether we should cull an object face or not\r\n       params:\r\n     @cullFace (boolean): what face we should cull\r\n     ***/\n\n  }, {\n    key: \"setFaceCulling\",\n    value: function setFaceCulling(cullFace) {\n      if (this.state.cullFace !== cullFace) {\n        this.state.cullFace = cullFace;\n\n        if (cullFace === \"none\") {\n          this.gl.disable(this.gl.CULL_FACE);\n        } else {\n          // default to back face culling\n          var faceCulling = cullFace === \"front\" ? this.gl.FRONT : this.gl.BACK;\n          this.gl.enable(this.gl.CULL_FACE);\n          this.gl.cullFace(faceCulling);\n        }\n      }\n    }\n    /***\r\n     Tell WebGL to use the specified program if it's not already in use\r\n       params:\r\n     @program (object): a program object\r\n     ***/\n\n  }, {\n    key: \"useProgram\",\n    value: function useProgram(program) {\n      if (this.state.currentProgramID === null || this.state.currentProgramID !== program.id) {\n        this.gl.useProgram(program.program);\n        this.state.currentProgramID = program.id;\n      }\n    }\n    /*** PLANES ***/\n\n    /***\r\n     Removes a Plane element (that has already been disposed) from the scene and the planes array\r\n       params:\r\n     @plane (Plane object): the plane to remove\r\n     ***/\n\n  }, {\n    key: \"removePlane\",\n    value: function removePlane(plane) {\n      if (!this.gl) return; // remove from our planes array\n\n      this.planes = this.planes.filter(function (element) {\n        return element.uuid !== plane.uuid;\n      }); // remove from scene stacks\n\n      this.scene.removePlane(plane);\n      plane = null; // clear the buffer to clean scene\n\n      if (this.gl) this.clear(); // we've removed an object, keep Curtains class in sync with our renderer\n\n      this.onSceneChange();\n    }\n    /*** POST PROCESSING ***/\n\n    /***\r\n     Completely remove a RenderTarget element\r\n       params:\r\n     @renderTarget (RenderTarget object): the render target to remove\r\n     ***/\n\n  }, {\n    key: \"removeRenderTarget\",\n    value: function removeRenderTarget(renderTarget) {\n      if (!this.gl) return;\n      var hasPlane = this.planes.find(function (plane) {\n        return plane.type !== \"PingPongPlane\" && plane.target && plane.target.uuid === renderTarget.uuid;\n      }); // loop through all planes that might use that render target and reset it\n\n      for (var i = 0; i < this.planes.length; i++) {\n        if (this.planes[i].target && this.planes[i].target.uuid === renderTarget.uuid) {\n          this.planes[i].target = null;\n        }\n      }\n\n      this.renderTargets = this.renderTargets.filter(function (element) {\n        return element.uuid !== renderTarget.uuid;\n      }); // update render target indexes\n\n      for (var _i7 = 0; _i7 < this.renderTargets.length; _i7++) {\n        this.renderTargets[_i7].index = _i7;\n      }\n\n      renderTarget = null; // clear the buffer to clean scene\n\n      if (this.gl) this.clear(); // we had at least a plane that was rendered in this render targets stack\n      // re init stacks\n\n      if (hasPlane) {\n        this.scene.resetPlaneStacks();\n      } // we've removed an object, keep Curtains class in sync with our renderer\n\n\n      this.onSceneChange();\n    }\n    /*** SHADER PASSES ***/\n\n    /***\r\n     Removes a ShaderPass element (that has already been disposed) from the scene and the shaderPasses array\r\n       params:\r\n     @shaderPass (ShaderPass object): the shader pass to remove\r\n     ***/\n\n  }, {\n    key: \"removeShaderPass\",\n    value: function removeShaderPass(shaderPass) {\n      if (!this.gl) return; // remove from shaderPasses our array\n\n      this.shaderPasses = this.shaderPasses.filter(function (element) {\n        return element.uuid !== shaderPass.uuid;\n      }); // remove from scene stacks\n\n      this.scene.removeShaderPass(shaderPass);\n      shaderPass = null; // clear the buffer to clean scene\n\n      if (this.gl) this.clear(); // we've removed an object, keep Curtains class in sync with our renderer\n\n      this.onSceneChange();\n    }\n    /***\r\n     Enables the render loop\r\n     ***/\n\n  }, {\n    key: \"enableDrawing\",\n    value: function enableDrawing() {\n      this.state.drawingEnabled = true;\n    }\n    /***\r\n     Disables the render loop\r\n     ***/\n\n  }, {\n    key: \"disableDrawing\",\n    value: function disableDrawing() {\n      this.state.drawingEnabled = false;\n    }\n    /***\r\n     Forces the rendering of the next frame, even if disabled\r\n     ***/\n\n  }, {\n    key: \"needRender\",\n    value: function needRender() {\n      this.state.forceRender = true;\n    }\n    /***\r\n     Called at each draw call to render our scene and its content\r\n     Also execute our nextRender callback queue\r\n     ***/\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.gl) return; // clear scene first\n\n      this.clear(); // reset attributes buffer state\n\n      this.state.currentGeometryID = null; // draw our scene content\n\n      this.scene.draw();\n    }\n    /*** DISPOSING ***/\n\n    /***\r\n     Delete all cached programs\r\n     ***/\n\n  }, {\n    key: \"deletePrograms\",\n    value: function deletePrograms() {\n      // delete all programs from manager\n      for (var i = 0; i < this.cache.programs.length; i++) {\n        var program = this.cache.programs[i];\n        this.gl.deleteProgram(program.program);\n      }\n    }\n    /***\r\n     Dispose our WebGL context and all its objects\r\n     ***/\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this6 = this;\n\n      if (!this.gl) return;\n      this.state.isActive = false; // be sure to delete all planes\n\n      while (this.planes.length > 0) {\n        this.removePlane(this.planes[0]);\n      } // we need to delete the shader passes also\n\n\n      while (this.shaderPasses.length > 0) {\n        this.removeShaderPass(this.shaderPasses[0]);\n      } // finally we need to delete the render targets\n\n\n      while (this.renderTargets.length > 0) {\n        this.removeRenderTarget(this.renderTargets[0]);\n      } // wait for all planes to be deleted before stopping everything\n\n\n      var disposeQueue = this.nextRender.add(function () {\n        if (_this6.planes.length === 0 && _this6.shaderPasses.length === 0 && _this6.renderTargets.length === 0) {\n          // clear from callback queue\n          disposeQueue.keep = false;\n\n          _this6.deletePrograms(); // clear the buffer to clean scene\n\n\n          _this6.clear();\n\n          _this6.canvas.removeEventListener(\"webgllost\", _this6._contextLostHandler, false);\n\n          _this6.canvas.removeEventListener(\"webglrestored\", _this6._contextRestoredHandler, false); // lose context\n\n\n          if (_this6.gl && _this6.extensions['WEBGL_lose_context']) {\n            _this6.extensions['WEBGL_lose_context'].loseContext();\n          } // clear canvas state\n\n\n          _this6.canvas.width = _this6.canvas.width;\n          _this6.gl = null; // remove canvas from DOM\n\n          _this6.container.removeChild(_this6.canvas);\n\n          _this6.container = null;\n          _this6.canvas = null;\n          _this6.onDisposed && _this6.onDisposed();\n        }\n      }, true);\n    }\n  }]);\n\n  return Renderer;\n}();\n/***\r\n Here we create a ScrollManager class object\r\n This keeps track of our scroll position, scroll deltas and triggers an onScroll callback\r\n Could either listen to the native scroll event or be hooked to any scroll (natural or virtual) scroll event\r\n\r\n params:\r\n @xOffset (float): scroll along X axis\r\n @yOffset (float): scroll along Y axis\r\n @lastXDelta (float): last scroll delta along X axis\r\n @lastYDelta (float): last scroll delta along Y axis\r\n\r\n @shouldWatch (bool): if the scroll manager should listen to the scroll event or not. Default to true.\r\n\r\n @onScroll (function): callback to execute each time the scroll values changed\r\n\r\n returns:\r\n @this: our ScrollManager class object\r\n ***/\n\n\nvar ScrollManager = /*#__PURE__*/function () {\n  function ScrollManager() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$xOffset = _ref3.xOffset,\n        xOffset = _ref3$xOffset === void 0 ? 0 : _ref3$xOffset,\n        _ref3$yOffset = _ref3.yOffset,\n        yOffset = _ref3$yOffset === void 0 ? 0 : _ref3$yOffset,\n        _ref3$lastXDelta = _ref3.lastXDelta,\n        lastXDelta = _ref3$lastXDelta === void 0 ? 0 : _ref3$lastXDelta,\n        _ref3$lastYDelta = _ref3.lastYDelta,\n        lastYDelta = _ref3$lastYDelta === void 0 ? 0 : _ref3$lastYDelta,\n        _ref3$shouldWatch = _ref3.shouldWatch,\n        shouldWatch = _ref3$shouldWatch === void 0 ? true : _ref3$shouldWatch,\n        _ref3$onScroll = _ref3.onScroll,\n        onScroll = _ref3$onScroll === void 0 ? function () {} : _ref3$onScroll;\n\n    _classCallCheck(this, ScrollManager);\n\n    this.xOffset = xOffset;\n    this.yOffset = yOffset;\n    this.lastXDelta = lastXDelta;\n    this.lastYDelta = lastYDelta;\n    this.shouldWatch = shouldWatch;\n    this.onScroll = onScroll; // keep a ref to our scroll event\n\n    this.handler = this.scroll.bind(this, true);\n\n    if (this.shouldWatch) {\n      window.addEventListener(\"scroll\", this.handler, {\n        passive: true\n      });\n    }\n  }\n  /***\r\n   Called by the scroll event listener\r\n   ***/\n\n\n  _createClass(ScrollManager, [{\n    key: \"scroll\",\n    value: function scroll() {\n      this.updateScrollValues(window.pageXOffset, window.pageYOffset);\n    }\n    /***\r\n     Updates the scroll manager X and Y scroll values as well as last X and Y deltas\r\n     Internally called by the scroll handler\r\n     Could be called externally as well if the user wants to handle the scroll by himself\r\n       params:\r\n     @x (float): scroll value along X axis\r\n     @y (float): scroll value along Y axis\r\n     ***/\n\n  }, {\n    key: \"updateScrollValues\",\n    value: function updateScrollValues(x, y) {\n      // get our scroll delta values\n      var lastScrollXValue = this.xOffset;\n      this.xOffset = x;\n      this.lastXDelta = lastScrollXValue - this.xOffset;\n      var lastScrollYValue = this.yOffset;\n      this.yOffset = y;\n      this.lastYDelta = lastScrollYValue - this.yOffset;\n\n      if (this.onScroll) {\n        this.onScroll(this.lastXDelta, this.lastYDelta);\n      }\n    }\n    /***\r\n     Dispose our scroll manager (just remove our event listner if it had been added previously)\r\n     ***/\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.shouldWatch) {\n        window.removeEventListener(\"scroll\", this.handler, {\n          passive: true\n        });\n      }\n    }\n  }]);\n\n  return ScrollManager;\n}();\n\nvar version = \"8.1.0\";\n/***\r\n Here we create our Curtains object\r\n\r\n\r\n params:\r\n @container (HTML element or string, optional): the container HTML element or ID that will hold our canvas. Could be set later if not passed as parameter here\r\n\r\n (WebGL context parameters)\r\n @alpha (bool, optional): whether the WebGL context should handle transparency. Default to true.\r\n @premultipliedAlpha (bool, optional): whether the WebGL context should handle premultiplied alpha. Default to false.\r\n @antialias (bool, optional): whether the WebGL context should use the default antialiasing. When using render targets, WebGL disables antialiasing, so you can safely set this to false to improve the performance. Default to true.\r\n @depth (bool, optional): whether the WebGL context should handle depth. Default to true.\r\n @failIfMajorPerformanceCaveat (bool, optional): whether the WebGL context creation should fail in case of major performance caveat. Default to true.\r\n @preserveDrawingBuffer (bool, optional): whether the WebGL context should preserve the drawing buffer. Default to false.\r\n @stencil (bool, optional): whether the WebGL context should handle stencil. Default to false.\r\n\r\n @autoResize (bool, optional): Whether the library should listen to the window resize event and actually resize the scene. Set it to false if you want to handle this by yourself using the resize() method. Default to true.\r\n @autoRender (bool, optional): Whether the library should create a request animation frame loop to render the scene. Set it to false if you want to handle this by yourself using the render() method. Default to true.\r\n @watchScroll (bool, optional): Whether the library should listen to the window scroll event. Set it to false if you want to handle this by yourself. Default to true.\r\n\r\n @pixelRatio (float, optional): Defines the pixel ratio value. Use it to limit it on init to increase performance. Default to window.devicePixelRatio.\r\n @renderingScale (float, optional): Use it to downscale your rendering canvas. May improve performance but will decrease quality. Default to 1 (minimum: 0.25, maximum: 1).\r\n\r\n @production (bool, optional): Whether the library should throw useful console warnings and errors and check shaders and programs compilation status. Default to false.\r\n\r\n returns :\r\n @this: our Renderer\r\n ***/\n\nvar Curtains = /*#__PURE__*/function () {\n  function Curtains() {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        container = _ref4.container,\n        _ref4$alpha = _ref4.alpha,\n        alpha = _ref4$alpha === void 0 ? true : _ref4$alpha,\n        _ref4$premultipliedAl = _ref4.premultipliedAlpha,\n        premultipliedAlpha = _ref4$premultipliedAl === void 0 ? false : _ref4$premultipliedAl,\n        _ref4$antialias = _ref4.antialias,\n        antialias = _ref4$antialias === void 0 ? true : _ref4$antialias,\n        _ref4$depth = _ref4.depth,\n        depth = _ref4$depth === void 0 ? true : _ref4$depth,\n        _ref4$failIfMajorPerf = _ref4.failIfMajorPerformanceCaveat,\n        failIfMajorPerformanceCaveat = _ref4$failIfMajorPerf === void 0 ? true : _ref4$failIfMajorPerf,\n        _ref4$preserveDrawing = _ref4.preserveDrawingBuffer,\n        preserveDrawingBuffer = _ref4$preserveDrawing === void 0 ? false : _ref4$preserveDrawing,\n        _ref4$stencil = _ref4.stencil,\n        stencil = _ref4$stencil === void 0 ? false : _ref4$stencil,\n        _ref4$autoResize = _ref4.autoResize,\n        autoResize = _ref4$autoResize === void 0 ? true : _ref4$autoResize,\n        _ref4$autoRender = _ref4.autoRender,\n        autoRender = _ref4$autoRender === void 0 ? true : _ref4$autoRender,\n        _ref4$watchScroll = _ref4.watchScroll,\n        watchScroll = _ref4$watchScroll === void 0 ? true : _ref4$watchScroll,\n        _ref4$pixelRatio = _ref4.pixelRatio,\n        pixelRatio = _ref4$pixelRatio === void 0 ? window.devicePixelRatio || 1 : _ref4$pixelRatio,\n        _ref4$renderingScale = _ref4.renderingScale,\n        renderingScale = _ref4$renderingScale === void 0 ? 1 : _ref4$renderingScale,\n        _ref4$production = _ref4.production,\n        production = _ref4$production === void 0 ? false : _ref4$production;\n\n    _classCallCheck(this, Curtains);\n\n    this.type = \"Curtains\"; // if we should use auto resize (default to true)\n\n    this._autoResize = autoResize; // if we should use auto render (default to true)\n\n    this._autoRender = autoRender; // if we should watch the scroll (default to true)\n\n    this._watchScroll = watchScroll; // pixel ratio and rendering scale\n\n    this.pixelRatio = pixelRatio; // rendering scale\n\n    renderingScale = isNaN(renderingScale) ? 1 : parseFloat(renderingScale);\n    this._renderingScale = Math.max(0.25, Math.min(1, renderingScale)); // webgl context parameters\n\n    this.premultipliedAlpha = premultipliedAlpha;\n    this.alpha = alpha;\n    this.antialias = antialias;\n    this.depth = depth;\n    this.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;\n    this.preserveDrawingBuffer = preserveDrawingBuffer;\n    this.stencil = stencil;\n    this.production = production;\n    this.errors = false; // if a container has been provided, proceed to init\n\n    if (container) {\n      this.setContainer(container);\n    } else if (!this.production) {\n      throwWarning(this.type + \": no container provided in the initial parameters. Use setContainer() method to set one later and initialize the WebGL context\");\n    }\n  }\n  /***\r\n   Set up our Curtains container and start initializing everything\r\n   Called on Curtains instancing if a params container has been provided, could be call afterwards else\r\n   Useful with JS frameworks to init our Curtains class globally and then set the container in a canvas component afterwards to fully instantiate everything\r\n     params:\r\n   @container (HTML element or string): the container HTML element or ID that will hold our canvas\r\n   ***/\n\n\n  _createClass(Curtains, [{\n    key: \"setContainer\",\n    value: function setContainer(container) {\n      if (!container) {\n        var _container = document.createElement(\"div\");\n\n        _container.setAttribute(\"id\", \"curtains-canvas\");\n\n        document.body.appendChild(_container);\n        this.container = _container;\n        if (!this.production) throwWarning('Curtains: no valid container HTML element or ID provided, created a div with \"curtains-canvas\" ID instead');\n      } else {\n        if (typeof container === \"string\") {\n          container = document.getElementById(container);\n\n          if (!container) {\n            var _container2 = document.createElement(\"div\");\n\n            _container2.setAttribute(\"id\", \"curtains-canvas\");\n\n            document.body.appendChild(_container2);\n            this.container = _container2;\n            if (!this.production) throwWarning('Curtains: no valid container HTML element or ID provided, created a div with \"curtains-canvas\" ID instead');\n          } else {\n            this.container = container;\n          }\n        } else if (container instanceof Element) {\n          this.container = container;\n        }\n      }\n\n      this._initCurtains();\n    }\n    /***\r\n     Initialize everything that the class will need: WebGL renderer, scroll manager, sizes, listeners\r\n     Then starts our animation frame loop if needed\r\n     ***/\n\n  }, {\n    key: \"_initCurtains\",\n    value: function _initCurtains() {\n      this.planes = [];\n      this.renderTargets = [];\n      this.shaderPasses = []; // init webgl context\n\n      this._initRenderer();\n\n      if (!this.gl) return; // scroll\n\n      this._initScroll(); // sizes\n\n\n      this._setSize(); // event listeners\n\n\n      this._addListeners(); // we are ready to go\n\n\n      this.container.appendChild(this.canvas); // watermark\n\n      console.log(\"curtains.js - v\" + version); // start rendering\n\n      this._animationFrameID = null;\n\n      if (this._autoRender) {\n        this._animate();\n      }\n    }\n    /*** WEBGL CONTEXT ***/\n\n    /***\r\n     Initialize the Renderer class object\r\n     ***/\n\n  }, {\n    key: \"_initRenderer\",\n    value: function _initRenderer() {\n      var _this7 = this;\n\n      this.renderer = new Renderer({\n        alpha: this.alpha,\n        antialias: this.antialias,\n        premultipliedAlpha: this.premultipliedAlpha,\n        depth: this.depth,\n        failIfMajorPerformanceCaveat: this.failIfMajorPerformanceCaveat,\n        preserveDrawingBuffer: this.preserveDrawingBuffer,\n        stencil: this.stencil,\n        container: this.container,\n        pixelRatio: this.pixelRatio,\n        renderingScale: this._renderingScale,\n        production: this.production,\n        onError: function onError() {\n          return _this7._onRendererError();\n        },\n        onSuccess: function onSuccess() {\n          return _this7._onRendererSuccess();\n        },\n        onContextLost: function onContextLost() {\n          return _this7._onRendererContextLost();\n        },\n        onContextRestored: function onContextRestored() {\n          return _this7._onRendererContextRestored();\n        },\n        onDisposed: function onDisposed() {\n          return _this7._onRendererDisposed();\n        },\n        // keep sync between renderer planes, shader passes and render targets arrays and the Curtains ones\n        onSceneChange: function onSceneChange() {\n          return _this7._keepSync();\n        }\n      });\n      this.gl = this.renderer.gl;\n      this.canvas = this.renderer.canvas;\n    }\n    /***\r\n     Force our renderer to restore the WebGL context\r\n     ***/\n\n  }, {\n    key: \"restoreContext\",\n    value: function restoreContext() {\n      this.renderer.restoreContext();\n    }\n    /***\r\n     This just handles our drawing animation frame\r\n     ***/\n\n  }, {\n    key: \"_animate\",\n    value: function _animate() {\n      this.render();\n      this._animationFrameID = window.requestAnimationFrame(this._animate.bind(this));\n    }\n    /*** RENDERING ***/\n\n    /***\r\n     Enables rendering\r\n     ***/\n\n  }, {\n    key: \"enableDrawing\",\n    value: function enableDrawing() {\n      this.renderer.enableDrawing();\n    }\n    /***\r\n     Disables rendering\r\n     ***/\n\n  }, {\n    key: \"disableDrawing\",\n    value: function disableDrawing() {\n      this.renderer.disableDrawing();\n    }\n    /***\r\n     Forces the rendering of the next frame, even if disabled\r\n     ***/\n\n  }, {\n    key: \"needRender\",\n    value: function needRender() {\n      this.renderer.needRender();\n    }\n    /***\r\n     Executes a callback on next frame\r\n       params:\r\n     @callback (function): callback to execute on next frame\r\n     @keep (bool): whether to keep calling that callback on each rendering call or not (act as a setInterval). Default to false\r\n       returns:\r\n     @queueItem: the queue item. Allows to keep a track of it and set its keep property to false when needed\r\n     ***/\n\n  }, {\n    key: \"nextRender\",\n    value: function nextRender(callback) {\n      var keep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.renderer.nextRender.add(callback, keep);\n    }\n    /***\r\n     Clear our WebGL renderer colors and depth buffers\r\n     ***/\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.renderer && this.renderer.clear();\n    }\n    /***\r\n     Clear our WebGL renderer depth buffer\r\n     ***/\n\n  }, {\n    key: \"clearDepth\",\n    value: function clearDepth() {\n      this.renderer && this.renderer.clearDepth();\n    }\n    /***\r\n     Clear our WebGL renderer color buffer\r\n     ***/\n\n  }, {\n    key: \"clearColor\",\n    value: function clearColor() {\n      this.renderer && this.renderer.clearColor();\n    }\n    /***\r\n     Check whether the created context is WebGL2\r\n       return:\r\n     @isWebGL2 (bool): whether the created WebGL context is 2.0 or not\r\n     ***/\n\n  }, {\n    key: \"isWebGL2\",\n    value: function isWebGL2() {\n      return this.gl ? this.renderer._isWebGL2 : false;\n    }\n    /***\r\n     Tells our renderer to render the scene if the drawing is enabled\r\n     ***/\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      // always execute callback queue\n      this.renderer.nextRender.execute(); // If forceRender is true, force rendering this frame even if drawing is not enabled.\n      // If not, only render if enabled.\n\n      if (!this.renderer.state.drawingEnabled && !this.renderer.state.forceRender) {\n        return;\n      } // reset forceRender\n\n\n      if (this.renderer.state.forceRender) {\n        this.renderer.state.forceRender = false;\n      } // Curtains onRender callback\n\n\n      if (this._onRenderCallback) {\n        this._onRenderCallback();\n      }\n\n      this.renderer.render();\n    }\n    /*** LISTENERS ***/\n\n    /***\r\n     Adds our resize event listener if needed\r\n     ***/\n\n  }, {\n    key: \"_addListeners\",\n    value: function _addListeners() {\n      // handling window resize event\n      this._resizeHandler = null;\n\n      if (this._autoResize) {\n        this._resizeHandler = this.resize.bind(this, true);\n        window.addEventListener(\"resize\", this._resizeHandler, false);\n      }\n    }\n    /*** SIZING ***/\n\n    /***\r\n     Set the pixel ratio property and update everything by calling the resize() method\r\n     ***/\n\n  }, {\n    key: \"setPixelRatio\",\n    value: function setPixelRatio(pixelRatio, triggerCallback) {\n      this.pixelRatio = parseFloat(Math.max(pixelRatio, 1)) || 1;\n      this.renderer.setPixelRatio(pixelRatio); // apply new pixel ratio to all our elements but don't trigger onAfterResize callback\n\n      this.resize(triggerCallback);\n    }\n    /***\r\n     Set our renderer container and canvas sizes and update the scroll values\r\n     ***/\n\n  }, {\n    key: \"_setSize\",\n    value: function _setSize() {\n      this.renderer.setSize(); // update scroll values ass well\n\n      if (this._scrollManager.shouldWatch) {\n        this._scrollManager.xOffset = window.pageXOffset;\n        this._scrollManager.yOffset = window.pageYOffset;\n      }\n    }\n    /***\r\n     Useful to get our container bounding rectangle without triggering a reflow/layout\r\n       returns :\r\n     @boundingRectangle (object): an object containing our container bounding rectangle (width, height, top and left properties)\r\n     ***/\n\n  }, {\n    key: \"getBoundingRect\",\n    value: function getBoundingRect() {\n      return this.renderer._boundingRect;\n    }\n    /***\r\n     Resize our container and the renderer\r\n       params:\r\n     @triggerCallback (bool): Whether we should trigger onAfterResize callback\r\n     ***/\n\n  }, {\n    key: \"resize\",\n    value: function resize(triggerCallback) {\n      var _this8 = this;\n\n      if (!this.gl) return;\n\n      this._setSize();\n\n      this.renderer.resize();\n      this.nextRender(function () {\n        if (_this8._onAfterResizeCallback && triggerCallback) {\n          _this8._onAfterResizeCallback();\n        }\n      });\n    }\n    /*** SCROLL ***/\n\n    /***\r\n     Init our ScrollManager class object\r\n     ***/\n\n  }, {\n    key: \"_initScroll\",\n    value: function _initScroll() {\n      var _this9 = this;\n\n      this._scrollManager = new ScrollManager({\n        // init values\n        xOffset: window.pageXOffset,\n        yOffset: window.pageYOffset,\n        lastXDelta: 0,\n        lastYDelta: 0,\n        shouldWatch: this._watchScroll,\n        onScroll: function onScroll(lastXDelta, lastYDelta) {\n          return _this9._updateScroll(lastXDelta, lastYDelta);\n        }\n      });\n    }\n    /***\r\n     Handles the different values associated with a scroll event (scroll and delta values)\r\n     If no plane watch the scroll then those values won't be retrieved to avoid unnecessary reflow calls\r\n     If at least a plane is watching, update all watching planes positions based on the scroll values\r\n     And force render for at least one frame to actually update the scene\r\n     ***/\n\n  }, {\n    key: \"_updateScroll\",\n    value: function _updateScroll(lastXDelta, lastYDelta) {\n      for (var i = 0; i < this.planes.length; i++) {\n        // if our plane is watching the scroll, update its position\n        if (this.planes[i].watchScroll) {\n          this.planes[i].updateScrollPosition(lastXDelta, lastYDelta);\n        }\n      } // be sure we'll update the scene even if drawing is disabled\n\n\n      this.renderer.needRender();\n      this._onScrollCallback && this._onScrollCallback();\n    }\n    /***\r\n     Updates the scroll manager X and Y scroll values as well as last X and Y deltas\r\n     Internally called by the scroll handler if at least one plane is watching the scroll\r\n     Could be called externally as well if the user wants to handle the scroll by himself\r\n       params:\r\n     @x (float): scroll value along X axis\r\n     @y (float): scroll value along Y axis\r\n     ***/\n\n  }, {\n    key: \"updateScrollValues\",\n    value: function updateScrollValues(x, y) {\n      this._scrollManager.updateScrollValues(x, y);\n    }\n    /***\r\n     Returns last delta scroll values\r\n       returns:\r\n     @delta (object): an object containing X and Y last delta values\r\n     ***/\n\n  }, {\n    key: \"getScrollDeltas\",\n    value: function getScrollDeltas() {\n      return {\n        x: this._scrollManager.lastXDelta,\n        y: this._scrollManager.lastYDelta\n      };\n    }\n    /***\r\n     Returns last window scroll values\r\n       returns:\r\n     @scrollValues (object): an object containing X and Y last scroll values\r\n     ***/\n\n  }, {\n    key: \"getScrollValues\",\n    value: function getScrollValues() {\n      return {\n        x: this._scrollManager.xOffset,\n        y: this._scrollManager.yOffset\n      };\n    }\n    /*** ADDING / REMOVING OBJECTS TO THE RENDERER ***/\n\n    /***\r\n     Always keep sync between renderer and Curtains scene objects when adding/removing objects\r\n     ***/\n\n  }, {\n    key: \"_keepSync\",\n    value: function _keepSync() {\n      this.planes = this.renderer.planes;\n      this.shaderPasses = this.renderer.shaderPasses;\n      this.renderTargets = this.renderer.renderTargets;\n    }\n    /*** UTILS ***/\n\n    /***\r\n     Linear interpolation helper defined in utils\r\n     ***/\n\n  }, {\n    key: \"lerp\",\n    value: function lerp(start, end, amount) {\n      return _lerp(start, end, amount);\n    }\n    /*** EVENTS ***/\n\n    /***\r\n     This is called each time our container has been resized\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our Curtains element to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onAfterResize\",\n    value: function onAfterResize(callback) {\n      if (callback) {\n        this._onAfterResizeCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called when an error has been detected\r\n       params:\r\n     @callback (function): a function to execute\r\n       returns:\r\n     @this: our Curtains element to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      if (callback) {\n        this._onErrorCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This triggers the onError callback and is called by the renderer when an error has been detected\r\n     ***/\n\n  }, {\n    key: \"_onRendererError\",\n    value: function _onRendererError() {\n      var _this10 = this;\n\n      // be sure that the callback has been registered and only call the global error callback once\n      setTimeout(function () {\n        if (_this10._onErrorCallback && !_this10.errors) {\n          _this10._onErrorCallback();\n        }\n\n        _this10.errors = true;\n      }, 0);\n    }\n    /***\r\n     This is called when the WebGL context has been successfully created\r\n       params:\r\n     @callback (function): a function to execute\r\n       returns:\r\n     @this: our Curtains element to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onSuccess\",\n    value: function onSuccess(callback) {\n      if (callback) {\n        this._onSuccessCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This triggers the onSuccess callback and is called by the renderer when the context has been successfully created\r\n     ***/\n\n  }, {\n    key: \"_onRendererSuccess\",\n    value: function _onRendererSuccess() {\n      var _this11 = this;\n\n      setTimeout(function () {\n        _this11._onSuccessCallback && _this11._onSuccessCallback();\n      }, 0);\n    }\n    /***\r\n     This is called once our context has been lost\r\n       params:\r\n     @callback (function): a function to execute\r\n       returns:\r\n     @this: our Curtains element to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onContextLost\",\n    value: function onContextLost(callback) {\n      if (callback) {\n        this._onContextLostCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This triggers the onContextLost callback and is called by the renderer when the context has been lost\r\n     ***/\n\n  }, {\n    key: \"_onRendererContextLost\",\n    value: function _onRendererContextLost() {\n      this._onContextLostCallback && this._onContextLostCallback();\n    }\n    /***\r\n     This is called once our context has been restored\r\n       params:\r\n     @callback (function): a function to execute\r\n       returns:\r\n     @this: our Curtains element to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onContextRestored\",\n    value: function onContextRestored(callback) {\n      if (callback) {\n        this._onContextRestoredCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This triggers the onContextRestored callback and is called by the renderer when the context has been restored\r\n     ***/\n\n  }, {\n    key: \"_onRendererContextRestored\",\n    value: function _onRendererContextRestored() {\n      this._onContextRestoredCallback && this._onContextRestoredCallback();\n    }\n    /***\r\n     This is called once at each request animation frame call\r\n       params:\r\n     @callback (function): a function to execute\r\n       returns:\r\n     @this: our Curtains element to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onRender\",\n    value: function onRender(callback) {\n      if (callback) {\n        this._onRenderCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called each time window is scrolled and if our scrollManager is active\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our Curtains element to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onScroll\",\n    value: function onScroll(callback) {\n      if (callback) {\n        this._onScrollCallback = callback;\n      }\n\n      return this;\n    }\n    /*** DESTROYING ***/\n\n    /***\r\n     Dispose everything\r\n     ***/\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.renderer.dispose();\n    }\n    /***\r\n     This is called when the renderer has finished disposing all the WebGL stuff\r\n     ***/\n\n  }, {\n    key: \"_onRendererDisposed\",\n    value: function _onRendererDisposed() {\n      // cancel animation frame\n      this._animationFrameID && window.cancelAnimationFrame(this._animationFrameID); // remove event listeners\n\n      this._resizeHandler && window.removeEventListener(\"resize\", this._resizeHandler, false);\n      this._scrollManager && this._scrollManager.dispose();\n    }\n  }]);\n\n  return Curtains;\n}();\n/***\r\n Uniforms class manages uniforms setting and updating\r\n\r\n params:\r\n @renderer (Renderer class object): our renderer class object\r\n @program (object): our mesh's Program (see Program class object)\r\n\r\n @uniforms (object): our uniforms object:\r\n - name (string): uniform name to use in your shaders\r\n - type (uniform type): uniform type. Will try to detect it if not set (see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform)\r\n - value (float / int / Vec2 / Vec3 / Mat4 / array): initial value of the uniform\r\n\r\n returns:\r\n @this: our Uniforms manager\r\n ***/\n\n\nvar Uniforms = /*#__PURE__*/function () {\n  function Uniforms(renderer, program, uniforms) {\n    _classCallCheck(this, Uniforms);\n\n    this.type = \"Uniforms\";\n\n    if (!renderer || renderer.type !== \"Renderer\") {\n      throwError(this.type + \": Renderer not passed as first argument\", renderer);\n    } else if (!renderer.gl) {\n      throwError(this.type + \": Renderer WebGL context is undefined\", renderer); // return if no gl context\n\n      return;\n    }\n\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n    this.program = program;\n    this.uniforms = {};\n\n    if (uniforms) {\n      for (var key in uniforms) {\n        var uniform = uniforms[key]; // fill our uniform object\n\n        this.uniforms[key] = {\n          name: uniform.name,\n          type: uniform.type,\n          // clone value if possible, use original value else\n          value: uniform.value.clone && typeof uniform.value.clone === \"function\" ? uniform.value.clone() : uniform.value,\n          update: null\n        };\n      }\n    }\n  }\n  /***\r\n   Set uniforms WebGL function based on their types\r\n     params :\r\n   @uniform (object): the uniform\r\n   ***/\n\n\n  _createClass(Uniforms, [{\n    key: \"handleUniformSetting\",\n    value: function handleUniformSetting(uniform) {\n      switch (uniform.type) {\n        case \"1i\":\n          uniform.update = this.setUniform1i.bind(this);\n          break;\n\n        case \"1iv\":\n          uniform.update = this.setUniform1iv.bind(this);\n          break;\n\n        case \"1f\":\n          uniform.update = this.setUniform1f.bind(this);\n          break;\n\n        case \"1fv\":\n          uniform.update = this.setUniform1fv.bind(this);\n          break;\n\n        case \"2i\":\n          uniform.update = this.setUniform2i.bind(this);\n          break;\n\n        case \"2iv\":\n          uniform.update = this.setUniform2iv.bind(this);\n          break;\n\n        case \"2f\":\n          uniform.update = this.setUniform2f.bind(this);\n          break;\n\n        case \"2fv\":\n          uniform.update = this.setUniform2fv.bind(this);\n          break;\n\n        case \"3i\":\n          uniform.update = this.setUniform3i.bind(this);\n          break;\n\n        case \"3iv\":\n          uniform.update = this.setUniform3iv.bind(this);\n          break;\n\n        case \"3f\":\n          uniform.update = this.setUniform3f.bind(this);\n          break;\n\n        case \"3fv\":\n          uniform.update = this.setUniform3fv.bind(this);\n          break;\n\n        case \"4i\":\n          uniform.update = this.setUniform4i.bind(this);\n          break;\n\n        case \"4iv\":\n          uniform.update = this.setUniform4iv.bind(this);\n          break;\n\n        case \"4f\":\n          uniform.update = this.setUniform4f.bind(this);\n          break;\n\n        case \"4fv\":\n          uniform.update = this.setUniform4fv.bind(this);\n          break;\n\n        case \"mat2\":\n          uniform.update = this.setUniformMatrix2fv.bind(this);\n          break;\n\n        case \"mat3\":\n          uniform.update = this.setUniformMatrix3fv.bind(this);\n          break;\n\n        case \"mat4\":\n          uniform.update = this.setUniformMatrix4fv.bind(this);\n          break;\n\n        default:\n          if (!this.renderer.production) throwWarning(this.type + \": This uniform type is not handled : \", uniform.type);\n      }\n    }\n    /***\r\n     Auto detect the format of the uniform (check if its a float, an integer, a Vector, a Matrix, an array...)\r\n     Also set a lastValue property that we'll use to compare to our value property and update the uniform if it changed\r\n       params :\r\n     @uniform (object): the uniform\r\n     ***/\n\n  }, {\n    key: \"setInternalFormat\",\n    value: function setInternalFormat(uniform) {\n      if (uniform.value.type === \"Vec2\") {\n        uniform._internalFormat = \"Vec2\";\n        uniform.lastValue = uniform.value.clone();\n      } else if (uniform.value.type === \"Vec3\") {\n        uniform._internalFormat = \"Vec3\";\n        uniform.lastValue = uniform.value.clone();\n      } else if (uniform.value.type === \"Mat4\") {\n        uniform._internalFormat = \"Mat4\";\n        uniform.lastValue = uniform.value.clone();\n      } else if (uniform.value.type === \"Quat\") {\n        uniform._internalFormat = \"Quat\";\n        uniform.lastValue = uniform.value.clone();\n      } else if (Array.isArray(uniform.value)) {\n        uniform._internalFormat = \"array\";\n        uniform.lastValue = Array.from(uniform.value);\n      } else if (uniform.value.constructor === Float32Array) {\n        uniform._internalFormat = \"mat\";\n        uniform.lastValue = uniform.value;\n      } else {\n        uniform._internalFormat = \"float\";\n        uniform.lastValue = uniform.value;\n      }\n    }\n    /***\r\n     This inits our uniforms\r\n     Sets its internal format and type if not provided then upload the uniform\r\n     ***/\n\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      // set our uniforms if we got some\n      if (this.uniforms) {\n        for (var key in this.uniforms) {\n          var uniform = this.uniforms[key]; // set our uniform location\n\n          uniform.location = this.gl.getUniformLocation(this.program, uniform.name); // handle Vec2, Vec3, Mat4, floats, arrays, etc\n\n          if (!uniform._internalFormat) {\n            this.setInternalFormat(uniform);\n          }\n\n          if (!uniform.type) {\n            if (uniform._internalFormat === \"Vec2\") {\n              uniform.type = \"2f\";\n            } else if (uniform._internalFormat === \"Vec3\") {\n              uniform.type = \"3f\";\n            } else if (uniform._internalFormat === \"Mat4\") {\n              uniform.type = \"mat4\";\n            } else if (uniform._internalFormat === \"array\") {\n              if (uniform.value.length === 4) {\n                uniform.type = \"4f\";\n                if (!this.renderer.production) throwWarning(this.type + \": No uniform type declared for \" + uniform.name + \", applied a 4f (array of 4 floats) uniform type\");\n              } else if (uniform.value.length === 3) {\n                uniform.type = \"3f\";\n                if (!this.renderer.production) throwWarning(this.type + \": No uniform type declared for \" + uniform.name + \", applied a 3f (array of 3 floats) uniform type\");\n              } else if (uniform.value.length === 2) {\n                uniform.type = \"2f\";\n                if (!this.renderer.production) throwWarning(this.type + \": No uniform type declared for \" + uniform.name + \", applied a 2f (array of 2 floats) uniform type\");\n              }\n            } else if (uniform._internalFormat === \"mat\") {\n              if (uniform.value.length === 16) {\n                uniform.type = \"mat4\";\n                if (!this.renderer.production) throwWarning(this.type + \": No uniform type declared for \" + uniform.name + \", applied a mat4 (4x4 matrix array) uniform type\");\n              } else if (uniform.value.length === 9) {\n                uniform.type = \"mat3\";\n                if (!this.renderer.production) throwWarning(this.type + \": No uniform type declared for \" + uniform.name + \", applied a mat3 (3x3 matrix array) uniform type\");\n              } else if (uniform.value.length === 4) {\n                uniform.type = \"mat2\";\n                if (!this.renderer.production) throwWarning(this.type + \": No uniform type declared for \" + uniform.name + \", applied a mat2 (2x2 matrix array) uniform type\");\n              }\n            } else {\n              uniform.type = \"1f\";\n              if (!this.renderer.production) throwWarning(this.type + \": No uniform type declared for \" + uniform.name + \", applied a 1f (float) uniform type\");\n            }\n          } // set the uniforms update functions\n\n\n          this.handleUniformSetting(uniform); // update the uniform\n\n          uniform.update && uniform.update(uniform);\n        }\n      }\n    }\n    /***\r\n     This updates all uniforms of an object that were set by the user\r\n     It is called at each draw call\r\n     ***/\n\n  }, {\n    key: \"updateUniforms\",\n    value: function updateUniforms() {\n      if (this.uniforms) {\n        for (var key in this.uniforms) {\n          var uniform = this.uniforms[key];\n          var shouldUpdate = false;\n\n          if (uniform._internalFormat === \"Vec2\") {\n            if (!uniform.value.equals(uniform.lastValue)) {\n              shouldUpdate = true;\n              uniform.lastValue.copy(uniform.value);\n            }\n          } else if (uniform._internalFormat === \"Vec3\") {\n            if (!uniform.value.equals(uniform.lastValue)) {\n              shouldUpdate = true;\n              uniform.lastValue.copy(uniform.value);\n            }\n          } else if (uniform._internalFormat === \"Quat\") {\n            if (!uniform.value.equals(uniform.lastValue)) {\n              shouldUpdate = true;\n              uniform.lastValue.copy(uniform.value);\n            }\n          } else if (!uniform.value.length) {\n            if (uniform.value !== uniform.lastValue) {\n              shouldUpdate = true;\n              uniform.lastValue = uniform.value;\n            }\n          } else if (JSON.stringify(uniform.value) !== JSON.stringify(uniform.lastValue)) {\n            // compare two arrays\n            shouldUpdate = true; // copy array\n\n            uniform.lastValue = Array.from(uniform.value);\n          }\n\n          if (shouldUpdate) {\n            // update our uniforms\n            uniform.update && uniform.update(uniform);\n          }\n        }\n      }\n    }\n    /***\r\n     Use appropriate WebGL uniform setting function based on the uniform type\r\n       params :\r\n     @uniform (object): the uniform\r\n     ***/\n\n  }, {\n    key: \"setUniform1i\",\n    value: function setUniform1i(uniform) {\n      this.gl.uniform1i(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform1iv\",\n    value: function setUniform1iv(uniform) {\n      this.gl.uniform1iv(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform1f\",\n    value: function setUniform1f(uniform) {\n      this.gl.uniform1f(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform1fv\",\n    value: function setUniform1fv(uniform) {\n      this.gl.uniform1fv(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform2i\",\n    value: function setUniform2i(uniform) {\n      uniform._internalFormat === \"Vec2\" ? this.gl.uniform2i(uniform.location, uniform.value.x, uniform.value.y) : this.gl.uniform2i(uniform.location, uniform.value[0], uniform.value[1]);\n    }\n  }, {\n    key: \"setUniform2iv\",\n    value: function setUniform2iv(uniform) {\n      uniform._internalFormat === \"Vec2\" ? this.gl.uniform2iv(uniform.location, [uniform.value.x, uniform.value.y]) : this.gl.uniform2iv(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform2f\",\n    value: function setUniform2f(uniform) {\n      uniform._internalFormat === \"Vec2\" ? this.gl.uniform2f(uniform.location, uniform.value.x, uniform.value.y) : this.gl.uniform2f(uniform.location, uniform.value[0], uniform.value[1]);\n    }\n  }, {\n    key: \"setUniform2fv\",\n    value: function setUniform2fv(uniform) {\n      uniform._internalFormat === \"Vec2\" ? this.gl.uniform2fv(uniform.location, [uniform.value.x, uniform.value.y]) : this.gl.uniform2fv(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform3i\",\n    value: function setUniform3i(uniform) {\n      uniform._internalFormat === \"Vec3\" ? this.gl.uniform3i(uniform.location, uniform.value.x, uniform.value.y, uniform.value.z) : this.gl.uniform3i(uniform.location, uniform.value[0], uniform.value[1], uniform.value[2]);\n    }\n  }, {\n    key: \"setUniform3iv\",\n    value: function setUniform3iv(uniform) {\n      uniform._internalFormat === \"Vec3\" ? this.gl.uniform3iv(uniform.location, [uniform.value.x, uniform.value.y, uniform.value.z]) : this.gl.uniform3iv(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform3f\",\n    value: function setUniform3f(uniform) {\n      uniform._internalFormat === \"Vec3\" ? this.gl.uniform3f(uniform.location, uniform.value.x, uniform.value.y, uniform.value.z) : this.gl.uniform3f(uniform.location, uniform.value[0], uniform.value[1], uniform.value[2]);\n    }\n  }, {\n    key: \"setUniform3fv\",\n    value: function setUniform3fv(uniform) {\n      uniform._internalFormat === \"Vec3\" ? this.gl.uniform3fv(uniform.location, [uniform.value.x, uniform.value.y, uniform.value.z]) : this.gl.uniform3fv(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform4i\",\n    value: function setUniform4i(uniform) {\n      uniform._internalFormat === \"Quat\" ? this.gl.uniform4i(uniform.location, uniform.value.elements[0], uniform.value.elements[1], uniform.value.elements[2], uniform.value[3]) : this.gl.uniform4i(uniform.location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);\n    }\n  }, {\n    key: \"setUniform4iv\",\n    value: function setUniform4iv(uniform) {\n      uniform._internalFormat === \"Quat\" ? this.gl.uniform4iv(uniform.location, [uniform.value.elements[0], uniform.value.elements[1], uniform.value.elements[2], uniform.value[3]]) : this.gl.uniform4iv(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniform4f\",\n    value: function setUniform4f(uniform) {\n      uniform._internalFormat === \"Quat\" ? this.gl.uniform4f(uniform.location, uniform.value.elements[0], uniform.value.elements[1], uniform.value.elements[2], uniform.value[3]) : this.gl.uniform4f(uniform.location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);\n    }\n  }, {\n    key: \"setUniform4fv\",\n    value: function setUniform4fv(uniform) {\n      uniform._internalFormat === \"Quat\" ? this.gl.uniform4fv(uniform.location, [uniform.value.elements[0], uniform.value.elements[1], uniform.value.elements[2], uniform.value[3]]) : this.gl.uniform4fv(uniform.location, uniform.value);\n    }\n  }, {\n    key: \"setUniformMatrix2fv\",\n    value: function setUniformMatrix2fv(uniform) {\n      this.gl.uniformMatrix2fv(uniform.location, false, uniform.value);\n    }\n  }, {\n    key: \"setUniformMatrix3fv\",\n    value: function setUniformMatrix3fv(uniform) {\n      this.gl.uniformMatrix3fv(uniform.location, false, uniform.value);\n    }\n  }, {\n    key: \"setUniformMatrix4fv\",\n    value: function setUniformMatrix4fv(uniform) {\n      uniform._internalFormat === \"Mat4\" ? this.gl.uniformMatrix4fv(uniform.location, false, uniform.value.elements) : this.gl.uniformMatrix4fv(uniform.location, false, uniform.value);\n    }\n  }]);\n\n  return Uniforms;\n}();\n\nvar precisionMedium = \"\\nprecision mediump float;\\n\";\nvar precisionMedium$1 = precisionMedium.replace(/\\n/g, '');\nvar defaultAttributes = \"\\nattribute vec3 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\";\nvar defaultAttributes$1 = defaultAttributes.replace(/\\n/g, '');\nvar defaultVaryings = \"\\nvarying vec3 vVertexPosition;\\nvarying vec2 vTextureCoord;\\n\";\nvar defaultVaryings$1 = defaultVaryings.replace(/\\n/g, '');\nvar planeVS = precisionMedium$1 + defaultAttributes$1 + defaultVaryings$1 + \"\\nuniform mat4 uMVMatrix;\\nuniform mat4 uPMatrix;\\n\\nvoid main() {\\n    vTextureCoord = aTextureCoord;\\n    vVertexPosition = aVertexPosition;\\n    \\n    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\\n}\\n\";\nvar planeVS$1 = planeVS.replace(/\\n/g, '');\nvar planeFS = precisionMedium$1 + defaultVaryings$1 + \"\\nvoid main() {\\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n}\\n\";\nvar planeFS$1 = planeFS.replace(/\\n/g, '');\nvar shaderPassVS = precisionMedium$1 + defaultAttributes$1 + defaultVaryings$1 + \"\\nvoid main() {\\n    vTextureCoord = aTextureCoord;\\n    vVertexPosition = aVertexPosition;\\n    \\n    gl_Position = vec4(aVertexPosition, 1.0);\\n}\\n\";\nvar shaderPassVS$1 = shaderPassVS.replace(/\\n/g, '');\nvar shaderPassFS = precisionMedium$1 + defaultVaryings$1 + \"\\nuniform sampler2D uRenderTexture;\\n\\nvoid main() {\\n    gl_FragColor = texture2D(uRenderTexture, vTextureCoord);\\n}\\n\";\nvar shaderPassFS$1 = shaderPassFS.replace(/\\n/g, '');\n/***\r\n Program class that creates, compiles and links the shaders\r\n Use a cache system to get already compiled shaders and save some CPU\r\n Also responsible for the creation, setting and updating of the uniforms (see Uniforms class object)\r\n\r\n params:\r\n @renderer (Renderer class object): our renderer class object\r\n\r\n @parent (Plane/ShaderPass class object): the mesh that will use that program\r\n @vertexShader (string): vertex shader as a string\r\n @fragmentShader (string): fragment shader as a string\r\n\r\n returns:\r\n @this: our newly created Program\r\n ***/\n// store programs id\n\nvar id = 0;\n\nvar Program = /*#__PURE__*/function () {\n  function Program(renderer) {\n    var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        parent = _ref5.parent,\n        vertexShader = _ref5.vertexShader,\n        fragmentShader = _ref5.fragmentShader;\n\n    _classCallCheck(this, Program);\n\n    this.type = \"Program\";\n\n    if (!renderer || renderer.type !== \"Renderer\") {\n      throwError(this.type + \": Renderer not passed as first argument\", renderer);\n    } else if (!renderer.gl) {\n      throwError(this.type + \": Renderer WebGL context is undefined\", renderer); // return if no gl context\n\n      return;\n    }\n\n    this.renderer = renderer;\n    this.gl = this.renderer.gl;\n    this.parent = parent;\n    this.defaultVsCode = this.parent.type === \"Plane\" ? planeVS$1 : shaderPassVS$1;\n    this.defaultFsCode = this.parent.type === \"Plane\" ? planeFS$1 : shaderPassFS$1; // use the vertex shader specified or fallback to a default one\n\n    if (!vertexShader) {\n      if (!this.renderer.production && this.parent.type === \"Plane\") {\n        throwWarning(this.parent.type + \": No vertex shader provided, will use a default one\");\n      }\n\n      this.vsCode = this.defaultVsCode;\n    } else {\n      this.vsCode = vertexShader;\n    } // use the fragment shader specified or fallback to a default one\n\n\n    if (!fragmentShader) {\n      if (!this.renderer.production) {\n        throwWarning(this.parent.type + \": No fragment shader provided, will use a default one\");\n      }\n\n      this.fsCode = this.defaultFsCode;\n    } else {\n      this.fsCode = fragmentShader;\n    }\n\n    this.compiled = true;\n    this.setupProgram();\n  }\n  /***\r\n   Compile our WebGL shaders based on our written shaders\r\n     params:\r\n   @shaderCode (string): shader code\r\n   @shaderType (shaderType): WebGL shader type (vertex or fragment)\r\n     returns:\r\n   @shader (compiled shader): our compiled shader\r\n   ***/\n\n\n  _createClass(Program, [{\n    key: \"createShader\",\n    value: function createShader(shaderCode, shaderType) {\n      var shader = this.gl.createShader(shaderType);\n      this.gl.shaderSource(shader, shaderCode);\n      this.gl.compileShader(shader); // check shader compilation status only when not in production mode\n\n      if (!this.renderer.production) {\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n          // shader debugging log as seen in THREE.js WebGLProgram source code\n          var shaderTypeString = shaderType === this.gl.VERTEX_SHADER ? \"vertex shader\" : \"fragment shader\";\n          var shaderSource = this.gl.getShaderSource(shader);\n          var shaderLines = shaderSource.split('\\n');\n\n          for (var i = 0; i < shaderLines.length; i++) {\n            shaderLines[i] = i + 1 + ': ' + shaderLines[i];\n          }\n\n          shaderLines = shaderLines.join(\"\\n\");\n          throwWarning(this.type + \": Errors occurred while compiling the\", shaderTypeString, \":\\n\", this.gl.getShaderInfoLog(shader));\n          throwError(shaderLines);\n          throwWarning(this.type + \": Will use a default\", shaderTypeString); // use the library default shaders instead\n\n          return this.createShader(shaderType === this.gl.VERTEX_SHADER ? this.defaultVsCode : this.defaultFsCode, shaderType);\n        }\n      }\n\n      return shader;\n    }\n    /***\r\n     Compiles and creates new shaders\r\n     ***/\n\n  }, {\n    key: \"useNewShaders\",\n    value: function useNewShaders() {\n      this.vertexShader = this.createShader(this.vsCode, this.gl.VERTEX_SHADER);\n      this.fragmentShader = this.createShader(this.fsCode, this.gl.FRAGMENT_SHADER);\n\n      if (!this.vertexShader || !this.fragmentShader) {\n        if (!this.renderer.production) throwWarning(this.type + \": Unable to find or compile the vertex or fragment shader\");\n      }\n    }\n  }, {\n    key: \"setupProgram\",\n    value:\n    /***\r\n     Checks whether the program has already been registered before creating it\r\n     If yes, use the compiled shaders to create a new one with createProgram()\r\n     If not, compile the shaders and call createProgram()\r\n     ***/\n    function setupProgram() {\n      var existingProgram = this.renderer.cache.getProgramFromShaders(this.vsCode, this.fsCode); // we found an existing program\n\n      if (existingProgram) {\n        // we need to create a new program but we don't have to re compile the shaders\n        this.vertexShader = existingProgram.vertexShader;\n        this.fragmentShader = existingProgram.fragmentShader; // copy active textures as well\n\n        this.activeUniforms = existingProgram.activeUniforms;\n        this.createProgram();\n      } else {\n        // compile the new shaders and create a new program\n        this.useNewShaders();\n\n        if (this.compiled) {\n          this.createProgram(); // add it to our program manager programs list\n\n          this.renderer.cache.addProgram(this);\n        }\n      }\n    }\n    /***\r\n     Used internally to set up program based on the created shaders and attach them to the program\r\n     Sets a list of active textures that are actually used by the shaders to avoid binding unused textures during draw calls\r\n     Add the program to the cache\r\n     ***/\n\n  }, {\n    key: \"createProgram\",\n    value: function createProgram() {\n      // set program id and type\n      id++;\n      this.id = id; // we need to create a new shader program\n\n      this.program = this.gl.createProgram(); // if shaders are valid, go on\n\n      this.gl.attachShader(this.program, this.vertexShader);\n      this.gl.attachShader(this.program, this.fragmentShader);\n      this.gl.linkProgram(this.program); // TODO getProgramParameter even in production to avoid errors?\n      // check the shader program creation status only when not in production mode\n\n      if (!this.renderer.production) {\n        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n          throwWarning(this.type + \": Unable to initialize the shader program: \" + this.gl.getProgramInfoLog(this.program)); // use default shaders, recompile and recreate program\n\n          throwWarning(this.type + \": Will use default vertex and fragment shaders\");\n          this.vertexShader = this.createShader(this.defaultVsCode, this.gl.VERTEX_SHADER);\n          this.fragmentShader = this.createShader(this.defaultFsCode, this.gl.FRAGMENT_SHADER);\n          this.createProgram();\n          return;\n        }\n      } // free the shaders handles\n\n\n      this.gl.deleteShader(this.vertexShader);\n      this.gl.deleteShader(this.fragmentShader); // store active textures (those that are used in the shaders) to avoid binding unused textures\n\n      if (!this.activeUniforms) {\n        this.activeUniforms = {\n          textures: [],\n          textureMatrices: []\n        }; // check for program active textures\n\n        var numUniforms = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);\n\n        for (var i = 0; i < numUniforms; i++) {\n          var activeUniform = this.gl.getActiveUniform(this.program, i);\n\n          if (activeUniform.type === this.gl.SAMPLER_2D) {\n            // if it's a texture add it to our activeUniforms textures array\n            this.activeUniforms.textures.push(activeUniform.name);\n          }\n\n          if (activeUniform.type === this.gl.FLOAT_MAT4 && activeUniform.name !== \"uMVMatrix\" && activeUniform.name !== \"uPMatrix\") {\n            // if it's a texture matrix add it to our activeUniforms textureMatrices array\n            this.activeUniforms.textureMatrices.push(activeUniform.name);\n          }\n        }\n      }\n    }\n    /*** UNIFORMS ***/\n\n    /***\r\n     Creates and attach the uniform handlers to our program\r\n       params:\r\n     @uniforms (object): an object describing our uniforms (see Uniforms class object)\r\n     ***/\n\n  }, {\n    key: \"createUniforms\",\n    value: function createUniforms(uniforms) {\n      this.uniformsManager = new Uniforms(this.renderer, this.program, uniforms); // set them right away\n\n      this.setUniforms();\n    }\n    /***\r\n     Sets our uniforms (used on init and on context restoration)\r\n     ***/\n\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      // use this program\n      this.renderer.useProgram(this);\n      this.uniformsManager.setUniforms();\n    }\n    /***\r\n     Updates our uniforms at each draw calls\r\n     ***/\n\n  }, {\n    key: \"updateUniforms\",\n    value: function updateUniforms() {\n      // use this program\n      this.renderer.useProgram(this);\n      this.uniformsManager.updateUniforms();\n    }\n  }]);\n\n  return Program;\n}();\n/***\r\n Geometry class handles attributes, VertexArrayObjects (if available) and vertices/UVs set up\r\n\r\n params:\r\n @renderer (Renderer class object): our renderer class object\r\n\r\n @program (object): our mesh's Program (see Program class object)\r\n @width (int): number of vertices along width\r\n @height (int): number of vertices along height\r\n @id (int): an integer based on geometry's width and height and used to avoid redundant buffer binding calls\r\n\r\n returns:\r\n @this: our newly created Geometry\r\n ***/\n\n\nvar Geometry = /*#__PURE__*/function () {\n  function Geometry(renderer) {\n    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref6$program = _ref6.program,\n        program = _ref6$program === void 0 ? null : _ref6$program,\n        _ref6$width = _ref6.width,\n        width = _ref6$width === void 0 ? 1 : _ref6$width,\n        _ref6$height = _ref6.height,\n        height = _ref6$height === void 0 ? 1 : _ref6$height;\n\n    _classCallCheck(this, Geometry);\n\n    this.type = \"Geometry\";\n\n    if (!renderer || renderer.type !== \"Renderer\") {\n      throwError(this.type + \": Renderer not passed as first argument\", renderer);\n    } else if (!renderer.gl) {\n      throwError(this.type + \": Renderer WebGL context is undefined\", renderer); // return if no gl context\n\n      return;\n    }\n\n    this.renderer = renderer;\n    this.gl = this.renderer.gl; // unique plane buffers id based on width and height\n    // used to get a geometry from cache\n\n    this.definition = {\n      id: width * height + width,\n      width: width,\n      height: height\n    };\n    this.setDefaultAttributes();\n    this.setVerticesUVs();\n  }\n  /*** CONTEXT RESTORATION ***/\n\n  /***\r\n   Used internally to handle context restoration after the program has been successfully compiled again\r\n   Reset the default attributes, the vertices and UVs and the program\r\n   ***/\n\n\n  _createClass(Geometry, [{\n    key: \"restoreContext\",\n    value: function restoreContext(program) {\n      this.program = null;\n      this.setDefaultAttributes();\n      this.setVerticesUVs();\n      this.setProgram(program);\n    }\n    /*** SET DEFAULT ATTRIBUTES ***/\n\n    /***\r\n     Our geometry default attributes that will handle the buffers\r\n     We're just using vertices positions and texture coordinates\r\n     ***/\n\n  }, {\n    key: \"setDefaultAttributes\",\n    value: function setDefaultAttributes() {\n      // our plane default attributes\n      // if we'd want to introduce custom attributes we'd merge them with those\n      this.attributes = {\n        vertexPosition: {\n          name: \"aVertexPosition\",\n          size: 3\n        },\n        textureCoord: {\n          name: \"aTextureCoord\",\n          size: 3\n        }\n      };\n    }\n    /***\r\n     Set our vertices and texture coordinates array\r\n     Get them from the cache if possible\r\n     ***/\n\n  }, {\n    key: \"setVerticesUVs\",\n    value: function setVerticesUVs() {\n      // we need to create our geometry and material objects\n      var cachedGeometry = this.renderer.cache.getGeometryFromID(this.definition.id);\n\n      if (cachedGeometry) {\n        this.attributes.vertexPosition.array = cachedGeometry.vertices;\n        this.attributes.textureCoord.array = cachedGeometry.uvs;\n      } else {\n        this.computeVerticesUVs(); // TODO better caching? We could pass all attributes to cache and handle arrays in there\n\n        this.renderer.cache.addGeometry(this.definition.id, this.attributes.vertexPosition.array, this.attributes.textureCoord.array);\n      }\n    }\n    /***\r\n     Called on init and on context restoration to set up the attribute buffers\r\n     Use VertexArrayObjects whenever possible\r\n     ***/\n\n  }, {\n    key: \"setProgram\",\n    value: function setProgram(program) {\n      this.program = program.program;\n      this.initAttributes(); // use vertex array objects if available\n\n      if (this.renderer._isWebGL2) {\n        this._vao = this.gl.createVertexArray();\n        this.gl.bindVertexArray(this._vao);\n      } else if (this.renderer.extensions['OES_vertex_array_object']) {\n        this._vao = this.renderer.extensions['OES_vertex_array_object'].createVertexArrayOES();\n        this.renderer.extensions['OES_vertex_array_object'].bindVertexArrayOES(this._vao);\n      }\n\n      this.initializeBuffers();\n    }\n    /***\r\n     This creates our mesh attributes and buffers by looping over it\r\n     ***/\n\n  }, {\n    key: \"initAttributes\",\n    value: function initAttributes() {\n      // loop through our attributes and create buffers and attributes locations\n      for (var key in this.attributes) {\n        this.attributes[key].location = this.gl.getAttribLocation(this.program, this.attributes[key].name);\n        this.attributes[key].buffer = this.gl.createBuffer();\n        this.attributes[key].numberOfItems = this.definition.width * this.definition.height * this.attributes[key].size * 2;\n      }\n    }\n    /***\r\n     This method is used internally to create our vertices coordinates and texture UVs\r\n     we first create our UVs on a grid from [0, 0, 0] to [1, 1, 0]\r\n     then we use the UVs to create our vertices coords\r\n     ***/\n\n  }, {\n    key: \"computeVerticesUVs\",\n    value: function computeVerticesUVs() {\n      // geometry vertices and UVs\n      this.attributes.vertexPosition.array = [];\n      this.attributes.textureCoord.array = [];\n      var vertices = this.attributes.vertexPosition.array;\n      var uvs = this.attributes.textureCoord.array;\n\n      for (var y = 0; y < this.definition.height; y++) {\n        var v = y / this.definition.height;\n\n        for (var x = 0; x < this.definition.width; x++) {\n          var u = x / this.definition.width; // uvs and vertices\n          // our uvs are ranging from 0 to 1, our vertices range from -1 to 1\n          // first triangle\n\n          uvs.push(u);\n          uvs.push(v);\n          uvs.push(0);\n          vertices.push((u - 0.5) * 2);\n          vertices.push((v - 0.5) * 2);\n          vertices.push(0);\n          uvs.push(u + 1 / this.definition.width);\n          uvs.push(v);\n          uvs.push(0);\n          vertices.push((u + 1 / this.definition.width - 0.5) * 2);\n          vertices.push((v - 0.5) * 2);\n          vertices.push(0);\n          uvs.push(u);\n          uvs.push(v + 1 / this.definition.height);\n          uvs.push(0);\n          vertices.push((u - 0.5) * 2);\n          vertices.push((v + 1 / this.definition.height - 0.5) * 2);\n          vertices.push(0); // second triangle\n\n          uvs.push(u);\n          uvs.push(v + 1 / this.definition.height);\n          uvs.push(0);\n          vertices.push((u - 0.5) * 2);\n          vertices.push((v + 1 / this.definition.height - 0.5) * 2);\n          vertices.push(0);\n          uvs.push(u + 1 / this.definition.width);\n          uvs.push(v);\n          uvs.push(0);\n          vertices.push((u + 1 / this.definition.width - 0.5) * 2);\n          vertices.push((v - 0.5) * 2);\n          vertices.push(0);\n          uvs.push(u + 1 / this.definition.width);\n          uvs.push(v + 1 / this.definition.height);\n          uvs.push(0);\n          vertices.push((u + 1 / this.definition.width - 0.5) * 2);\n          vertices.push((v + 1 / this.definition.height - 0.5) * 2);\n          vertices.push(0);\n        }\n      }\n    }\n    /***\r\n     This method enables and binds our attributes buffers\r\n     ***/\n\n  }, {\n    key: \"initializeBuffers\",\n    value: function initializeBuffers() {\n      if (!this.attributes) return; // loop through our attributes\n\n      for (var key in this.attributes) {\n        // bind attribute buffer\n        this.gl.enableVertexAttribArray(this.attributes[key].location);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.attributes[key].buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.attributes[key].array), this.gl.STATIC_DRAW); // set where the attribute gets its data\n\n        this.gl.vertexAttribPointer(this.attributes[key].location, this.attributes[key].size, this.gl.FLOAT, false, 0, 0);\n      } // update current buffers ID\n\n\n      this.renderer.state.currentGeometryID = this.definition.id;\n    }\n    /***\r\n     Used inside our draw call to set the correct plane buffers before drawing it\r\n     ***/\n\n  }, {\n    key: \"bindBuffers\",\n    value: function bindBuffers() {\n      if (this._vao) {\n        if (this.renderer._isWebGL2) {\n          this.gl.bindVertexArray(this._vao);\n        } else {\n          this.renderer.extensions['OES_vertex_array_object'].bindVertexArrayOES(this._vao);\n        }\n      } else {\n        // loop through our attributes to bind the buffers and set the attribute pointer\n        for (var key in this.attributes) {\n          this.gl.enableVertexAttribArray(this.attributes[key].location);\n          this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.attributes[key].buffer);\n          this.gl.vertexAttribPointer(this.attributes[key].location, this.attributes[key].size, this.gl.FLOAT, false, 0, 0);\n        }\n      } // update current buffers ID\n\n\n      this.renderer.state.currentGeometryID = this.definition.id;\n    }\n    /***\r\n     Draw a geometry\r\n     ***/\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this.gl.drawArrays(this.gl.TRIANGLES, 0, this.attributes.vertexPosition.numberOfItems);\n    }\n    /***\r\n     Dispose a geometry (ie delete its vertex array objects and buffers)\r\n     ***/\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      // delete buffers\n      // each time we check for existing properties to avoid errors\n      if (this._vao) {\n        if (this.renderer._isWebGL2) {\n          this.gl.deleteVertexArray(this._vao);\n        } else {\n          this.renderer.extensions['OES_vertex_array_object'].deleteVertexArrayOES(this._vao);\n        }\n      }\n\n      for (var key in this.attributes) {\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.attributes[key].buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, 1, this.gl.STATIC_DRAW);\n        this.gl.deleteBuffer(this.attributes[key].buffer);\n      }\n\n      this.attributes = null; // update current buffers ID\n\n      this.renderer.state.currentGeometryID = null;\n    }\n  }]);\n\n  return Geometry;\n}();\n/***\r\n Here we create a Mat4 class object\r\n This is a really basic Matrix4 class used for matrix calculations\r\n Highly based on https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js and http://glmatrix.net/docs/mat4.js.html\r\n\r\n params :\r\n @elements (Float32Array of length 16): our matrix array. Default to identity matrix.\r\n\r\n returns :\r\n @this: our Mat4 class object\r\n ***/\n// TODO lot of (unused at the time) methods are missing\n\n\nvar Mat4 = /*#__PURE__*/function () {\n  function Mat4() {\n    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n\n    _classCallCheck(this, Mat4);\n\n    this.type = \"Mat4\";\n    this.elements = elements;\n  }\n  /***\r\n   Sets the matrix values from an array\r\n     params:\r\n   @array (array): an array of at least 16 elements\r\n     returns:\r\n   @this (Mat4 class object): this matrix after being set\r\n   ***/\n\n\n  _createClass(Mat4, [{\n    key: \"setFromArray\",\n    value: function setFromArray(array) {\n      for (var i = 0; i < this.elements.length; i++) {\n        this.elements[i] = array[i];\n      }\n\n      return this;\n    }\n    /***\r\n     Copy another Mat4\r\n       params:\r\n     @matrix (Mat4 class object): matrix to copy\r\n       returns:\r\n     @this (Mat4 class object): this matrix after copy\r\n     ***/\n\n  }, {\n    key: \"copy\",\n    value: function copy(matrix) {\n      var array = matrix.elements;\n      this.elements[0] = array[0];\n      this.elements[1] = array[1];\n      this.elements[2] = array[2];\n      this.elements[3] = array[3];\n      this.elements[4] = array[4];\n      this.elements[5] = array[5];\n      this.elements[6] = array[6];\n      this.elements[7] = array[7];\n      this.elements[8] = array[8];\n      this.elements[9] = array[9];\n      this.elements[10] = array[10];\n      this.elements[11] = array[11];\n      this.elements[12] = array[12];\n      this.elements[13] = array[13];\n      this.elements[14] = array[14];\n      this.elements[15] = array[15];\n      return this;\n    }\n    /***\r\n     Clone a matrix\r\n       returns:\r\n     @clonedMatrix (Mat4 object): cloned matrix\r\n     ***/\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Mat4().copy(this);\n    }\n    /***\r\n     Simple matrix multiplication helper\r\n       params:\r\n     @matrix (Mat4 class object): Mat4 to multiply with\r\n       returns:\r\n     @result (Mat4 class object): Mat4 after multiplication\r\n     ***/\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(matrix) {\n      var a = this.elements;\n      var b = matrix.elements;\n      var result = new Mat4();\n      result.elements[0] = b[0] * a[0] + b[1] * a[4] + b[2] * a[8] + b[3] * a[12];\n      result.elements[1] = b[0] * a[1] + b[1] * a[5] + b[2] * a[9] + b[3] * a[13];\n      result.elements[2] = b[0] * a[2] + b[1] * a[6] + b[2] * a[10] + b[3] * a[14];\n      result.elements[3] = b[0] * a[3] + b[1] * a[7] + b[2] * a[11] + b[3] * a[15];\n      result.elements[4] = b[4] * a[0] + b[5] * a[4] + b[6] * a[8] + b[7] * a[12];\n      result.elements[5] = b[4] * a[1] + b[5] * a[5] + b[6] * a[9] + b[7] * a[13];\n      result.elements[6] = b[4] * a[2] + b[5] * a[6] + b[6] * a[10] + b[7] * a[14];\n      result.elements[7] = b[4] * a[3] + b[5] * a[7] + b[6] * a[11] + b[7] * a[15];\n      result.elements[8] = b[8] * a[0] + b[9] * a[4] + b[10] * a[8] + b[11] * a[12];\n      result.elements[9] = b[8] * a[1] + b[9] * a[5] + b[10] * a[9] + b[11] * a[13];\n      result.elements[10] = b[8] * a[2] + b[9] * a[6] + b[10] * a[10] + b[11] * a[14];\n      result.elements[11] = b[8] * a[3] + b[9] * a[7] + b[10] * a[11] + b[11] * a[15];\n      result.elements[12] = b[12] * a[0] + b[13] * a[4] + b[14] * a[8] + b[15] * a[12];\n      result.elements[13] = b[12] * a[1] + b[13] * a[5] + b[14] * a[9] + b[15] * a[13];\n      result.elements[14] = b[12] * a[2] + b[13] * a[6] + b[14] * a[10] + b[15] * a[14];\n      result.elements[15] = b[12] * a[3] + b[13] * a[7] + b[14] * a[11] + b[15] * a[15];\n      return result;\n    }\n    /***\r\n     Get matrix inverse\r\n       returns:\r\n     @result (Mat4 class object): inverted Mat4\r\n     ***/\n\n  }, {\n    key: \"getInverse\",\n    value: function getInverse() {\n      var te = this.elements;\n      var out = new Mat4();\n      var oe = out.elements;\n      var a00 = te[0],\n          a01 = te[1],\n          a02 = te[2],\n          a03 = te[3];\n      var a10 = te[4],\n          a11 = te[5],\n          a12 = te[6],\n          a13 = te[7];\n      var a20 = te[8],\n          a21 = te[9],\n          a22 = te[10],\n          a23 = te[11];\n      var a30 = te[12],\n          a31 = te[13],\n          a32 = te[14],\n          a33 = te[15];\n      var b00 = a00 * a11 - a01 * a10;\n      var b01 = a00 * a12 - a02 * a10;\n      var b02 = a00 * a13 - a03 * a10;\n      var b03 = a01 * a12 - a02 * a11;\n      var b04 = a01 * a13 - a03 * a11;\n      var b05 = a02 * a13 - a03 * a12;\n      var b06 = a20 * a31 - a21 * a30;\n      var b07 = a20 * a32 - a22 * a30;\n      var b08 = a20 * a33 - a23 * a30;\n      var b09 = a21 * a32 - a22 * a31;\n      var b10 = a21 * a33 - a23 * a31;\n      var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n      if (!det) {\n        return null;\n      }\n\n      det = 1 / det;\n      oe[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n      oe[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n      oe[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n      oe[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n      oe[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n      oe[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n      oe[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n      oe[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n      oe[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n      oe[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n      oe[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n      oe[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n      oe[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n      oe[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n      oe[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n      oe[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n      return out;\n    }\n    /***\r\n     Simple Mat4 scaling helper\r\n       params :\r\n     @vector (Vec3 class object): Vec3 representing scale along X, Y and Z axis\r\n       returns :\r\n     @result (Mat4 class object): Mat4 after scaling\r\n     ***/\n\n  }, {\n    key: \"scale\",\n    value: function scale(vector) {\n      var a = this.elements;\n      a[0] *= vector.x;\n      a[1] *= vector.x;\n      a[2] *= vector.x;\n      a[3] *= vector.x;\n      a[4] *= vector.y;\n      a[5] *= vector.y;\n      a[6] *= vector.y;\n      a[7] *= vector.y;\n      a[8] *= vector.z;\n      a[9] *= vector.z;\n      a[10] *= vector.z;\n      a[11] *= vector.z;\n      return this;\n    }\n    /***\r\n     Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n     Equivalent for applying translation, rotation and scale matrices but much faster\r\n     Source code from: http://glmatrix.net/docs/mat4.js.html\r\n       params :\r\n     @translation (Vec3 class object): translation vector\r\n     @quaternion (Quat class object): rotation quaternion\r\n     @scale (Vec3 class object): scale vector\r\n       returns :\r\n     @this (Mat4 class object): matrix after transformations\r\n     ***/\n\n  }, {\n    key: \"compose\",\n    value: function compose(translation, quaternion, scale) {\n      var matrix = this.elements; // Quaternion math\n\n      var x = quaternion.elements[0],\n          y = quaternion.elements[1],\n          z = quaternion.elements[2],\n          w = quaternion.elements[3];\n      var x2 = x + x;\n      var y2 = y + y;\n      var z2 = z + z;\n      var xx = x * x2;\n      var xy = x * y2;\n      var xz = x * z2;\n      var yy = y * y2;\n      var yz = y * z2;\n      var zz = z * z2;\n      var wx = w * x2;\n      var wy = w * y2;\n      var wz = w * z2;\n      var sx = scale.x;\n      var sy = scale.y;\n      var sz = scale.z;\n      matrix[0] = (1 - (yy + zz)) * sx;\n      matrix[1] = (xy + wz) * sx;\n      matrix[2] = (xz - wy) * sx;\n      matrix[3] = 0;\n      matrix[4] = (xy - wz) * sy;\n      matrix[5] = (1 - (xx + zz)) * sy;\n      matrix[6] = (yz + wx) * sy;\n      matrix[7] = 0;\n      matrix[8] = (xz + wy) * sz;\n      matrix[9] = (yz - wx) * sz;\n      matrix[10] = (1 - (xx + yy)) * sz;\n      matrix[11] = 0;\n      matrix[12] = translation.x;\n      matrix[13] = translation.y;\n      matrix[14] = translation.z;\n      matrix[15] = 1;\n      return this;\n    }\n    /***\r\n     Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n     Equivalent for applying translation, rotation and scale matrices but much faster\r\n     Source code from: http://glmatrix.net/docs/mat4.js.html\r\n       params :\r\n     @translation (Vec3 class object): translation vector\r\n     @quaternion (Quat class object): rotation quaternion\r\n     @scale (Vec3 class object): scale vector\r\n     @origin (Vec3 class object): origin vector around which to scale and rotate\r\n       returns :\r\n     @this (Mat4 class object): matrix after transformations\r\n     ***/\n\n  }, {\n    key: \"composeFromOrigin\",\n    value: function composeFromOrigin(translation, quaternion, scale, origin) {\n      var matrix = this.elements; // Quaternion math\n\n      var x = quaternion.elements[0],\n          y = quaternion.elements[1],\n          z = quaternion.elements[2],\n          w = quaternion.elements[3];\n      var x2 = x + x;\n      var y2 = y + y;\n      var z2 = z + z;\n      var xx = x * x2;\n      var xy = x * y2;\n      var xz = x * z2;\n      var yy = y * y2;\n      var yz = y * z2;\n      var zz = z * z2;\n      var wx = w * x2;\n      var wy = w * y2;\n      var wz = w * z2;\n      var sx = scale.x;\n      var sy = scale.y;\n      var sz = scale.z; // scale along Z is always equal to 1 anyway\n\n      var ox = origin.x;\n      var oy = origin.y;\n      var oz = origin.z;\n      var out0 = (1 - (yy + zz)) * sx;\n      var out1 = (xy + wz) * sx;\n      var out2 = (xz - wy) * sx;\n      var out4 = (xy - wz) * sy;\n      var out5 = (1 - (xx + zz)) * sy;\n      var out6 = (yz + wx) * sy;\n      var out8 = (xz + wy) * sz;\n      var out9 = (yz - wx) * sz;\n      var out10 = (1 - (xx + yy)) * sz;\n      matrix[0] = out0;\n      matrix[1] = out1;\n      matrix[2] = out2;\n      matrix[3] = 0;\n      matrix[4] = out4;\n      matrix[5] = out5;\n      matrix[6] = out6;\n      matrix[7] = 0;\n      matrix[8] = out8;\n      matrix[9] = out9;\n      matrix[10] = out10;\n      matrix[11] = 0;\n      matrix[12] = translation.x + ox - (out0 * ox + out4 * oy + out8 * oz);\n      matrix[13] = translation.y + oy - (out1 * ox + out5 * oy + out9 * oz);\n      matrix[14] = translation.z + oz - (out2 * ox + out6 * oy + out10 * oz);\n      matrix[15] = 1;\n      return this;\n    }\n  }]);\n\n  return Mat4;\n}();\n/***\r\n Here we create a Vec2 class object\r\n This is a really basic Vector2 class used for vector calculations\r\n Highly based on https://github.com/mrdoob/three.js/blob/dev/src/math/Vector2.js and http://glmatrix.net/docs/vec2.js.html\r\n\r\n params :\r\n @x (float): X component of our vector\r\n @y (float): Y component of our vector\r\n\r\n returns :\r\n @this: our Vec2 class object\r\n ***/\n// TODO lot of (unused at the time) methods are missing\n\n\nvar Vec2 = /*#__PURE__*/function () {\n  function Vec2() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n\n    _classCallCheck(this, Vec2);\n\n    this.type = \"Vec2\";\n    this._x = x;\n    this._y = y;\n  }\n  /***\r\n   Getters and setters (with onChange callback)\r\n   ***/\n\n\n  _createClass(Vec2, [{\n    key: \"x\",\n    get: function get() {\n      return this._x;\n    },\n    set: function set(value) {\n      var changed = value !== this._x;\n      this._x = value;\n      changed && this._onChangeCallback && this._onChangeCallback();\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this._y;\n    },\n    set: function set(value) {\n      var changed = value !== this._y;\n      this._y = value;\n      changed && this._onChangeCallback && this._onChangeCallback();\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(callback) {\n      if (callback) {\n        this._onChangeCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     Sets the vector from values\r\n       params:\r\n     @x (float): X component of our vector\r\n     @y (float): Y component of our vector\r\n       returns:\r\n     @this (Vec2): this vector after being set\r\n     ***/\n\n  }, {\n    key: \"set\",\n    value: function set(x, y) {\n      this._x = x;\n      this._y = y;\n      return this;\n    }\n    /***\r\n     Adds a vector to this vector\r\n       params:\r\n     @vector (Vec2): vector to add\r\n       returns:\r\n     @this (Vec2): this vector after addition\r\n     ***/\n\n  }, {\n    key: \"add\",\n    value: function add(vector) {\n      this._x += vector.x;\n      this._y += vector.y;\n      return this;\n    }\n    /***\r\n     Adds a scalar to this vector\r\n       params:\r\n     @value (float): number to add\r\n       returns:\r\n     @this (Vec2): this vector after addition\r\n     ***/\n\n  }, {\n    key: \"addScalar\",\n    value: function addScalar(value) {\n      this._x += value;\n      this._y += value;\n      return this;\n    }\n    /***\r\n     Subtracts a vector from this vector\r\n       params:\r\n     @vector (Vec2): vector to use for subtraction\r\n       returns:\r\n     @this (Vec2): this vector after subtraction\r\n     ***/\n\n  }, {\n    key: \"sub\",\n    value: function sub(vector) {\n      this._x -= vector.x;\n      this._y -= vector.y;\n      return this;\n    }\n    /***\r\n     Subtracts a scalar to this vector\r\n       params:\r\n     @value (float): number to use for subtraction\r\n       returns:\r\n     @this (Vec2): this vector after subtraction\r\n     ***/\n\n  }, {\n    key: \"subScalar\",\n    value: function subScalar(value) {\n      this._x -= value;\n      this._y -= value;\n      return this;\n    }\n    /***\r\n     Multiplies a vector with this vector\r\n       params:\r\n     @vector (Vec2): vector to use for multiplication\r\n       returns:\r\n     @this (Vec2): this vector after multiplication\r\n     ***/\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(vector) {\n      this._x *= vector.x;\n      this._y *= vector.y;\n      return this;\n    }\n    /***\r\n     Multiplies a scalar with this vector\r\n       params:\r\n     @value (float): number to use for multiplication\r\n       returns:\r\n     @this (Vec2): this vector after multiplication\r\n     ***/\n\n  }, {\n    key: \"multiplyScalar\",\n    value: function multiplyScalar(value) {\n      this._x *= value;\n      this._y *= value;\n      return this;\n    }\n    /***\r\n     Copy a vector into this vector\r\n       params:\r\n     @vector (Vec2): vector to copy\r\n       returns:\r\n     @this (Vec2): this vector after copy\r\n     ***/\n\n  }, {\n    key: \"copy\",\n    value: function copy(vector) {\n      this._x = vector.x;\n      this._y = vector.y;\n      return this;\n    }\n    /***\r\n     Clone this vector\r\n       returns:\r\n     @vector (Vec2): cloned vector\r\n     ***/\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Vec2(this._x, this._y);\n    }\n    /***\r\n     Merges this vector with a vector when values are NaN. Mostly used internally.\r\n       params:\r\n     @vector (Vec2): vector to use for sanitization\r\n       returns:\r\n     @vector (Vec2): sanitized vector\r\n     ***/\n\n  }, {\n    key: \"sanitizeNaNValuesWith\",\n    value: function sanitizeNaNValuesWith(vector) {\n      this._x = isNaN(this._x) ? vector.x : parseFloat(this._x);\n      this._y = isNaN(this._y) ? vector.y : parseFloat(this._y);\n      return this;\n    }\n    /***\r\n     Apply max values to this vector\r\n       params:\r\n     @vector (Vec2): vector representing max values\r\n       returns:\r\n     @vector (Vec2): vector with max values applied\r\n     ***/\n\n  }, {\n    key: \"max\",\n    value: function max(vector) {\n      this._x = Math.max(this._x, vector.x);\n      this._y = Math.max(this._y, vector.y);\n      return this;\n    }\n    /***\r\n     Apply min values to this vector\r\n       params:\r\n     @vector (Vec2): vector representing min values\r\n       returns:\r\n     @vector (Vec2): vector with min values applied\r\n     ***/\n\n  }, {\n    key: \"min\",\n    value: function min(vector) {\n      this._x = Math.min(this._x, vector.x);\n      this._y = Math.min(this._y, vector.y);\n      return this;\n    }\n    /***\r\n     Checks if 2 vectors are equal\r\n       params:\r\n     @vector (Vec2): vector to compare\r\n       returns:\r\n     @isEqual (bool): whether the vectors are equals or not\r\n     ***/\n\n  }, {\n    key: \"equals\",\n    value: function equals(vector) {\n      return this._x === vector.x && this._y === vector.y;\n    }\n    /***\r\n     Normalize this vector\r\n       returns:\r\n     @this (Vec2): normalized vector\r\n     ***/\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      // normalize\n      var len = this._x * this._x + this._y * this._y;\n\n      if (len > 0) {\n        len = 1 / Math.sqrt(len);\n      }\n\n      this._x *= len;\n      this._y *= len;\n      return this;\n    }\n    /***\r\n     Calculates the dot product of 2 vectors\r\n       params:\r\n     @vector (Vec2): vector to use for dot product\r\n       returns:\r\n     @dotProduct (float): dot product of the 2 vectors\r\n     ***/\n\n  }, {\n    key: \"dot\",\n    value: function dot(vector) {\n      return this._x * vector.x + this._y * vector.y;\n    }\n  }]);\n\n  return Vec2;\n}();\n/***\r\n Here we create a Vec3 class object\r\n This is a really basic Vector3 class used for vector calculations\r\n Highly based on https://github.com/mrdoob/three.js/blob/dev/src/math/Vector3.js and http://glmatrix.net/docs/vec3.js.html\r\n\r\n params :\r\n @x (float): X component of our vector\r\n @y (float): Y component of our vector\r\n @z (float): Z component of our vector\r\n\r\n returns :\r\n @this: our Vec3 class object\r\n ***/\n// TODO lot of (unused at the time) methods are missing\n\n\nvar Vec3 = /*#__PURE__*/function () {\n  function Vec3() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : x;\n\n    _classCallCheck(this, Vec3);\n\n    this.type = \"Vec3\";\n    this._x = x;\n    this._y = y;\n    this._z = z;\n  }\n  /***\r\n   Getters and setters (with onChange callback)\r\n   ***/\n\n\n  _createClass(Vec3, [{\n    key: \"x\",\n    get: function get() {\n      return this._x;\n    },\n    set: function set(value) {\n      var changed = value !== this._x;\n      this._x = value;\n      changed && this._onChangeCallback && this._onChangeCallback();\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this._y;\n    },\n    set: function set(value) {\n      var changed = value !== this._y;\n      this._y = value;\n      changed && this._onChangeCallback && this._onChangeCallback();\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return this._z;\n    },\n    set: function set(value) {\n      var changed = value !== this._z;\n      this._z = value;\n      changed && this._onChangeCallback && this._onChangeCallback();\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(callback) {\n      if (callback) {\n        this._onChangeCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     Sets the vector from values\r\n       params:\r\n     @x (float): X component of our vector\r\n     @y (float): Y component of our vector\r\n     @z (float): Z component of our vector\r\n       returns:\r\n     @this (Vec2): this vector after being set\r\n     ***/\n\n  }, {\n    key: \"set\",\n    value: function set(x, y, z) {\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      return this;\n    }\n    /***\r\n     Adds a vector to this vector\r\n       params:\r\n     @vector (Vec3): vector to add\r\n       returns:\r\n     @this (Vec3): this vector after addition\r\n     ***/\n\n  }, {\n    key: \"add\",\n    value: function add(vector) {\n      this._x += vector.x;\n      this._y += vector.y;\n      this._z += vector.z;\n      return this;\n    }\n    /***\r\n     Adds a scalar to this vector\r\n       params:\r\n     @value (float): number to add\r\n       returns:\r\n     @this (Vec3): this vector after addition\r\n     ***/\n\n  }, {\n    key: \"addScalar\",\n    value: function addScalar(value) {\n      this._x += value;\n      this._y += value;\n      this._z += value;\n      return this;\n    }\n    /***\r\n     Subtracts a vector from this vector\r\n       params:\r\n     @vector (Vec3): vector to use for subtraction\r\n       returns:\r\n     @this (Vec3): this vector after subtraction\r\n     ***/\n\n  }, {\n    key: \"sub\",\n    value: function sub(vector) {\n      this._x -= vector.x;\n      this._y -= vector.y;\n      this._z -= vector.z;\n      return this;\n    }\n    /***\r\n     Subtracts a scalar to this vector\r\n       params:\r\n     @value (float): number to use for subtraction\r\n       returns:\r\n     @this (Vec3): this vector after subtraction\r\n     ***/\n\n  }, {\n    key: \"subScalar\",\n    value: function subScalar(value) {\n      this._x -= value;\n      this._y -= value;\n      this._z -= value;\n      return this;\n    }\n    /***\r\n     Multiplies a vector with this vector\r\n       params:\r\n     @vector (Vec3): vector to use for multiplication\r\n       returns:\r\n     @this (Vec3): this vector after multiplication\r\n     ***/\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(vector) {\n      this._x *= vector.x;\n      this._y *= vector.y;\n      this._z *= vector.z;\n      return this;\n    }\n    /***\r\n     Multiplies a scalar with this vector\r\n       params:\r\n     @value (float): number to use for multiplication\r\n       returns:\r\n     @this (Vec3): this vector after multiplication\r\n     ***/\n\n  }, {\n    key: \"multiplyScalar\",\n    value: function multiplyScalar(value) {\n      this._x *= value;\n      this._y *= value;\n      this._z *= value;\n      return this;\n    }\n    /***\r\n     Copy a vector into this vector\r\n       params:\r\n     @vector (Vec3): vector to copy\r\n       returns:\r\n     @this (Vec3): this vector after copy\r\n     ***/\n\n  }, {\n    key: \"copy\",\n    value: function copy(vector) {\n      this._x = vector.x;\n      this._y = vector.y;\n      this._z = vector.z;\n      return this;\n    }\n    /***\r\n     Clone this vector\r\n       returns:\r\n     @vector (Vec3): cloned vector\r\n     ***/\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Vec3(this._x, this._y, this._z);\n    }\n    /***\r\n     Merges this vector with a vector when values are NaN. Mostly used internally.\r\n       params:\r\n     @vector (Vec3): vector to use for sanitization\r\n       returns:\r\n     @vector (Vec3): sanitized vector\r\n     ***/\n\n  }, {\n    key: \"sanitizeNaNValuesWith\",\n    value: function sanitizeNaNValuesWith(vector) {\n      this._x = isNaN(this._x) ? vector.x : parseFloat(this._x);\n      this._y = isNaN(this._y) ? vector.y : parseFloat(this._y);\n      this._z = isNaN(this._z) ? vector.z : parseFloat(this._z);\n      return this;\n    }\n    /***\r\n     Apply max values to this vector\r\n       params:\r\n     @vector (Vec3): vector representing max values\r\n       returns:\r\n     @vector (Vec3): vector with max values applied\r\n     ***/\n\n  }, {\n    key: \"max\",\n    value: function max(vector) {\n      this._x = Math.max(this._x, vector.x);\n      this._y = Math.max(this._y, vector.y);\n      this._z = Math.max(this._z, vector.z);\n      return this;\n    }\n    /***\r\n     Apply min values to this vector\r\n       params:\r\n     @vector (Vec3): vector representing min values\r\n       returns:\r\n     @vector (Vec3): vector with min values applied\r\n     ***/\n\n  }, {\n    key: \"min\",\n    value: function min(vector) {\n      this._x = Math.min(this._x, vector.x);\n      this._y = Math.min(this._y, vector.y);\n      this._z = Math.min(this._z, vector.z);\n      return this;\n    }\n    /***\r\n     Checks if 2 vectors are equal\r\n       returns:\r\n     @isEqual (bool): whether the vectors are equals or not\r\n     ***/\n\n  }, {\n    key: \"equals\",\n    value: function equals(vector) {\n      return this._x === vector.x && this._y === vector.y && this._z === vector.z;\n    }\n    /***\r\n     Normalize this vector\r\n       returns:\r\n     @this (Vec3): normalized vector\r\n     ***/\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      // normalize\n      var len = this._x * this._x + this._y * this._y + this._z * this._z;\n\n      if (len > 0) {\n        len = 1 / Math.sqrt(len);\n      }\n\n      this._x *= len;\n      this._y *= len;\n      this._z *= len;\n      return this;\n    }\n    /***\r\n     Calculates the dot product of 2 vectors\r\n       returns:\r\n     @dotProduct (float): dot product of the 2 vectors\r\n     ***/\n\n  }, {\n    key: \"dot\",\n    value: function dot(vector) {\n      return this._x * vector.x + this._y * vector.y + this._z * vector.z;\n    }\n    /***\r\n     Apply a matrix 4 to a point (vec3)\r\n     Useful to convert a point position from plane local world to webgl space using projection view matrix for example\r\n     Source code from: http://glmatrix.net/docs/vec3.js.html\r\n       params :\r\n     @matrix (array): 4x4 matrix used\r\n       returns :\r\n     @this (Vec3): this vector after matrix application\r\n     ***/\n\n  }, {\n    key: \"applyMat4\",\n    value: function applyMat4(matrix) {\n      var x = this._x,\n          y = this._y,\n          z = this._z;\n      var mArray = matrix.elements;\n      var w = mArray[3] * x + mArray[7] * y + mArray[11] * z + mArray[15];\n      w = w || 1;\n      this._x = (mArray[0] * x + mArray[4] * y + mArray[8] * z + mArray[12]) / w;\n      this._y = (mArray[1] * x + mArray[5] * y + mArray[9] * z + mArray[13]) / w;\n      this._z = (mArray[2] * x + mArray[6] * y + mArray[10] * z + mArray[14]) / w;\n      return this;\n    }\n    /***\r\n     Apply a quaternion (rotation in 3D space) to this vector\r\n       params :\r\n     @quaternion (Quat): quaternion to use\r\n       returns :\r\n     @this (Vec3): this vector after applying the transformation\r\n     ***/\n\n  }, {\n    key: \"applyQuat\",\n    value: function applyQuat(quaternion) {\n      var x = this._x,\n          y = this._y,\n          z = this._z;\n      var qx = quaternion.elements[0],\n          qy = quaternion.elements[1],\n          qz = quaternion.elements[2],\n          qw = quaternion.elements[3]; // calculate quat * vector\n\n      var ix = qw * x + qy * z - qz * y;\n      var iy = qw * y + qz * x - qx * z;\n      var iz = qw * z + qx * y - qy * x;\n      var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n      this._x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n      this._y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n      this._z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n      return this;\n    }\n    /***\r\n     Project 3D coordinate to 2D point\r\n       params:\r\n     @camera (Camera): camera to use for projection\r\n     ***/\n\n  }, {\n    key: \"project\",\n    value: function project(camera) {\n      this.applyMat4(camera.viewMatrix).applyMat4(camera.projectionMatrix);\n      return this;\n    }\n    /***\r\n     Unproject 2D point to 3D coordinate\r\n       params:\r\n     @camera (Camera): camera to use for projection\r\n     ***/\n\n  }, {\n    key: \"unproject\",\n    value: function unproject(camera) {\n      this.applyMat4(camera.projectionMatrix.getInverse()).applyMat4(camera.worldMatrix);\n      return this;\n    }\n  }]);\n\n  return Vec3;\n}();\n/***\r\n Texture class objects used by render targets, shader passes and planes.\r\n\r\n params:\r\n @renderer (Curtains renderer or Renderer class object): our curtains object OR our curtains renderer object\r\n\r\n @isFBOTexture (bool): Whether this texture is used by a render target/frame buffer object. Default to false\r\n @fromTexture (bool): Whether this texture should copy another texture right from init (and avoid creating a new webgl texture). Default to false\r\n @loader (TextureLoader class object): loader used to create that texture and load its source. Default to null\r\n\r\n @sampler (string): the texture sampler's name that will be used in the shaders\r\n\r\n @floatingPoint (string): texture floating point to apply. Could be \"float\", \"half-float\" or \"none\". Default to \"none\"\r\n\r\n @premultiplyAlpha (bool): Whether this texture should handle premultiplied alpha. Default to false\r\n @anisotropy (int): Texture anisotropy (see https://developer.mozilla.org/en-US/docs/Web/API/EXT_texture_filter_anisotropic). Default to 1\r\n @generateMipmap (bool): Whether to generate texture mipmaps (see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/generateMipmap). Default to true except for frame buffer objects textures.\r\n\r\n see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/samplerParameter\r\n @wrapS (GLenum): WebGL constant specifying the texture wrapping function for the texture coordinate S\r\n @wrapT (GLenum): WebGL constant specifying the texture wrapping function for the texture coordinate T\r\n @minFilter (GLenum): WebGL constant specifying the texture minification filter\r\n @magFilter (GLenum): WebGL constant specifying the texture magnification filter\r\n\r\n returns:\r\n @this: our newly created Texture class object\r\n ***/\n// avoid reinstancing those during runtime\n\n\nvar tempVec2 = new Vec2();\nvar tempVec3 = new Vec3();\nvar textureTranslation = new Mat4();\n\nvar Texture = /*#__PURE__*/function () {\n  function Texture(renderer) {\n    var _this12 = this;\n\n    var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref7$isFBOTexture = _ref7.isFBOTexture,\n        isFBOTexture = _ref7$isFBOTexture === void 0 ? false : _ref7$isFBOTexture,\n        _ref7$fromTexture = _ref7.fromTexture,\n        fromTexture = _ref7$fromTexture === void 0 ? false : _ref7$fromTexture,\n        loader = _ref7.loader,\n        sampler = _ref7.sampler,\n        _ref7$floatingPoint = _ref7.floatingPoint,\n        floatingPoint = _ref7$floatingPoint === void 0 ? \"none\" : _ref7$floatingPoint,\n        _ref7$premultiplyAlph = _ref7.premultiplyAlpha,\n        premultiplyAlpha = _ref7$premultiplyAlph === void 0 ? false : _ref7$premultiplyAlph,\n        _ref7$anisotropy = _ref7.anisotropy,\n        anisotropy = _ref7$anisotropy === void 0 ? 1 : _ref7$anisotropy,\n        _ref7$generateMipmap = _ref7.generateMipmap,\n        generateMipmap = _ref7$generateMipmap === void 0 ? null : _ref7$generateMipmap,\n        wrapS = _ref7.wrapS,\n        wrapT = _ref7.wrapT,\n        minFilter = _ref7.minFilter,\n        magFilter = _ref7.magFilter;\n\n    _classCallCheck(this, Texture);\n\n    this.type = \"Texture\"; // we could pass our curtains object OR our curtains renderer object\n\n    renderer = renderer && renderer.renderer || renderer;\n\n    if (!renderer || renderer.type !== \"Renderer\") {\n      throwError(this.type + \": Renderer not passed as first argument\", renderer);\n    } else if (!renderer.gl) {\n      if (!renderer.production) throwError(this.type + \": Unable to create a \" + this.type + \" because the Renderer WebGL context is not defined\"); // return if no gl context\n\n      return;\n    }\n\n    this.renderer = renderer;\n    this.gl = this.renderer.gl;\n    this.uuid = generateUUID(); // texture parameters\n\n    this._globalParameters = {\n      // global gl context parameters\n      unpackAlignment: 4,\n      flipY: !isFBOTexture,\n      premultiplyAlpha: false,\n      shouldPremultiplyAlpha: premultiplyAlpha,\n      // texImage2D properties\n      floatingPoint: floatingPoint,\n      type: this.gl.UNSIGNED_BYTE,\n      internalFormat: this.gl.RGBA,\n      format: this.gl.RGBA\n    };\n    this.parameters = {\n      // per texture parameters\n      anisotropy: anisotropy,\n      generateMipmap: generateMipmap,\n      wrapS: wrapS || this.gl.CLAMP_TO_EDGE,\n      wrapT: wrapT || this.gl.CLAMP_TO_EDGE,\n      minFilter: minFilter || this.gl.LINEAR,\n      magFilter: magFilter || this.gl.LINEAR,\n      _shouldUpdate: true\n    }; // per texture state\n\n    this._initState(); // is it a frame buffer object texture?\n    // if it's not, type will change when the source will be loaded\n\n\n    this.sourceType = isFBOTexture ? \"fbo\" : \"empty\"; // whether to use cache for image textures\n\n    this._useCache = true;\n    this._samplerName = sampler; // prepare texture sampler\n\n    this._sampler = {\n      isActive: false,\n      isTextureBound: false,\n      texture: this.gl.createTexture() // always create a gl texture\n\n    }; // we will always declare a texture matrix\n\n    this._textureMatrix = {\n      matrix: new Mat4(),\n      isActive: false\n    }; // actual size will be set later on\n\n    this._size = {\n      width: 1,\n      height: 1\n    };\n    this.scale = new Vec2(1);\n    this.scale.onChange(function () {\n      return _this12.resize();\n    });\n    this.offset = new Vec2();\n    this.offset.onChange(function () {\n      return _this12.resize();\n    }); // source loading and GPU uploading flags\n\n    this._loader = loader;\n    this._sourceLoaded = false;\n    this._uploaded = false; // _willUpdate and shouldUpdate property are set to false by default\n    // we will handle that in the setSource() method for videos and canvases\n\n    this._willUpdate = false;\n    this.shouldUpdate = false; // if we need to force a texture update\n\n    this._forceUpdate = false; // custom user properties\n\n    this.userData = {}; // useful flag to avoid binding texture that does not belong to current context\n\n    this._canDraw = false; // is it set from an existing texture?\n\n    if (fromTexture) {\n      this._copyOnInit = true;\n      this._copiedFrom = fromTexture; // everything else will be done when adding a parent to that texture\n\n      return;\n    }\n\n    this._copyOnInit = false; // init our texture\n\n    this._initTexture();\n  }\n  /***\r\n   Init per-texture parameters state\r\n   Called on init and on context restoration to force parameters settings\r\n   ***/\n\n\n  _createClass(Texture, [{\n    key: \"_initState\",\n    value: function _initState() {\n      this._state = {\n        anisotropy: 1,\n        generateMipmap: false,\n        wrapS: null,\n        wrapT: null,\n        minFilter: null,\n        magFilter: this.gl.LINEAR // default to gl.LINEAR\n\n      };\n    }\n    /***\r\n     Init our texture object\r\n     ***/\n\n  }, {\n    key: \"_initTexture\",\n    value: function _initTexture() {\n      // bind the texture the target (TEXTURE_2D) of the active texture unit.\n      this.gl.bindTexture(this.gl.TEXTURE_2D, this._sampler.texture);\n\n      if (this.sourceType === \"empty\") {\n        // avoid flipY on non DOM elements\n        this._globalParameters.flipY = false; // update global parameters before drawing an empty texture\n\n        this._updateGlobalTexParameters(); // draw a black plane before the real texture's content has been loaded\n\n\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));\n        this._canDraw = true;\n      }\n    }\n    /*** RESTORING CONTEXT ***/\n\n    /***\r\n     Restore a WebGL texture that is a copy\r\n     Depending on whether it's a copy from start or not, just reset its uniforms or run the full init\r\n     And finally copy our original texture back again\r\n     ***/\n\n  }, {\n    key: \"_restoreFromTexture\",\n    value: function _restoreFromTexture() {\n      // init again if needed\n      if (!this._copyOnInit) {\n        this._initTexture();\n      } // a texture shouldn't be restored if it does not have a parent\n      // since it's always the parent that calls the _restoreContext() method\n\n\n      if (this._parent) {\n        // set uniforms again\n        this._setTextureUniforms(); // update the texture matrix uniform as well\n\n\n        this._setSize();\n      } // copy our texture again\n\n\n      this.copy(this._copiedFrom);\n      this._canDraw = true;\n    }\n    /***\r\n     Restore our WebGL texture\r\n     If it is an original texture, just re run the init function and eventually reset its source\r\n     If it is a texture set from another texture, wait for the original texture to be ready first\r\n     ***/\n\n  }, {\n    key: \"_restoreContext\",\n    value: function _restoreContext() {\n      var _this13 = this;\n\n      // avoid binding that texture before reseting it\n      this._canDraw = false;\n      this._sampler.isActive = false;\n\n      this._initState(); // force mip map regeneration if needed\n\n\n      this._state.generateMipmap = false;\n      this.parameters._shouldUpdate = true; // this is an original texture, reset it right away\n\n      if (!this._copiedFrom) {\n        this._initTexture();\n\n        if (this._parent) {\n          this._setParent();\n        }\n\n        if (this.source) {\n          this.setSource(this.source); // cache again if it is an image\n          // also since it's an image it has been uploaded in setSource()\n\n          if (this.sourceType === \"image\") {\n            this.renderer.cache.addTexture(this);\n          } else {\n            // force update\n            this.needUpdate();\n          }\n        }\n\n        this._canDraw = true;\n      } else {\n        // wait for the original texure to be ready before attempting to restore the copy\n        var queue = this.renderer.nextRender.add(function () {\n          if (_this13._copiedFrom._canDraw) {\n            _this13._restoreFromTexture(); // remove from callback queue\n\n\n            queue.keep = false;\n          }\n        }, true);\n      }\n    }\n    /*** ADD PARENT ***/\n\n    /***\r\n     Adds a parent to a texture\r\n     Sets its index, its parent and add it to the parent textures array as well\r\n     Then runs _setParent() to set the size and uniforms if needed\r\n     ***/\n\n  }, {\n    key: \"addParent\",\n    value: function addParent(parent) {\n      if (!parent || parent.type !== \"Plane\" && parent.type !== \"PingPongPlane\" && parent.type !== \"ShaderPass\" && parent.type !== \"RenderTarget\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": cannot add texture as a child of \", parent, \" because it is not a valid parent\");\n        }\n\n        return;\n      } // add parent property\n\n\n      this._parent = parent; // update parent textures array\n\n      this.index = this._parent.textures.length;\n\n      this._parent.textures.push(this); // now set its parent for real\n\n\n      this._setParent();\n    }\n    /***\r\n     Sets the parent\r\n     Basically sets the uniforms names and locations and sizes\r\n     ***/\n\n  }, {\n    key: \"_setParent\",\n    value: function _setParent() {\n      var _this14 = this;\n\n      // prepare texture sampler\n      this._sampler.name = this._samplerName || \"uSampler\" + this.index; // we will always declare a texture matrix\n\n      this._textureMatrix.name = this._samplerName ? this._samplerName + \"Matrix\" : \"uTextureMatrix\" + this.index; // if the parent has a program it means its not a render target texture\n\n      if (this._parent._program) {\n        if (!this._parent._program.compiled) {\n          if (!this.renderer.production) {\n            throwWarning(this.type + \": Unable to create the texture because the program is not valid\");\n          }\n\n          return;\n        } // set uniform\n\n\n        this._setTextureUniforms();\n\n        if (this._copyOnInit) {\n          // wait for original texture to be ready before copying it\n          var waitForOriginalTexture = this.renderer.nextRender.add(function () {\n            if (_this14._copiedFrom._canDraw && _this14._copiedFrom._uploaded) {\n              _this14.copy(_this14._copiedFrom);\n\n              waitForOriginalTexture.keep = false;\n            }\n          }, true); // we're done!\n\n          return;\n        }\n\n        if (!this.source) {\n          // set its size based on parent element size for now\n          this._size = {\n            width: this._parent._boundingRect.document.width,\n            height: this._parent._boundingRect.document.height\n          };\n        } else if (this._parent.loader) {\n          // we're adding a parent to a texture that already has a source\n          // it means the source should have been loaded before the parent was set\n          // add it to the right asset array if needed\n          this._parent.loader._addSourceToParent(this.source, this.sourceType);\n        }\n\n        this._setSize();\n      } else if (this._parent.type === \"RenderTarget\") {\n        // its a render target texture, it has no uniform location and no texture matrix\n        this._size = {\n          width: this._parent._size && this._parent._size.width || this.renderer._boundingRect.width,\n          height: this._parent._size && this._parent._size.height || this.renderer._boundingRect.height\n        }; // updload to gpu\n\n        this._upload(); // update render texture parameters because it will never be drawn (hence not called)\n\n\n        this._updateTexParameters();\n\n        this._canDraw = true;\n      }\n    }\n    /***\r\n     Checks if this texture has a parent\r\n       return:\r\n     @hasParent (bool): whether this texture has a parent or not\r\n     ***/\n\n  }, {\n    key: \"hasParent\",\n    value: function hasParent() {\n      return !!this._parent;\n    }\n    /*** SEND DATA TO THE GPU ***/\n\n    /***\r\n     Check if our textures is effectively used in our shaders\r\n     If so, set it to active, get its uniform locations and bind it to our texture unit\r\n     ***/\n\n  }, {\n    key: \"_setTextureUniforms\",\n    value: function _setTextureUniforms() {\n      var _this15 = this;\n\n      // check if our texture is used in our program shaders\n      // if so, get its uniform locations and bind it to our program\n      var activeUniforms = this._parent._program.activeUniforms;\n\n      for (var i = 0; i < activeUniforms.textures.length; i++) {\n        if (activeUniforms.textures[i] === this._sampler.name) {\n          // this texture is active\n          this._sampler.isActive = true; // use the program and get our sampler and texture matrices uniforms\n\n          this.renderer.useProgram(this._parent._program); // set our texture sampler uniform\n\n          this._sampler.location = this.gl.getUniformLocation(this._parent._program.program, this._sampler.name); // set texture matrix uniform location only if active\n\n          var isTextureMatrixActive = activeUniforms.textureMatrices.find(function (textureMatrix) {\n            return textureMatrix === _this15._textureMatrix.name;\n          });\n\n          if (isTextureMatrixActive) {\n            this._textureMatrix.isActive = true;\n            this._textureMatrix.location = this.gl.getUniformLocation(this._parent._program.program, this._textureMatrix.name);\n          } // tell the shader we bound the texture to our indexed texture unit\n\n\n          this.gl.uniform1i(this._sampler.location, this.index);\n        }\n      }\n    }\n    /***\r\n     This copies an already existing Texture object to our texture\r\n       params:\r\n     @texture (Texture): texture to set from\r\n     ***/\n\n  }, {\n    key: \"copy\",\n    value: function copy(texture) {\n      if (!texture || texture.type !== \"Texture\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": Unable to set the texture from texture:\", texture);\n        }\n\n        return;\n      } // copy states\n\n\n      this._globalParameters = texture._globalParameters;\n      this._state = texture._state; // copy source\n\n      this._size = texture._size; // trigger loaded callback if needed\n\n      if (!this._sourceLoaded && texture._sourceLoaded) {\n        this._onSourceLoadedCallback && this._onSourceLoadedCallback();\n      }\n\n      this._sourceLoaded = texture._sourceLoaded; // trigger uploaded callback if needed\n\n      if (!this._uploaded && texture._uploaded) {\n        this._onSourceUploadedCallback && this._onSourceUploadedCallback();\n      }\n\n      this._uploaded = texture._uploaded;\n      this.sourceType = texture.sourceType;\n      this.source = texture.source;\n      this._videoFrameCallbackID = texture._videoFrameCallbackID; // copy texture\n\n      this._sampler.texture = texture._sampler.texture; // keep a track from the original one\n\n      this._copiedFrom = texture; // update its texture matrix if needed and we're good to go!\n\n      if (this._parent && this._parent._program && (!this._canDraw || !this._textureMatrix.matrix)) {\n        this._setSize();\n\n        this._canDraw = true;\n      } // force rendering\n\n\n      this.renderer.needRender();\n    }\n    /*** LOADING SOURCES ***/\n\n    /***\r\n     This uses our source as texture\r\n       params:\r\n     @source (images/video/canvas): either an image, a video or a canvas\r\n     ***/\n\n  }, {\n    key: \"setSource\",\n    value: function setSource(source) {\n      var _this16 = this;\n\n      // fire callback during load (useful for a loader)\n      if (!this._sourceLoaded) {\n        // texture source loaded callback\n        this.renderer.nextRender.add(function () {\n          return _this16._onSourceLoadedCallback && _this16._onSourceLoadedCallback();\n        });\n      } // get new source type based on source tag\n\n\n      var sourceType = source.tagName.toUpperCase() === \"IMG\" ? \"image\" : source.tagName.toLowerCase(); // somehow if the texture type changes from image to video or canvas, the cache won't work anymore\n\n      if (sourceType === \"video\" || sourceType === \"canvas\") {\n        this._useCache = false;\n      } // check for cache\n\n\n      if (this._useCache) {\n        var cachedTexture = this.renderer.cache.getTextureFromSource(source); // if we have a cached texture, just copy it\n\n        if (cachedTexture && cachedTexture.uuid !== this.uuid) {\n          // force texture uploaded callback\n          if (!this._uploaded) {\n            // GPU uploading callback\n            this.renderer.nextRender.add(function () {\n              return _this16._onSourceUploadedCallback && _this16._onSourceUploadedCallback();\n            });\n            this._uploaded = true;\n          }\n\n          this.copy(cachedTexture);\n          this.resize();\n          return;\n        }\n      }\n\n      if (this.sourceType === \"empty\" || this.sourceType !== sourceType) {\n        if (sourceType === \"video\") {\n          // a video should be updated by default\n          this._willUpdate = false;\n          this.shouldUpdate = true;\n        } else if (sourceType === \"canvas\") {\n          // a canvas could change each frame so we need to update it by default\n          this._willUpdate = true;\n          this.shouldUpdate = true;\n        } else if (sourceType === \"image\") {\n          this._willUpdate = false;\n          this.shouldUpdate = false;\n        } else {\n          if (!this.renderer.production) {\n            throwWarning(this.type + \": this HTML tag could not be converted into a texture:\", source.tagName);\n          }\n\n          return;\n        }\n      } // set new source\n\n\n      this.source = source;\n      this.sourceType = sourceType;\n      this._size = {\n        width: this.source.naturalWidth || this.source.width || this.source.videoWidth,\n        height: this.source.naturalHeight || this.source.height || this.source.videoHeight\n      }; // our source is loaded now\n\n      this._sourceLoaded = true; // no need to set WebGL active texture unit here, we'll do it at run time for each texture\n      // binding the texture is enough\n\n      this.gl.bindTexture(this.gl.TEXTURE_2D, this._sampler.texture);\n      this.resize();\n      this._globalParameters.flipY = true;\n      this._globalParameters.premultiplyAlpha = this._globalParameters.shouldPremultiplyAlpha; // upload our webgl texture only if it is an image\n      // canvas and video textures will be updated anyway in the rendering loop\n      // thanks to the shouldUpdate and _willUpdate flags\n\n      if (this.sourceType === \"image\") {\n        // generate mip maps if they have not been explicitly disabled\n        this.parameters.generateMipmap = this.parameters.generateMipmap || this.parameters.generateMipmap === null;\n        this.parameters._shouldUpdate = this.parameters.generateMipmap;\n        this._state.generateMipmap = false;\n\n        this._upload();\n      } // update scene\n\n\n      this.renderer.needRender();\n    }\n    /*** TEXTURE PARAMETERS ***/\n\n    /***\r\n     Updates textures parameters that depends on global WebGL context state\r\n     Typically unpacking, flipY and premultiplied alpha\r\n     Usually called before uploading a texture to the GPU\r\n     ***/\n\n  }, {\n    key: \"_updateGlobalTexParameters\",\n    value: function _updateGlobalTexParameters() {\n      // unpack alignment\n      if (this.renderer.state.unpackAlignment !== this._globalParameters.unpackAlignment) {\n        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this._globalParameters.unpackAlignment);\n        this.renderer.state.unpackAlignment = this._globalParameters.unpackAlignment;\n      } // flip Y only if source is not empty\n\n\n      if (this.renderer.state.flipY !== this._globalParameters.flipY) {\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this._globalParameters.flipY);\n        this.renderer.state.flipY = this._globalParameters.flipY;\n      } // premultiplied alpha only if source is not empty\n\n\n      if (this.renderer.state.premultiplyAlpha !== this._globalParameters.premultiplyAlpha) {\n        this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._globalParameters.premultiplyAlpha);\n        this.renderer.state.premultiplyAlpha = this._globalParameters.premultiplyAlpha;\n      } // floating point textures\n\n\n      if (this._globalParameters.floatingPoint === \"half-float\") {\n        if (this.renderer._isWebGL2 && this.renderer.extensions['EXT_color_buffer_float']) {\n          this._globalParameters.internalFormat = this.gl.RGBA16F;\n          this._globalParameters.type = this.gl.HALF_FLOAT;\n        } else if (this.renderer.extensions['OES_texture_half_float']) {\n          this._globalParameters.type = this.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES;\n        } else if (!this.renderer.production) {\n          throwWarning(this.type + \": could not use half-float textures because the extension is not available\");\n        }\n      } else if (this._globalParameters.floatingPoint === \"float\") {\n        if (this.renderer._isWebGL2 && this.renderer.extensions['EXT_color_buffer_float']) {\n          this._globalParameters.internalFormat = this.gl.RGBA16F;\n          this._globalParameters.type = this.gl.FLOAT;\n        } else if (this.renderer.extensions['OES_texture_float']) {\n          this._globalParameters.type = this.renderer.extensions['OES_texture_half_float'].FLOAT;\n        } else if (!this.renderer.production) {\n          throwWarning(this.type + \": could not use float textures because the extension is not available\");\n        }\n      }\n    }\n    /***\r\n     Updates per-textures parameters\r\n     Wrapping, filters, anisotropy and mipmaps generation\r\n     Usually called after uploading a texture to the GPU\r\n     ***/\n\n  }, {\n    key: \"_updateTexParameters\",\n    value: function _updateTexParameters() {\n      // be sure we're updating the right texture\n      if (this.index && this.renderer.state.activeTexture !== this.index) {\n        this._bindTexture();\n      } // wrapS\n\n\n      if (this.parameters.wrapS !== this._state.wrapS) {\n        if (!this.renderer._isWebGL2 && (!isPowerOf2(this._size.width) || !isPowerOf2(this._size.height))) {\n          this.parameters.wrapS = this.gl.CLAMP_TO_EDGE;\n        } // handle wrong wrapS values\n\n\n        if (this.parameters.wrapS !== this.gl.REPEAT && this.parameters.wrapS !== this.gl.CLAMP_TO_EDGE && this.parameters.wrapS !== this.gl.MIRRORED_REPEAT) {\n          if (!this.renderer.production) {\n            throwWarning(this.type + \": Wrong wrapS value\", this.parameters.wrapS, \"for this texture:\", this, \"\\ngl.CLAMP_TO_EDGE wrapping will be used instead\");\n          }\n\n          this.parameters.wrapS = this.gl.CLAMP_TO_EDGE;\n        }\n\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.parameters.wrapS);\n        this._state.wrapS = this.parameters.wrapS;\n      } // wrapT\n\n\n      if (this.parameters.wrapT !== this._state.wrapT) {\n        if (!this.renderer._isWebGL2 && (!isPowerOf2(this._size.width) || !isPowerOf2(this._size.height))) {\n          this.parameters.wrapT = this.gl.CLAMP_TO_EDGE;\n        } // handle wrong wrapT values\n\n\n        if (this.parameters.wrapT !== this.gl.REPEAT && this.parameters.wrapT !== this.gl.CLAMP_TO_EDGE && this.parameters.wrapT !== this.gl.MIRRORED_REPEAT) {\n          if (!this.renderer.production) {\n            throwWarning(this.type + \": Wrong wrapT value\", this.parameters.wrapT, \"for this texture:\", this, \"\\ngl.CLAMP_TO_EDGE wrapping will be used instead\");\n          }\n\n          this.parameters.wrapT = this.gl.CLAMP_TO_EDGE;\n        }\n\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.parameters.wrapT);\n        this._state.wrapT = this.parameters.wrapT;\n      } // generate mip map only if it has a source\n\n\n      if (this.parameters.generateMipmap && !this._state.generateMipmap && this.source) {\n        if (!this.renderer._isWebGL2 && (!isPowerOf2(this._size.width) || !isPowerOf2(this._size.height))) {\n          this.parameters.generateMipmap = false;\n        } else {\n          this.gl.generateMipmap(this.gl.TEXTURE_2D);\n        }\n\n        this._state.generateMipmap = this.parameters.generateMipmap;\n      } // min filter\n\n\n      if (this.parameters.minFilter !== this._state.minFilter) {\n        // WebGL1 and non PO2\n        if (!this.renderer._isWebGL2 && (!isPowerOf2(this._size.width) || !isPowerOf2(this._size.height))) {\n          this.parameters.minFilter = this.gl.LINEAR;\n        } // at this point if generateMipmap is null it means we will generate them later on\n\n\n        if (!this.parameters.generateMipmap && this.parameters.generateMipmap !== null) {\n          this.parameters.minFilter = this.gl.LINEAR;\n        } // handle wrong minFilter values\n\n\n        if (this.parameters.minFilter !== this.gl.LINEAR && this.parameters.minFilter !== this.gl.NEAREST && this.parameters.minFilter !== this.gl.NEAREST_MIPMAP_NEAREST && this.parameters.minFilter !== this.gl.LINEAR_MIPMAP_NEAREST && this.parameters.minFilter !== this.gl.NEAREST_MIPMAP_LINEAR && this.parameters.minFilter !== this.gl.LINEAR_MIPMAP_LINEAR) {\n          if (!this.renderer.production) {\n            throwWarning(this.type + \": Wrong minFilter value\", this.parameters.minFilter, \"for this texture:\", this, \"\\ngl.LINEAR filtering will be used instead\");\n          }\n\n          this.parameters.minFilter = this.gl.LINEAR;\n        }\n\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.parameters.minFilter);\n        this._state.minFilter = this.parameters.minFilter;\n      } // mag filter\n\n\n      if (this.parameters.magFilter !== this._state.magFilter) {\n        if (!this.renderer._isWebGL2 && (!isPowerOf2(this._size.width) || !isPowerOf2(this._size.height))) {\n          this.parameters.magFilter = this.gl.LINEAR;\n        } // handle wrong magFilter values\n\n\n        if (this.parameters.magFilter !== this.gl.LINEAR && this.parameters.magFilter !== this.gl.NEAREST) {\n          if (!this.renderer.production) {\n            throwWarning(this.type + \": Wrong magFilter value\", this.parameters.magFilter, \"for this texture:\", this, \"\\ngl.LINEAR filtering will be used instead\");\n          }\n\n          this.parameters.magFilter = this.gl.LINEAR;\n        }\n\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.parameters.magFilter);\n        this._state.magFilter = this.parameters.magFilter;\n      } // anisotropy\n\n\n      var anisotropyExt = this.renderer.extensions['EXT_texture_filter_anisotropic'];\n\n      if (anisotropyExt && this.parameters.anisotropy !== this._state.anisotropy) {\n        var max = this.gl.getParameter(anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n        this.parameters.anisotropy = Math.max(1, Math.min(this.parameters.anisotropy, max));\n        this.gl.texParameterf(this.gl.TEXTURE_2D, anisotropyExt.TEXTURE_MAX_ANISOTROPY_EXT, this.parameters.anisotropy);\n        this._state.anisotropy = this.parameters.anisotropy;\n      }\n    }\n    /***\r\n     Sets the texture wrapping for the texture coordinate S\r\n       params:\r\n     @wrapS (GLenum): WebGL constant specifying the texture wrapping function for the texture coordinate S\r\n     ***/\n\n  }, {\n    key: \"setWrapS\",\n    value: function setWrapS(wrapS) {\n      if (this.parameters.wrapS !== wrapS) {\n        this.parameters.wrapS = wrapS;\n        this.parameters._shouldUpdate = true;\n      }\n    }\n    /***\r\n     Sets the texture wrapping for the texture coordinate T\r\n       params:\r\n     @wrapT (GLenum): WebGL constant specifying the texture wrapping function for the texture coordinate T\r\n     ***/\n\n  }, {\n    key: \"setWrapT\",\n    value: function setWrapT(wrapT) {\n      if (this.parameters.wrapT !== wrapT) {\n        this.parameters.wrapT = wrapT;\n        this.parameters._shouldUpdate = true;\n      }\n    }\n    /***\r\n     Sets the texture minifaction filter value\r\n       params:\r\n     @minFilter (GLenum): WebGL constant specifying the texture minification filter\r\n     ***/\n\n  }, {\n    key: \"setMinFilter\",\n    value: function setMinFilter(minFilter) {\n      if (this.parameters.minFilter !== minFilter) {\n        this.parameters.minFilter = minFilter;\n        this.parameters._shouldUpdate = true;\n      }\n    }\n    /***\r\n     Sets the texture magnifaction filter value\r\n       params:\r\n     @magFilter (GLenum): WebGL constant specifying the texture magnifaction filter\r\n     ***/\n\n  }, {\n    key: \"setMagFilter\",\n    value: function setMagFilter(magFilter) {\n      if (this.parameters.magFilter !== magFilter) {\n        this.parameters.magFilter = magFilter;\n        this.parameters._shouldUpdate = true;\n      }\n    }\n    /***\r\n     Sets the texture anisotropy\r\n       params:\r\n     @anisotropy (int): Texture anisotropy value\r\n     ***/\n\n  }, {\n    key: \"setAnisotropy\",\n    value: function setAnisotropy(anisotropy) {\n      anisotropy = isNaN(anisotropy) ? this.parameters.anisotropy : anisotropy;\n\n      if (this.parameters.anisotropy !== anisotropy) {\n        this.parameters.anisotropy = anisotropy;\n        this.parameters._shouldUpdate = true;\n      }\n    }\n    /***\r\n     This forces a texture to be updated on the next draw call\r\n     ***/\n\n  }, {\n    key: \"needUpdate\",\n    value: function needUpdate() {\n      this._forceUpdate = true;\n    }\n    /***\r\n     This uses the requestVideoFrameCallback API to update the texture each time a new frame is displayed\r\n     ***/\n\n  }, {\n    key: \"_videoFrameCallback\",\n    value: function _videoFrameCallback() {\n      var _this17 = this;\n\n      this._willUpdate = true;\n      this.source.requestVideoFrameCallback(function () {\n        return _this17._videoFrameCallback();\n      });\n    }\n    /***\r\n     This updloads our texture to the GPU\r\n     Called on init or inside our drawing loop if shouldUpdate property is set to true\r\n     Typically used by videos or canvas\r\n     ***/\n\n  }, {\n    key: \"_upload\",\n    value: function _upload() {\n      var _this18 = this;\n\n      // set parameters that need to be set before texture uploading\n      this._updateGlobalTexParameters();\n\n      if (this.source) {\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this._globalParameters.internalFormat, this._globalParameters.format, this._globalParameters.type, this.source);\n      } else if (this.sourceType === \"fbo\") {\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this._globalParameters.internalFormat, this._size.width, this._size.height, 0, this._globalParameters.format, this._globalParameters.type, this.source || null);\n      } // texture has been uploaded\n\n\n      if (!this._uploaded) {\n        // GPU uploading callback\n        this.renderer.nextRender.add(function () {\n          return _this18._onSourceUploadedCallback && _this18._onSourceUploadedCallback();\n        });\n        this._uploaded = true;\n      }\n    }\n    /*** TEXTURE SIZINGS ***/\n\n    /***\r\n     This is used to calculate how to crop/center an texture\r\n       returns:\r\n     @sizes (obj): an object containing plane sizes, source sizes and x and y offset to center the source in the plane\r\n     ***/\n\n  }, {\n    key: \"_getSizes\",\n    value: function _getSizes() {\n      // if this is a fbo texture, its size is the same as its parent\n      if (this.sourceType === \"fbo\") {\n        return {\n          parentWidth: this._parent._boundingRect.document.width,\n          parentHeight: this._parent._boundingRect.document.height,\n          sourceWidth: this._parent._boundingRect.document.width,\n          sourceHeight: this._parent._boundingRect.document.height,\n          xOffset: 0,\n          yOffset: 0\n        };\n      } // remember our ShaderPass objects don't have a scale property\n\n\n      var scale = this._parent.scale ? tempVec2.set(this._parent.scale.x, this._parent.scale.y) : tempVec2.set(1, 1);\n      var parentWidth = this._parent._boundingRect.document.width * scale.x;\n      var parentHeight = this._parent._boundingRect.document.height * scale.y;\n      var sourceWidth = this._size.width;\n      var sourceHeight = this._size.height;\n      var sourceRatio = sourceWidth / sourceHeight;\n      var parentRatio = parentWidth / parentHeight; // center image in its container\n\n      var xOffset = 0;\n      var yOffset = 0;\n\n      if (parentRatio > sourceRatio) {\n        // means parent is larger\n        yOffset = Math.min(0, parentHeight - parentWidth * (1 / sourceRatio));\n      } else if (parentRatio < sourceRatio) {\n        // means parent is taller\n        xOffset = Math.min(0, parentWidth - parentHeight * sourceRatio);\n      }\n\n      return {\n        parentWidth: parentWidth,\n        parentHeight: parentHeight,\n        sourceWidth: sourceWidth,\n        sourceHeight: sourceHeight,\n        xOffset: xOffset,\n        yOffset: yOffset\n      };\n    }\n    /***\r\n     Set the texture scale and then update its matrix\r\n       params:\r\n     @scale (Vec2 object): scale to apply on X and Y axes\r\n     ***/\n\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      if (!scale.type || scale.type !== \"Vec2\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": Cannot set scale because the parameter passed is not of Vec2 type:\", scale);\n        }\n\n        return;\n      }\n\n      scale.sanitizeNaNValuesWith(this.scale).max(tempVec2.set(0.001, 0.001));\n\n      if (!scale.equals(this.scale)) {\n        this.scale.copy(scale);\n        this.resize();\n      }\n    }\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(offset) {\n      if (!offset.type || offset.type !== \"Vec2\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": Cannot set offset because the parameter passed is not of Vec2 type:\", scale);\n        }\n\n        return;\n      }\n\n      offset.sanitizeNaNValuesWith(this.offset);\n\n      if (!offset.equals(this.offset)) {\n        this.offset.copy(offset);\n        this.resize();\n      }\n    }\n    /***\r\n     Gets our texture and parent sizes and tells our texture matrix to update based on those values\r\n     ***/\n\n  }, {\n    key: \"_setSize\",\n    value: function _setSize() {\n      // if we need to update the texture matrix uniform\n      if (this._parent && this._parent._program) {\n        var sizes = this._getSizes(); // always update texture matrix anyway\n\n\n        this._updateTextureMatrix(sizes);\n      }\n    }\n    /***\r\n     This is used to crop/center a texture\r\n     If the texture is using texture matrix then we just have to update its matrix\r\n     If it is a render pass texture we also upload the texture with its new size on the GPU\r\n     ***/\n\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      if (this.sourceType === \"fbo\") {\n        // update size based on parent sizes (RenderTarget or ShaderPass)\n        this._size = {\n          width: this._parent._size && this._parent._size.width || this._parent._boundingRect.document.width,\n          height: this._parent._size && this._parent._size.height || this._parent._boundingRect.document.height\n        }; // reupload only if its not a texture set from another texture (means its a RenderTarget texture)\n\n        if (!this._copiedFrom) {\n          this.gl.bindTexture(this.gl.TEXTURE_2D, this._sampler.texture);\n          this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this._globalParameters.internalFormat, this._size.width, this._size.height, 0, this._globalParameters.format, this._globalParameters.type, null);\n        }\n      } else if (this.source) {\n        // reset texture sizes (useful for canvas because their dimensions might change on resize)\n        this._size = {\n          width: this.source.naturalWidth || this.source.width || this.source.videoWidth,\n          height: this.source.naturalHeight || this.source.height || this.source.videoHeight\n        };\n      }\n\n      this._setSize();\n    }\n    /***\r\n     This updates our textures matrix uniform based on plane and sources sizes\r\n       params:\r\n     @sizes (object): object containing plane sizes, source sizes and x and y offset to center the source in the plane\r\n     ***/\n\n  }, {\n    key: \"_updateTextureMatrix\",\n    value: function _updateTextureMatrix(sizes) {\n      // calculate scale to apply to the matrix\n      var textureScale = tempVec3.set(sizes.parentWidth / (sizes.parentWidth - sizes.xOffset), sizes.parentHeight / (sizes.parentHeight - sizes.yOffset), 1); // apply texture scale\n\n      textureScale.x /= this.scale.x;\n      textureScale.y /= this.scale.y; // translate and scale texture to center it\n      // equivalent (but faster) than applying those steps to an identity matrix:\n      // translate from [(1 - textureScale.x) / 2 + this.offset.x, (1 - textureScale.y) / 2 + this.offset.y, 0]\n      // then apply a scale of [textureScale.x, textureScale.y, 1]\n\n      this._textureMatrix.matrix = textureTranslation.setFromArray([textureScale.x, 0, 0, 0, 0, textureScale.y, 0, 0, 0, 0, 1, 0, (1 - textureScale.x) / 2 + this.offset.x, (1 - textureScale.y) / 2 + this.offset.y, 0, 1]); // update the texture matrix uniform\n\n      this._updateMatrixUniform();\n    }\n    /***\r\n     This updates our textures matrix GL uniform\r\n     ***/\n\n  }, {\n    key: \"_updateMatrixUniform\",\n    value: function _updateMatrixUniform() {\n      if (this._textureMatrix.isActive) {\n        this.renderer.useProgram(this._parent._program);\n        this.gl.uniformMatrix4fv(this._textureMatrix.location, false, this._textureMatrix.matrix.elements);\n      }\n    }\n    /***\r\n     This calls our loading callback and set our media as texture source\r\n     ***/\n\n  }, {\n    key: \"_onSourceLoaded\",\n    value: function _onSourceLoaded(source) {\n      // set the media as our texture source\n      this.setSource(source); // add to the cache if needed\n\n      if (this.sourceType === \"image\") {\n        this.renderer.cache.addTexture(this);\n      }\n    }\n    /*** DRAWING ***/\n\n    /***\r\n     This is used to set the WebGL context active texture and bind it\r\n       params:\r\n     @texture (texture object): Our texture object containing our WebGL texture and its index\r\n     ***/\n\n  }, {\n    key: \"_bindTexture\",\n    value: function _bindTexture() {\n      if (this._canDraw) {\n        if (this.renderer.state.activeTexture !== this.index) {\n          // tell WebGL we want to affect the texture at the plane's index unit\n          this.gl.activeTexture(this.gl.TEXTURE0 + this.index);\n          this.renderer.state.activeTexture = this.index;\n        } // bind the texture to the plane's index unit\n\n\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this._sampler.texture); // check for texture binding until we got one\n\n        if (!this._sampler.isTextureBound) {\n          this._sampler.isTextureBound = !!this.gl.getParameter(this.gl.TEXTURE_BINDING_2D); // force render\n\n          this._sampler.isTextureBound && this.renderer.needRender();\n        }\n      }\n    }\n    /***\r\n     This is called to draw the texture\r\n     ***/\n\n  }, {\n    key: \"_draw\",\n    value: function _draw() {\n      // only draw if the texture is active (used in the shader)\n      if (this._sampler.isActive) {\n        // bind the texture\n        this._bindTexture(); // if no videoFrameCallback check if the video is actually really playing\n\n\n        if (this.sourceType === \"video\" && this.source && !this._videoFrameCallbackID && this.source.readyState >= this.source.HAVE_CURRENT_DATA && !this.source.paused) {\n          this._willUpdate = true;\n        }\n\n        if (this._forceUpdate || this._willUpdate && this.shouldUpdate) {\n          // force mipmaps regeneration if needed\n          this._state.generateMipmap = false;\n\n          this._upload();\n        } // reset the video willUpdate flag\n\n\n        if (this.sourceType === \"video\") {\n          this._willUpdate = false;\n        }\n\n        this._forceUpdate = false;\n      } // set parameters that need to be set after texture uploading\n\n\n      if (this.parameters._shouldUpdate) {\n        this._updateTexParameters();\n\n        this.parameters._shouldUpdate = false;\n      }\n    }\n    /*** EVENTS ***/\n\n    /***\r\n     This is called each time a source has been loaded for the first time\r\n     TODO useless?\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our texture to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onSourceLoaded\",\n    value: function onSourceLoaded(callback) {\n      if (callback) {\n        this._onSourceLoadedCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called each time a texture has been uploaded to the GPU for the first time\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our texture to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onSourceUploaded\",\n    value: function onSourceUploaded(callback) {\n      if (callback) {\n        this._onSourceUploadedCallback = callback;\n      }\n\n      return this;\n    }\n    /*** DESTROYING ***/\n\n    /***\r\n     This is used to destroy a texture and free the memory space\r\n     Usually used on a plane/shader pass/render target removal\r\n       params:\r\n     @force (bool, optional): force the texture to be deleted even if cached\r\n     ***/\n\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.sourceType === \"video\" || this.sourceType === \"image\" && !this.renderer.state.isActive) {\n        // remove event listeners\n        if (this._loader) {\n          this._loader._removeSource(this);\n        } // clear source\n\n\n        this.source = null;\n      } else if (this.sourceType === \"canvas\") {\n        // clear all canvas states\n        this.source.width = this.source.width; // clear source\n\n        this.source = null;\n      } // remove its parent\n\n\n      this._parent = null; // do not delete original texture if this texture is a copy, or image texture if we're not destroying the context\n\n      var shouldDelete = this.gl && !this._copiedFrom && (force || this.sourceType !== \"image\" || !this.renderer.state.isActive);\n\n      if (shouldDelete) {\n        this._canDraw = false; // if the texture is in our textures cache array, remove it\n\n        this.renderer.cache.removeTexture(this);\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.index);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n        this.gl.deleteTexture(this._sampler.texture);\n      }\n    }\n  }]);\n\n  return Texture;\n}();\n/*** TEXTURE LOADER CLASS ***/\n\n/***\r\n An asset loader that handles images, videos and canvas loading\r\n Load the assets and create a Texture class object that will use those assets as sources\r\n\r\n params:\r\n @renderer (Curtains or Renderer class object): our curtains object OR our curtains renderer object\r\n @crossOrigin (string, optional): crossorigin policy to use\r\n\r\n returns :\r\n @this: our TextureLoader element\r\n ***/\n// TODO load assets with a web worker?\n\n\nvar TextureLoader = /*#__PURE__*/function () {\n  function TextureLoader(renderer) {\n    var crossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"anonymous\";\n\n    _classCallCheck(this, TextureLoader);\n\n    this.type = \"TextureLoader\"; // we could pass our curtains object OR our curtains renderer object\n\n    renderer = renderer && renderer.renderer || renderer; // throw warning if no renderer or webgl context\n\n    if (!renderer || renderer.type !== \"Renderer\") {\n      throwError(this.type + \": Renderer not passed as first argument\", renderer);\n    } else if (!renderer.gl) {\n      throwError(this.type + \": Renderer WebGL context is undefined\", renderer); // return if no gl context\n\n      return;\n    } // renderer and webgl context\n\n\n    this.renderer = renderer;\n    this.gl = this.renderer.gl; // crossorigin policy to apply\n\n    this.crossOrigin = crossOrigin; // keep a track of all sources loaded via this loader\n\n    this.elements = [];\n  }\n  /***\r\n   Keep a track of all sources loaded via this loader with an els array\r\n   This allows to get clean refs to the event listeners to be able to remove them later\r\n     params:\r\n   @source (html element): html image, video or canvas element that has been loaded\r\n   @texture (Texture class object): our newly created texture that will use that source\r\n   @successCallback (function): reference to our success callback\r\n   @errorCallback (function): reference to our error callback\r\n   ***/\n\n\n  _createClass(TextureLoader, [{\n    key: \"_addElement\",\n    value: function _addElement(source, texture, successCallback, errorCallback) {\n      var el = {\n        source: source,\n        texture: texture,\n        load: this._sourceLoaded.bind(this, source, texture, successCallback),\n        error: this._sourceLoadError.bind(this, source, errorCallback)\n      };\n      this.elements.push(el);\n      return el;\n    }\n    /***\r\n     Handles media loading errors\r\n       params:\r\n     @source (html element): html image or video element that has failed to load\r\n     @callback (function): function to execute\r\n     @error (object): loading error\r\n     ***/\n\n  }, {\n    key: \"_sourceLoadError\",\n    value: function _sourceLoadError(source, callback, error) {\n      // execute callback\n      if (callback) {\n        callback(source, error);\n      }\n    }\n    /***\r\n     Handles media loading success\r\n       params:\r\n     @source (html element): html image, video or canvas element that has been loaded\r\n     @texture (Texture class object): our newly created texture that will use that source\r\n     @callback (function): function to execute\r\n     ***/\n\n  }, {\n    key: \"_sourceLoaded\",\n    value: function _sourceLoaded(source, texture, callback) {\n      var _this19 = this;\n\n      // execute only once\n      if (!texture._sourceLoaded) {\n        texture._onSourceLoaded(source); // if this loader has a parent (means its a PlaneTextureLoader)\n\n\n        if (this._parent) {\n          // increment plane texture loader\n          this._increment && this._increment();\n          this.renderer.nextRender.add(function () {\n            return _this19._parent._onLoadingCallback && _this19._parent._onLoadingCallback(texture);\n          });\n        } // execute callback\n\n\n        if (callback) {\n          callback(texture);\n        }\n      }\n    }\n    /***\r\n     Get the source type based on its file extension if it's a string or it's tag name if its a HTML element\r\n       params:\r\n     @source (html element or string): html image, video, canvas element or source url\r\n       returns :\r\n     @sourceType (string): either \"image\", \"video\", \"canvas\" or null if source type cannot be determined\r\n     ***/\n\n  }, {\n    key: \"_getSourceType\",\n    value: function _getSourceType(source) {\n      var sourceType;\n\n      if (typeof source === \"string\") {\n        // from https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Supported_image_formats\n        if (source.match(/\\.(jpeg|jpg|jfif|pjpeg|pjp|gif|bmp|png|webp|svg|avif|apng)$/) !== null) {\n          sourceType = \"image\";\n        } else if (source.match(/\\.(webm|mp4|mpg|mpeg|avi|ogg|ogm|ogv|mov|av1)$/) !== null) {\n          sourceType = \"video\";\n        }\n      } else {\n        if (source.tagName.toUpperCase() === \"IMG\") {\n          sourceType = \"image\";\n        } else if (source.tagName.toUpperCase() === \"VIDEO\") {\n          sourceType = \"video\";\n        } else if (source.tagName.toUpperCase() === \"CANVAS\") {\n          sourceType = \"canvas\";\n        }\n      }\n\n      return sourceType;\n    }\n    /***\r\n     Create an image HTML element based on an image source url\r\n       params:\r\n     @source (string): source url\r\n       returns :\r\n     @image (HTML image element): an HTML image element\r\n     ***/\n\n  }, {\n    key: \"_createImage\",\n    value: function _createImage(source) {\n      // create a new image element if the source specified is a string\n      // or if the crossorigin attribute is not specified (avoid potential CORS errors)\n      if (typeof source === \"string\" || !source.hasAttribute(\"crossOrigin\")) {\n        var image = new Image();\n        image.crossOrigin = this.crossOrigin;\n\n        if (typeof source === \"string\") {\n          image.src = source;\n        } else {\n          image.src = source.src;\n          source.hasAttribute(\"data-sampler\") && image.setAttribute(\"data-sampler\", source.getAttribute(\"data-sampler\"));\n        }\n\n        return image;\n      } else {\n        // else return source directly to avoid reloading the image\n        return source;\n      }\n    }\n    /***\r\n     Create a video HTML element based on a video source url\r\n       params:\r\n     @source (string): source url\r\n       returns :\r\n     @video (HTML video element): an HTML video element\r\n     ***/\n\n  }, {\n    key: \"_createVideo\",\n    value: function _createVideo(source) {\n      // create a new video element if the source specified is a string\n      // or if the crossorigin attribute is not specified (avoid potential CORS errors)\n      if (typeof source === \"string\" || source.getAttribute(\"crossOrigin\") === null) {\n        var video = document.createElement(\"video\");\n        video.crossOrigin = this.crossOrigin;\n\n        if (typeof source === \"string\") {\n          video.src = source;\n        } else {\n          video.src = source.src;\n          source.hasAttribute(\"data-sampler\") && video.setAttribute(\"data-sampler\", source.getAttribute(\"data-sampler\"));\n        }\n\n        return video;\n      } else {\n        // else return source directly to avoid reloading the video\n        return source;\n      }\n    }\n    /***\r\n     This method loads one source\r\n     It checks what type of source it is then use the right loader\r\n       params:\r\n     @source (html element): html image, video or canvas element\r\n     @textureOptions (object): parameters to apply to the textures, such as sampler name, repeat wrapping, filters, anisotropy...\r\n     @successCallback (function): function to execute when the source has been loaded\r\n     @errorCallback (function): function to execute if the source fails to load\r\n     ***/\n\n  }, {\n    key: \"loadSource\",\n    value: function loadSource(source, textureOptions, successCallback, errorCallback) {\n      // get source type to use the right loader\n      var sourceType = this._getSourceType(source);\n\n      switch (sourceType) {\n        case \"image\":\n          this.loadImage(source, textureOptions, successCallback, errorCallback);\n          break;\n\n        case \"video\":\n          this.loadVideo(source, textureOptions, successCallback, errorCallback);\n          break;\n\n        case \"canvas\":\n          this.loadCanvas(source, textureOptions, successCallback);\n          break;\n\n        default:\n          this._sourceLoadError(source, errorCallback, \"this source could not be converted into a texture: \" + source);\n\n          break;\n      }\n    }\n    /***\r\n     This method loads an array of sources by calling loadSource() for each one of them\r\n       params:\r\n     @sources (array of html elements / sources url): array of html images, videos, canvases element or sources url\r\n     @texturesOptions (object): parameters to apply to the textures, such as sampler name, repeat wrapping, filters, anisotropy...\r\n     @successCallback (function): function to execute when each source has been loaded\r\n     @errorCallback (function): function to execute if a source fails to load\r\n     ***/\n\n  }, {\n    key: \"loadSources\",\n    value: function loadSources(sources, texturesOptions, successCallback, errorCallback) {\n      for (var i = 0; i < sources.length; i++) {\n        this.loadSource(sources[i], texturesOptions, successCallback, errorCallback);\n      }\n    }\n    /***\r\n     This method loads an image\r\n     Creates a new texture object right away and once the image is loaded it uses it as our WebGL texture\r\n       params:\r\n     @source (image): html image element\r\n     @textureOptions (object): parameters to apply to the textures, such as sampler name, repeat wrapping, filters, anisotropy...\r\n     @successCallback (function): function to execute when the source has been loaded\r\n     @errorCallback (function): function to execute if the source fails to load\r\n     ***/\n\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(source) {\n      var textureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var errorCallback = arguments.length > 3 ? arguments[3] : undefined;\n      // check for cache\n      var cachedTexture = this.renderer.cache.getTextureFromSource(source);\n      var options = Object.assign({}, textureOptions); // merge texture options with its parent textures options if needed\n\n      if (this._parent) {\n        options = Object.assign(options, this._parent._texturesOptions);\n      }\n\n      options.loader = this;\n\n      if (cachedTexture) {\n        options.sampler = typeof source !== \"string\" && source.hasAttribute(\"data-sampler\") ? source.getAttribute(\"data-sampler\") : options.sampler;\n        options.fromTexture = cachedTexture;\n\n        var _texture = new Texture(this.renderer, options); // execute source loaded callback directly\n\n\n        this._sourceLoaded(cachedTexture.source, _texture, successCallback); // if there's a parent (PlaneTextureLoader) add texture and source to it\n\n\n        this._parent && this._addToParent(_texture, cachedTexture.source, \"image\"); // that's all!\n\n        return;\n      }\n\n      var image = this._createImage(source);\n\n      options.sampler = image.hasAttribute(\"data-sampler\") ? image.getAttribute(\"data-sampler\") : options.sampler; // create a new texture that will use our image later\n\n      var texture = new Texture(this.renderer, options); // add a new entry in our elements array\n\n      var el = this._addElement(image, texture, successCallback, errorCallback); // If the image is in the cache of the browser,\n      // the 'load' event might have been triggered\n      // before we registered the event handler.\n\n\n      if (image.complete) {\n        this._sourceLoaded(image, texture, successCallback);\n      } else if (image.decode) {\n        image.decode().then(this._sourceLoaded.bind(this, image, texture, successCallback)).catch(function () {\n          // fallback to classic load & error events\n          image.addEventListener('load', el.load, false);\n          image.addEventListener('error', el.error, false);\n        });\n      } else {\n        image.addEventListener('load', el.load, false);\n        image.addEventListener('error', el.error, false);\n      } // if there's a parent (PlaneTextureLoader) add texture and source to it\n\n\n      this._parent && this._addToParent(texture, image, \"image\");\n    }\n    /***\r\n     This method loads an array of images by calling loadImage() for each one of them\r\n       params:\r\n     @sources (array of images / images url): array of html images elements or images url\r\n     @texturesOptions (object): parameters to apply to the textures, such as sampler name, repeat wrapping, filters, anisotropy...\r\n     @successCallback (function): function to execute when each source has been loaded\r\n     @errorCallback (function): function to execute if a source fails to load\r\n     ***/\n\n  }, {\n    key: \"loadImages\",\n    value: function loadImages(sources, texturesOptions, successCallback, errorCallback) {\n      for (var i = 0; i < sources.length; i++) {\n        this.loadImage(sources[i], texturesOptions, successCallback, errorCallback);\n      }\n    }\n    /***\r\n     This method loads a video\r\n     Creates a new texture object right away and once the video has enough data it uses it as our WebGL texture\r\n       params:\r\n     @source (video): html video element\r\n     @textureOptions (object): parameters to apply to the textures, such as sampler name, repeat wrapping, filters, anisotropy...\r\n     @successCallback (function): function to execute when the source has been loaded\r\n     @errorCallback (function): function to execute if the source fails to load\r\n     ***/\n\n  }, {\n    key: \"loadVideo\",\n    value: function loadVideo(source) {\n      var textureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var errorCallback = arguments.length > 3 ? arguments[3] : undefined;\n\n      var video = this._createVideo(source);\n\n      video.preload = true;\n      video.muted = true;\n      video.loop = true;\n      video.setAttribute(\"playsinline\", \"\");\n      video.crossOrigin = this.crossOrigin;\n      var options = Object.assign({}, textureOptions); // merge texture options with its parent textures options if needed\n\n      if (this._parent) {\n        options = Object.assign(textureOptions, this._parent._texturesOptions);\n      }\n\n      options.loader = this;\n      options.sampler = video.hasAttribute(\"data-sampler\") ? video.getAttribute(\"data-sampler\") : options.sampler; // create a new texture that will use our video later\n\n      var texture = new Texture(this.renderer, options); // add a new entry in our elements array\n\n      var el = this._addElement(video, texture, successCallback, errorCallback); // handle our loaded data event inside the texture and tell our plane when the video is ready to play\n\n\n      video.addEventListener('canplaythrough', el.load, false);\n      video.addEventListener('error', el.error, false); // If the video is in the cache of the browser,\n      // the 'canplaythrough' event might have been triggered\n      // before we registered the event handler.\n\n      if (video.readyState >= video.HAVE_FUTURE_DATA && successCallback) {\n        this._sourceLoaded(video, texture, successCallback);\n      } // start loading our video\n\n\n      video.load(); // if there's a parent (PlaneTextureLoader) add texture and source to it\n\n      this._addToParent && this._addToParent(texture, video, \"video\"); // if requestVideoFrameCallback exist, use it to update our video texture\n\n      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\n        el.videoFrameCallback = texture._videoFrameCallback.bind(texture);\n        texture._videoFrameCallbackID = video.requestVideoFrameCallback(el.videoFrameCallback);\n      }\n    }\n    /***\r\n     This method loads an array of images by calling loadVideo() for each one of them\r\n       params:\r\n     @sources (array of videos / videos url): array of html videos elements or videos url\r\n     @texturesOptions (object): parameters to apply to the textures, such as sampler name, repeat wrapping, filters, anisotropy...\r\n     @successCallback (function): function to execute when each source has been loaded\r\n     @errorCallback (function): function to execute if a source fails to load\r\n     ***/\n\n  }, {\n    key: \"loadVideos\",\n    value: function loadVideos(sources, texturesOptions, successCallback, errorCallback) {\n      for (var i = 0; i < sources.length; i++) {\n        this.loadVideo(sources[i], texturesOptions, successCallback, errorCallback);\n      }\n    }\n    /***\r\n     This method loads a canvas\r\n     Creates a new texture object right away and uses the canvas as our WebGL texture\r\n       params:\r\n     @source (canvas): html canvas element\r\n     @textureOptions (object): parameters to apply to the textures, such as sampler name, repeat wrapping, filters, anisotropy...\r\n     @successCallback (function): function to execute when the source has been loaded\r\n     ***/\n\n  }, {\n    key: \"loadCanvas\",\n    value: function loadCanvas(source) {\n      var textureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var options = Object.assign({}, textureOptions); // merge texture options with its parent textures options if needed\n\n      if (this._parent) {\n        options = Object.assign(textureOptions, this._parent._texturesOptions);\n      }\n\n      options.loader = this;\n      options.sampler = source.hasAttribute(\"data-sampler\") ? source.getAttribute(\"data-sampler\") : options.sampler; // create a new texture that will use our source later\n\n      var texture = new Texture(this.renderer, options); // add a new entry in our elements array\n\n      this._addElement(source, texture, successCallback, null); // canvas are directly loaded\n\n\n      this._sourceLoaded(source, texture, successCallback); // if there's a parent (PlaneTextureLoader) add texture and source to it\n\n\n      this._parent && this._addToParent(texture, source, \"canvas\");\n    }\n    /***\r\n     This method loads an array of images by calling loadCanvas() for each one of them\r\n       params:\r\n     @sources (array of canvas): array of html canvases elements\r\n     @texturesOptions (object): parameters to apply to the textures, such as sampler name, repeat wrapping, filters, anisotropy...\r\n     @successCallback (function): function to execute when each source has been loaded\r\n     ***/\n\n  }, {\n    key: \"loadCanvases\",\n    value: function loadCanvases(sources, texturesOptions, successCallback) {\n      for (var i = 0; i < sources.length; i++) {\n        this.loadCanvas(sources[i], texturesOptions, successCallback);\n      }\n    }\n    /*** REMOVING EVENT LISTENERS ***/\n\n    /***\r\n     Cleanly removes a texture source by removing its associated event listeners\r\n       params:\r\n     @texture (Texture class object): The texture that contains our source\r\n     ***/\n\n  }, {\n    key: \"_removeSource\",\n    value: function _removeSource(texture) {\n      // find our reference el in our els array\n      var el = this.elements.find(function (element) {\n        return element.texture.uuid === texture.uuid;\n      }); // if we have an element, remove its associated event listeners\n\n      if (el) {\n        if (texture.sourceType === \"image\") {\n          el.source.removeEventListener(\"load\", el.load, false);\n        } else if (texture.sourceType === \"video\") {\n          // cancel video frame callback\n          if (el.videoFrameCallback && texture._videoFrameCallbackID) {\n            el.source.cancelVideoFrameCallback(texture._videoFrameCallbackID);\n          }\n\n          el.source.removeEventListener(\"canplaythrough\", el.load, false); // empty source to properly delete video element and free the memory\n\n          el.source.pause();\n          el.source.removeAttribute(\"src\");\n          el.source.load();\n        }\n\n        el.source.removeEventListener(\"error\", el.error, false);\n      }\n    }\n  }]);\n\n  return TextureLoader;\n}();\n/*** PLANE TEXTURE LOADER CLASS ***/\n\n/***\r\n Extends our TextureLoader class to add sources loaded count, handle onComplete event\r\n Also adds the sources and textures to its defined parent\r\n\r\n params:\r\n @renderer (Curtains renderer or Renderer class object): our curtains object OR our curtains renderer object\r\n @parent (Plane or ShaderPass class object): The plane or shader pass that will use this loader\r\n\r\n @sourcesLoaded (int): Number of sources loaded\r\n @sourcesToLoad (int): Number of initial sources to load\r\n @complete (bool): Whether the loader has loaded all the initial sources\r\n @onComplete (function): Callback to execute when all the initial sources have been loaded\r\n\r\n returns :\r\n @this: our PlaneTextureLoader element\r\n ***/\n\n\nvar PlaneTextureLoader = /*#__PURE__*/function (_TextureLoader) {\n  _inherits(PlaneTextureLoader, _TextureLoader);\n\n  var _super = _createSuper(PlaneTextureLoader);\n\n  function PlaneTextureLoader(renderer, parent) {\n    var _this20;\n\n    var _ref8 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref8$sourcesLoaded = _ref8.sourcesLoaded,\n        sourcesLoaded = _ref8$sourcesLoaded === void 0 ? 0 : _ref8$sourcesLoaded,\n        _ref8$sourcesToLoad = _ref8.sourcesToLoad,\n        sourcesToLoad = _ref8$sourcesToLoad === void 0 ? 0 : _ref8$sourcesToLoad,\n        _ref8$complete = _ref8.complete,\n        complete = _ref8$complete === void 0 ? false : _ref8$complete,\n        _ref8$onComplete = _ref8.onComplete,\n        onComplete = _ref8$onComplete === void 0 ? function () {} : _ref8$onComplete;\n\n    _classCallCheck(this, PlaneTextureLoader);\n\n    _this20 = _super.call(this, renderer, parent.crossOrigin);\n    _this20.type = \"PlaneTextureLoader\";\n    _this20._parent = parent;\n\n    if (_this20._parent.type !== \"Plane\" && _this20._parent.type !== \"PingPongPlane\" && _this20._parent.type !== \"ShaderPass\") {\n      throwWarning(_this20.type + \": Wrong parent type assigned to this loader\");\n      _this20._parent = null;\n    }\n\n    _this20.sourcesLoaded = sourcesLoaded;\n    _this20.sourcesToLoad = sourcesToLoad;\n    _this20.complete = complete;\n    _this20.onComplete = onComplete;\n    return _this20;\n  }\n  /*** TRACK LOADING ***/\n\n  /***\r\n   Sets the total number of assets to load before firing the onComplete event\r\n     params:\r\n   @size (int): our curtains object OR our curtains renderer object\r\n   ***/\n\n\n  _createClass(PlaneTextureLoader, [{\n    key: \"_setLoaderSize\",\n    value: function _setLoaderSize(size) {\n      var _this21 = this;\n\n      this.sourcesToLoad = size;\n\n      if (this.sourcesToLoad === 0) {\n        this.complete = true;\n        this.renderer.nextRender.add(function () {\n          return _this21.onComplete && _this21.onComplete();\n        });\n      }\n    }\n    /***\r\n     Increment the number of sources loaded\r\n     ***/\n\n  }, {\n    key: \"_increment\",\n    value: function _increment() {\n      var _this22 = this;\n\n      this.sourcesLoaded++;\n\n      if (this.sourcesLoaded >= this.sourcesToLoad && !this.complete) {\n        this.complete = true;\n        this.renderer.nextRender.add(function () {\n          return _this22.onComplete && _this22.onComplete();\n        });\n      }\n    }\n    /*** UPDATE PARENT SOURCES AND TEXTURES ARAYS ***/\n\n    /***\r\n     Adds the source to the correct parent assets array\r\n       params:\r\n     @source (html element): html image, video or canvas element that has been loaded\r\n     @sourceType (string): either \"image\", \"video\" or \"canvas\"\r\n     ***/\n\n  }, {\n    key: \"_addSourceToParent\",\n    value: function _addSourceToParent(source, sourceType) {\n      // add the source if it is not already in the correct parent assets array\n      if (sourceType === \"image\") {\n        var parentAssetArray = this._parent[\"images\"];\n        var isInParent = parentAssetArray.find(function (element) {\n          return element.src === source.src;\n        });\n        !isInParent && parentAssetArray.push(source);\n      } else if (sourceType === \"video\") {\n        var _parentAssetArray = this._parent[\"videos\"];\n\n        var _isInParent = _parentAssetArray.find(function (element) {\n          return element.src === source.src;\n        });\n\n        !_isInParent && _parentAssetArray.push(source);\n      } else if (sourceType === \"canvas\") {\n        var _parentAssetArray2 = this._parent[\"canvases\"];\n\n        var _isInParent2 = _parentAssetArray2.find(function (element) {\n          return element.isSameNode(source);\n        });\n\n        !_isInParent2 && _parentAssetArray2.push(source);\n      }\n    }\n    /***\r\n     Adds the loader parent to the newly created texture\r\n     Also adds the source to the correct parent assets array\r\n       params:\r\n     @texture (Texture class object): our newly created texture\r\n     @source (html element): html image, video or canvas element that has been loaded\r\n     @sourceType (string): either \"image\", \"video\" or \"canvas\"\r\n     ***/\n\n  }, {\n    key: \"_addToParent\",\n    value: function _addToParent(texture, source, sourceType) {\n      this._addSourceToParent(source, sourceType); // add the texture to the parent\n\n\n      this._parent && texture.addParent(this._parent);\n    }\n  }]);\n\n  return PlaneTextureLoader;\n}(TextureLoader);\n/***\r\n Here we create our Mesh object\r\n We will create an object containing the program that handles shaders and uniforms, a geometry that handles attributes\r\n Also handles anything that relates to textures creation and basic drawing operations\r\n\r\n params:\r\n @renderer (Curtains renderer or Renderer class object): our curtains object OR our curtains renderer object\r\n @type (string): Object type (should be either \"Plane\" or \"ShaderPass\")\r\n\r\n @vertexShaderID (string, optional): the vertex shader script ID. If not specified, will look for a data attribute data-vs-id on the plane HTML element.\r\n @fragmentShaderID (string, optional): the fragment shader script ID. If not specified, will look for a data attribute data-fs-id on the plane HTML element.\r\n @vertexShader (string, optional): the vertex shader as a string. Will look for a vertexShaderID if not specified.\r\n @fragmentShader (string, optional): the fragment shader as a string. Will look for a fragmentShaderID if not specified.\r\n @uniforms (object, optional): the uniforms that will be passed to the shaders.\r\n @widthSegments (int, optional): mesh definition along the X axis (1 by default)\r\n @heightSegments (int, optional): mesh definition along the Y axis (1 by default)\r\n @renderOrder (int, optional): mesh render order in the scene draw stacks (0 by default)\r\n @depthTest (bool, optional): if the mesh should enable or disable the depth test. Default to true.\r\n @cullFace (string, optional): which face of the mesh should be culled. Could either be \"back\", \"front\" or \"none\". Default to \"back\".\r\n @texturesOptions (object, optional): options and parameters to apply to the textures loaded by the mesh's loader. See the Texture class object.\r\n @crossorigin (string, optional): defines the crossOrigin process to load images if any (default to \"anonymous\").\r\n\r\n returns:\r\n @this: our Mesh element\r\n ***/\n\n\nvar Mesh = /*#__PURE__*/function () {\n  function Mesh(renderer) {\n    var _this23 = this;\n\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Mesh\";\n\n    var _ref9 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        vertexShaderID = _ref9.vertexShaderID,\n        fragmentShaderID = _ref9.fragmentShaderID,\n        vertexShader = _ref9.vertexShader,\n        fragmentShader = _ref9.fragmentShader,\n        _ref9$uniforms = _ref9.uniforms,\n        uniforms = _ref9$uniforms === void 0 ? {} : _ref9$uniforms,\n        _ref9$widthSegments = _ref9.widthSegments,\n        widthSegments = _ref9$widthSegments === void 0 ? 1 : _ref9$widthSegments,\n        _ref9$heightSegments = _ref9.heightSegments,\n        heightSegments = _ref9$heightSegments === void 0 ? 1 : _ref9$heightSegments,\n        _ref9$renderOrder = _ref9.renderOrder,\n        renderOrder = _ref9$renderOrder === void 0 ? 0 : _ref9$renderOrder,\n        _ref9$depthTest = _ref9.depthTest,\n        depthTest = _ref9$depthTest === void 0 ? true : _ref9$depthTest,\n        _ref9$cullFace = _ref9.cullFace,\n        cullFace = _ref9$cullFace === void 0 ? \"back\" : _ref9$cullFace,\n        _ref9$texturesOptions = _ref9.texturesOptions,\n        texturesOptions = _ref9$texturesOptions === void 0 ? {} : _ref9$texturesOptions,\n        _ref9$crossOrigin = _ref9.crossOrigin,\n        crossOrigin = _ref9$crossOrigin === void 0 ? \"anonymous\" : _ref9$crossOrigin;\n\n    _classCallCheck(this, Mesh);\n\n    this.type = type; // we could pass our curtains object OR our curtains renderer object\n\n    renderer = renderer && renderer.renderer || renderer;\n\n    if (!renderer || renderer.type !== \"Renderer\") {\n      throwError(this.type + \": Curtains not passed as first argument or Curtains Renderer is missing\", renderer); // no renderer, we can't use the renderer nextRender method\n\n      setTimeout(function () {\n        if (_this23._onErrorCallback) {\n          _this23._onErrorCallback();\n        }\n      }, 0);\n    }\n\n    this.renderer = renderer;\n    this.gl = this.renderer.gl;\n\n    if (!this.gl) {\n      if (!this.renderer.production) throwError(this.type + \": Unable to create a \" + this.type + \" because the Renderer WebGL context is not defined\"); // we should assume there's still no renderer here, so no nextRender method\n\n      setTimeout(function () {\n        if (_this23._onErrorCallback) {\n          _this23._onErrorCallback();\n        }\n      }, 0); // return if no gl context\n\n      return;\n    }\n\n    this._canDraw = false;\n    this.renderOrder = renderOrder; // depth test\n\n    this._depthTest = depthTest; // face culling\n\n    this.cullFace = cullFace;\n\n    if (this.cullFace !== \"back\" && this.cullFace !== \"front\" && this.cullFace !== \"none\") {\n      this.cullFace = \"back\";\n    } // textures\n\n\n    this.textures = []; // default textures options depends on the type of Mesh and WebGL context\n\n    this._texturesOptions = Object.assign({\n      premultiplyAlpha: false,\n      anisotropy: 1,\n      floatingPoint: \"none\",\n      // accepts \"none\", \"half-float\" or \"float\"\n      wrapS: this.gl.CLAMP_TO_EDGE,\n      wrapT: this.gl.CLAMP_TO_EDGE,\n      minFilter: this.gl.LINEAR,\n      magFilter: this.gl.LINEAR\n    }, texturesOptions);\n    this.crossOrigin = crossOrigin; // handling shaders\n\n    if (!vertexShader && vertexShaderID && document.getElementById(vertexShaderID)) {\n      vertexShader = document.getElementById(vertexShaderID).innerHTML;\n    }\n\n    if (!fragmentShader && fragmentShaderID && document.getElementById(fragmentShaderID)) {\n      fragmentShader = document.getElementById(fragmentShaderID).innerHTML;\n    } // init sizes and loader\n\n\n    this._initMesh(); // geometry\n    // set plane attributes\n\n\n    widthSegments = parseInt(widthSegments);\n    heightSegments = parseInt(heightSegments);\n    this._geometry = new Geometry(this.renderer, {\n      width: widthSegments,\n      height: heightSegments // using a special ID for shader passes to avoid weird buffer binding bugs on mac devices\n      //id: this.type === \"ShaderPass\" ? 1 : widthSegments * heightSegments + widthSegments\n\n    });\n    this._program = new Program(this.renderer, {\n      parent: this,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    });\n\n    if (this._program.compiled) {\n      // create and set program uniforms\n      this._program.createUniforms(uniforms); // make uniforms accessible directly\n\n\n      this.uniforms = this._program.uniformsManager.uniforms; // geometry\n      // set plane attributes\n\n      this._geometry.setProgram(this._program); // we've added a new object, keep Curtains class in sync with our renderer\n\n\n      this.renderer.onSceneChange();\n    } else {\n      this.renderer.nextRender.add(function () {\n        return _this23._onErrorCallback && _this23._onErrorCallback();\n      });\n    }\n  }\n\n  _createClass(Mesh, [{\n    key: \"_initMesh\",\n    value: function _initMesh() {\n      var _this24 = this;\n\n      this.uuid = generateUUID(); // our Loader Class that will handle all medias loading process\n\n      this.loader = new PlaneTextureLoader(this.renderer, this, {\n        sourcesLoaded: 0,\n        initSourcesToLoad: 0,\n        // will change if there's any texture to load on init\n        complete: false,\n        onComplete: function onComplete() {\n          _this24._onReadyCallback && _this24._onReadyCallback();\n\n          _this24.renderer.needRender();\n        }\n      });\n      this.images = [];\n      this.videos = [];\n      this.canvases = []; // allow the user to add custom data to the plane\n\n      this.userData = {};\n      this._canDraw = true;\n    }\n    /*** RESTORING CONTEXT ***/\n\n    /***\r\n     Used internally to handle context restoration\r\n     ***/\n\n  }, {\n    key: \"_restoreContext\",\n    value: function _restoreContext() {\n      this._canDraw = false;\n\n      if (this._matrices) {\n        this._matrices = null;\n      } // reset the used program based on our previous shaders code strings\n\n\n      this._program = new Program(this.renderer, {\n        parent: this,\n        vertexShader: this._program.vsCode,\n        fragmentShader: this._program.fsCode\n      });\n\n      if (this._program.compiled) {\n        // reset geometry\n        this._geometry.restoreContext(this._program); // create and set program uniforms\n\n\n        this._program.createUniforms(this.uniforms); // make uniforms accessible directly\n\n\n        this.uniforms = this._program.uniformsManager.uniforms; // program restored callback of Planes and ShaderPasses\n\n        this._programRestored();\n      }\n    }\n    /***\r\n     This function adds a render target to a mesh\r\n       params :\r\n     @renderTarger (RenderTarget): the render target to add to that mesh\r\n     ***/\n\n  }, {\n    key: \"setRenderTarget\",\n    value: function setRenderTarget(renderTarget) {\n      if (!renderTarget || renderTarget.type !== \"RenderTarget\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": Could not set the render target because the argument passed is not a RenderTarget class object\", renderTarget);\n        }\n\n        return;\n      }\n\n      if (this.type === \"Plane\") {\n        // remove from scene stacks\n        this.renderer.scene.removePlane(this);\n      }\n\n      this.target = renderTarget;\n\n      if (this.type === \"Plane\") {\n        // add to scene stacks again\n        this.renderer.scene.addPlane(this);\n      }\n    }\n    /***\r\n     Set the mesh render order to draw it above or behind other meshes\r\n       params :\r\n     @renderOrder (int): new render order to apply: higher number means a mesh is drawn on top of others\r\n     ***/\n\n  }, {\n    key: \"setRenderOrder\",\n    value: function setRenderOrder() {\n      var renderOrder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      renderOrder = isNaN(renderOrder) ? this.renderOrder : parseInt(renderOrder);\n\n      if (renderOrder !== this.renderOrder) {\n        this.renderOrder = renderOrder;\n        this.renderer.scene.setPlaneRenderOrder(this);\n      }\n    }\n    /*** IMAGES, VIDEOS AND CANVASES LOADING ***/\n\n    /***\r\n     This method creates a new Texture and adds it to the mesh\r\n       params :\r\n     @textureOptions (object, optional) : Parameters to apply to that texture (see Texture class). Will be merged with the mesh default textures options\r\n       returns :\r\n     @texture: our newly created texture\r\n     ***/\n\n  }, {\n    key: \"createTexture\",\n    value: function createTexture() {\n      var textureOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // create a new texture with the specified options\n      var texture = new Texture(this.renderer, Object.assign(this._texturesOptions, textureOptions)); // add the texture to the mesh\n\n      texture.addParent(this);\n      return texture;\n    }\n    /***\r\n     Shortcut for addParent() Texture class method\r\n     ***/\n\n  }, {\n    key: \"addTexture\",\n    value: function addTexture(texture) {\n      if (!texture || texture.type !== \"Texture\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": cannot add \", texture, \" to this \" + this.type + \" because it is not a valid texture\");\n        }\n\n        return;\n      }\n\n      texture.addParent(this);\n    }\n    /***\r\n     This method handles the sources loading process\r\n       params :\r\n     @sourcesArray (array): array of html images, videos or canvases elements\r\n     @texturesOptions (object, optional) : Parameters to apply to those textures (see Texture class). Will be merged with the mesh default textures options\r\n     @successCallback (function): callback to execute on source loading success\r\n     @errorCallback (function): callback to execute on source loading error\r\n     ***/\n\n  }, {\n    key: \"loadSources\",\n    value: function loadSources(sourcesArray) {\n      var texturesOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var errorCallback = arguments.length > 3 ? arguments[3] : undefined;\n\n      for (var i = 0; i < sourcesArray.length; i++) {\n        this.loadSource(sourcesArray[i], texturesOptions, successCallback, errorCallback);\n      }\n    }\n    /***\r\n     This method loads one source using our mesh loader (see PlaneTextureLoader class)\r\n       params :\r\n     @source (html element) : html image, video or canvas element\r\n     @textureOptions (object, optional) : Parameters to apply to that texture (see Texture class). Will be merged with the mesh default textures options\r\n     @successCallback (function): callback to execute on source loading success\r\n     @errorCallback (function): callback to execute on source loading error\r\n     ***/\n\n  }, {\n    key: \"loadSource\",\n    value: function loadSource(source) {\n      var _this25 = this;\n\n      var textureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var errorCallback = arguments.length > 3 ? arguments[3] : undefined;\n      this.loader.loadSource(source, Object.assign(textureOptions, this._texturesOptions), function (texture) {\n        successCallback && successCallback(texture);\n      }, function (source, error) {\n        if (!_this25.renderer.production) {\n          throwWarning(_this25.type + \": this HTML tag could not be converted into a texture:\", source.tagName);\n        }\n\n        errorCallback && errorCallback(source, error);\n      });\n    }\n    /***\r\n     This method loads an image using our mesh loader (see PlaneTextureLoader class)\r\n       params :\r\n     @source (image) : html image element\r\n     @textureOptions (object, optional) : Parameters to apply to that texture (see Texture class). Will be merged with the mesh default textures options\r\n     @successCallback (function): callback to execute on source loading success\r\n     @errorCallback (function): callback to execute on source loading error\r\n     ***/\n\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(source) {\n      var _this26 = this;\n\n      var textureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var errorCallback = arguments.length > 3 ? arguments[3] : undefined;\n      this.loader.loadImage(source, Object.assign(textureOptions, this._texturesOptions), function (texture) {\n        successCallback && successCallback(texture);\n      }, function (source, error) {\n        if (!_this26.renderer.production) {\n          throwWarning(_this26.type + \": There has been an error:\\n\", error, \"\\nwhile loading this image:\\n\", source);\n        }\n\n        errorCallback && errorCallback(source, error);\n      });\n    }\n    /***\r\n     This method loads a video using the mesh loader (see PlaneTextureLoader class)\r\n       params :\r\n     @source (video) : html video element\r\n     @textureOptions (object, optional) : Parameters to apply to that texture (see Texture class). Will be merged with the mesh default textures options\r\n     @successCallback (function): callback to execute on source loading success\r\n     @errorCallback (function): callback to execute on source loading error\r\n     ***/\n\n  }, {\n    key: \"loadVideo\",\n    value: function loadVideo(source) {\n      var _this27 = this;\n\n      var textureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var errorCallback = arguments.length > 3 ? arguments[3] : undefined;\n      this.loader.loadVideo(source, Object.assign(textureOptions, this._texturesOptions), function (texture) {\n        successCallback && successCallback(texture);\n      }, function (source, error) {\n        if (!_this27.renderer.production) {\n          throwWarning(_this27.type + \": There has been an error:\\n\", error, \"\\nwhile loading this video:\\n\", source);\n        }\n\n        errorCallback && errorCallback(source, error);\n      });\n    }\n    /***\r\n     This method loads a canvas using the mesh loader (see PlaneTextureLoader class)\r\n       params :\r\n     @source (canvas) : html canvas element\r\n     @textureOptions (object, optional) : Parameters to apply to that texture (see Texture class). Will be merged with the mesh default textures options\r\n     @successCallback (function): callback to execute on source loading success\r\n     ***/\n\n  }, {\n    key: \"loadCanvas\",\n    value: function loadCanvas(source) {\n      var textureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      this.loader.loadCanvas(source, Object.assign(textureOptions, this._texturesOptions), function (texture) {\n        successCallback && successCallback(texture);\n      });\n    }\n    /*** LOAD ARRAYS ***/\n\n    /***\r\n     Loads an array of images\r\n       params :\r\n     @imagesArray (array) : array of html image elements\r\n     @texturesOptions (object, optional) : Parameters to apply to those textures (see Texture class). Will be merged with the mesh default textures options\r\n     @successCallback (function): callback to execute on source loading success\r\n     @errorCallback (function): callback to execute on source loading error\r\n     ***/\n\n  }, {\n    key: \"loadImages\",\n    value: function loadImages(imagesArray) {\n      var texturesOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var errorCallback = arguments.length > 3 ? arguments[3] : undefined;\n\n      for (var i = 0; i < imagesArray.length; i++) {\n        this.loadImage(imagesArray[i], texturesOptions, successCallback, errorCallback);\n      }\n    }\n    /***\r\n     Loads an array of videos\r\n       params :\r\n     @videosArray (array) : array of html video elements\r\n     @texturesOptions (object, optional) : Parameters to apply to those textures (see Texture class). Will be merged with the mesh default textures options\r\n     @successCallback (function): callback to execute on source loading success\r\n     @errorCallback (function): callback to execute on source loading error\r\n     ***/\n\n  }, {\n    key: \"loadVideos\",\n    value: function loadVideos(videosArray) {\n      var texturesOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n      var errorCallback = arguments.length > 3 ? arguments[3] : undefined;\n\n      for (var i = 0; i < videosArray.length; i++) {\n        this.loadVideo(videosArray[i], texturesOptions, successCallback, errorCallback);\n      }\n    }\n    /***\r\n     Loads an array of canvases\r\n       params :\r\n     @canvasesArray (array) : array of html canvas elements\r\n     @texturesOptions (object, optional) : Parameters to apply to those textures (see Texture class). Will be merged with the mesh default textures options\r\n     @successCallback (function): callback to execute on source loading success\r\n     @errorCallback (function): callback to execute on source loading error\r\n     ***/\n\n  }, {\n    key: \"loadCanvases\",\n    value: function loadCanvases(canvasesArray) {\n      var texturesOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successCallback = arguments.length > 2 ? arguments[2] : undefined;\n\n      for (var i = 0; i < canvasesArray.length; i++) {\n        this.loadCanvas(canvasesArray[i], texturesOptions, successCallback);\n      }\n    }\n    /***\r\n     This has to be called in order to play the planes videos\r\n     We need this because on mobile devices we can't start playing a video without a user action\r\n     Once the video has started playing we set an interval and update a new frame to our our texture at a 30FPS rate\r\n     ***/\n\n  }, {\n    key: \"playVideos\",\n    value: function playVideos() {\n      var _this28 = this;\n\n      for (var i = 0; i < this.textures.length; i++) {\n        var texture = this.textures[i];\n\n        if (texture.sourceType === \"video\") {\n          var playPromise = texture.source.play(); // In browsers that dont yet support this functionality,\n          // playPromise wont be defined.\n\n          if (playPromise !== undefined) {\n            playPromise.catch(function (error) {\n              if (!_this28.renderer.production) throwWarning(_this28.type + \": Could not play the video : \", error);\n            });\n          }\n        }\n      }\n    }\n    /*** DRAW THE PLANE ***/\n\n    /***\r\n     We draw the plane, ie bind the buffers, set the active textures and draw it\r\n     ***/\n\n  }, {\n    key: \"_draw\",\n    value: function _draw() {\n      // enable/disable depth test\n      this.renderer.setDepthTest(this._depthTest); // face culling\n\n      this.renderer.setFaceCulling(this.cullFace); // update all uniforms set up by the user\n\n      this._program.updateUniforms(); // bind plane attributes buffers\n      // TODO ideally we should only bind the attributes buffers if the geometry changed\n      // however it is leading to some bugs on macOS & iOS and should therefore be tested extensively\n      // for now we'll disable this feature even tho it is ready to be used\n      //if(this.renderer.state.currentGeometryID !== this._geometry.definition.id || this.renderer.state.forceBufferUpdate) {\n\n\n      this._geometry.bindBuffers();\n\n      this.renderer.state.forceBufferUpdate = false; //}\n      // draw all our plane textures\n\n      for (var i = 0; i < this.textures.length; i++) {\n        // draw (bind and maybe update) our texture\n        this.textures[i]._draw(); // do not draw mesh if one of the active texture is not bound yet\n\n\n        if (this.textures[i]._sampler.isActive && !this.textures[i]._sampler.isTextureBound) {\n          return;\n        }\n      } // the draw call!\n\n\n      this._geometry.draw(); // reset active texture\n\n\n      this.renderer.state.activeTexture = null; // callback after draw\n\n      this._onAfterRenderCallback && this._onAfterRenderCallback();\n    }\n    /*** EVENTS ***/\n\n    /***\r\n     This is called each time a mesh can't be instanciated\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      if (callback) {\n        this._onErrorCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called each time a mesh's image has been loaded. Useful to handle a loader\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onLoading\",\n    value: function onLoading(callback) {\n      if (callback) {\n        this._onLoadingCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called when a mesh is ready to be drawn\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onReady\",\n    value: function onReady(callback) {\n      if (callback) {\n        this._onReadyCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called at each requestAnimationFrame call\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onRender\",\n    value: function onRender(callback) {\n      if (callback) {\n        this._onRenderCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called at each requestAnimationFrame call for each mesh after the draw call\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onAfterRender\",\n    value: function onAfterRender(callback) {\n      if (callback) {\n        this._onAfterRenderCallback = callback;\n      }\n\n      return this;\n    }\n    /*** DESTROYING ***/\n\n    /***\r\n     Remove an element by calling the appropriate renderer method\r\n     ***/\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      // first we want to stop drawing it\n      this._canDraw = false; // force unbinding frame buffer\n\n      if (this.target) {\n        this.renderer.bindFrameBuffer(null);\n      } // delete all the webgl bindings\n\n\n      this._dispose();\n\n      if (this.type === \"Plane\") {\n        this.renderer.removePlane(this);\n      } else if (this.type === \"ShaderPass\") {\n        // remove its render target first\n        if (this.target) {\n          this.target._shaderPass = null;\n          this.target.remove();\n          this.target = null;\n        }\n\n        this.renderer.removeShaderPass(this);\n      }\n    }\n    /***\r\n     This deletes all our mesh webgl bindings and its textures\r\n     ***/\n\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      if (this.gl) {\n        // dispose our geometry\n        this._geometry && this._geometry.dispose();\n\n        if (this.target && this.type === \"ShaderPass\") {\n          this.renderer.removeRenderTarget(this.target); // remove the first texture since it has been deleted with the render target\n\n          this.textures.shift();\n        } // unbind and delete the textures\n\n\n        for (var i = 0; i < this.textures.length; i++) {\n          this.textures[i]._dispose();\n        }\n\n        this.textures = [];\n      }\n    }\n  }]);\n\n  return Mesh;\n}();\n/***\r\n Here we create our DOMGLObject object\r\n We will extend our Mesh class object by adding HTML sizes helpers (bounding boxes getter/setter and mouse to mesh positioning)\r\n\r\n params:\r\n @renderer (Curtains renderer or Renderer class object): our curtains object OR our curtains renderer object\r\n @plane (html element): the html element that we will use for our DOMMesh object\r\n @type (string): Object type (should be either \"Plane\" or \"ShaderPass\")\r\n @Meshparams (object): see Mesh class object\r\n \r\n returns:\r\n @this: our BasePlane element\r\n ***/\n// avoid reinstancing those during runtime\n\n\nvar tempVec2a = new Vec2();\nvar tempVec2b = new Vec2();\n\nvar DOMMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(DOMMesh, _Mesh);\n\n  var _super2 = _createSuper(DOMMesh);\n\n  function DOMMesh(renderer, htmlElement) {\n    var _this29;\n\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"DOMMesh\";\n\n    var _ref10 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        widthSegments = _ref10.widthSegments,\n        heightSegments = _ref10.heightSegments,\n        renderOrder = _ref10.renderOrder,\n        depthTest = _ref10.depthTest,\n        cullFace = _ref10.cullFace,\n        uniforms = _ref10.uniforms,\n        vertexShaderID = _ref10.vertexShaderID,\n        fragmentShaderID = _ref10.fragmentShaderID,\n        vertexShader = _ref10.vertexShader,\n        fragmentShader = _ref10.fragmentShader,\n        texturesOptions = _ref10.texturesOptions,\n        crossOrigin = _ref10.crossOrigin;\n\n    _classCallCheck(this, DOMMesh);\n\n    // handling HTML shaders scripts\n    vertexShaderID = vertexShaderID || htmlElement && htmlElement.getAttribute(\"data-vs-id\");\n    fragmentShaderID = fragmentShaderID || htmlElement && htmlElement.getAttribute(\"data-fs-id\");\n    _this29 = _super2.call(this, renderer, type, {\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      renderOrder: renderOrder,\n      depthTest: depthTest,\n      cullFace: cullFace,\n      uniforms: uniforms,\n      vertexShaderID: vertexShaderID,\n      fragmentShaderID: fragmentShaderID,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      texturesOptions: texturesOptions,\n      crossOrigin: crossOrigin\n    }); // return if no gl context\n\n    if (!_this29.gl) {\n      return _possibleConstructorReturn(_this29);\n    } // our HTML element\n\n\n    _this29.htmlElement = htmlElement;\n\n    if (!_this29.htmlElement || _this29.htmlElement.length === 0) {\n      if (!_this29.renderer.production) throwWarning(_this29.type + \": The HTML element you specified does not currently exists in the DOM\");\n    } // set plane sizes\n\n\n    _this29._setDocumentSizes();\n\n    return _this29;\n  }\n  /*** PLANE SIZES ***/\n\n  /***\r\n   Set our plane dimensions and positions relative to document\r\n   Triggers reflow!\r\n   ***/\n\n\n  _createClass(DOMMesh, [{\n    key: \"_setDocumentSizes\",\n    value: function _setDocumentSizes() {\n      // set our basic initial infos\n      var planeBoundingRect = this.htmlElement.getBoundingClientRect();\n      if (!this._boundingRect) this._boundingRect = {}; // set plane dimensions in document space\n\n      this._boundingRect.document = {\n        width: planeBoundingRect.width * this.renderer.pixelRatio,\n        height: planeBoundingRect.height * this.renderer.pixelRatio,\n        top: planeBoundingRect.top * this.renderer.pixelRatio,\n        left: planeBoundingRect.left * this.renderer.pixelRatio\n      };\n    }\n  }, {\n    key: \"getBoundingRect\",\n    value:\n    /*** BOUNDING BOXES GETTERS ***/\n\n    /***\r\n     Useful to get our plane HTML element bounding rectangle without triggering a reflow/layout\r\n       returns :\r\n     @boundingRectangle (obj): an object containing our plane HTML element bounding rectangle (width, height, top, bottom, right and left properties)\r\n     ***/\n    function getBoundingRect() {\n      return {\n        width: this._boundingRect.document.width,\n        height: this._boundingRect.document.height,\n        top: this._boundingRect.document.top,\n        left: this._boundingRect.document.left,\n        // right = left + width, bottom = top + height\n        right: this._boundingRect.document.left + this._boundingRect.document.width,\n        bottom: this._boundingRect.document.top + this._boundingRect.document.height\n      };\n    }\n    /***\r\n     Handles each plane resizing\r\n     used internally when our container is resized\r\n     ***/\n\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      var _this30 = this;\n\n      // reset plane dimensions\n      this._setDocumentSizes(); // if this is a Plane object we need to update its perspective and positions\n\n\n      if (this.type === \"Plane\") {\n        // reset perspective\n        this.setPerspective(this.camera.fov, this.camera.near, this.camera.far); // apply new position\n\n        this._setWorldSizes();\n\n        this._applyWorldPositions();\n      } // resize all textures\n\n\n      for (var i = 0; i < this.textures.length; i++) {\n        this.textures[i].resize();\n      } // handle our after resize event\n\n\n      this.renderer.nextRender.add(function () {\n        return _this30._onAfterResizeCallback && _this30._onAfterResizeCallback();\n      });\n    }\n    /*** INTERACTION ***/\n\n    /***\r\n     This function takes the mouse position relative to the document and returns it relative to our plane\r\n     It ranges from -1 to 1 on both axis\r\n       params :\r\n     @mouseCoordinates (Vec2 object): coordinates of the mouse\r\n       returns :\r\n     @mousePosition (Vec2 object): the mouse position relative to our plane in WebGL space coordinates\r\n     ***/\n\n  }, {\n    key: \"mouseToPlaneCoords\",\n    value: function mouseToPlaneCoords(mouseCoordinates) {\n      // remember our ShaderPass objects don't have a scale property\n      var scale = this.scale ? this.scale : tempVec2b.set(1, 1); // we need to adjust our plane document bounding rect to it's webgl scale\n\n      var scaleAdjustment = tempVec2a.set((this._boundingRect.document.width - this._boundingRect.document.width * scale.x) / 2, (this._boundingRect.document.height - this._boundingRect.document.height * scale.y) / 2); // also we need to divide by pixel ratio\n\n      var planeBoundingRect = {\n        width: this._boundingRect.document.width * scale.x / this.renderer.pixelRatio,\n        height: this._boundingRect.document.height * scale.y / this.renderer.pixelRatio,\n        top: (this._boundingRect.document.top + scaleAdjustment.y) / this.renderer.pixelRatio,\n        left: (this._boundingRect.document.left + scaleAdjustment.x) / this.renderer.pixelRatio\n      }; // mouse position conversion from document to plane space\n\n      return tempVec2a.set((mouseCoordinates.x - planeBoundingRect.left) / planeBoundingRect.width * 2 - 1, 1 - (mouseCoordinates.y - planeBoundingRect.top) / planeBoundingRect.height * 2);\n    }\n    /*** EVENTS ***/\n\n    /***\r\n     This is called each time a plane has been resized\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onAfterResize\",\n    value: function onAfterResize(callback) {\n      if (callback) {\n        this._onAfterResizeCallback = callback;\n      }\n\n      return this;\n    }\n  }]);\n\n  return DOMMesh;\n}(Mesh);\n/***\r\n Here we create our Camera object\r\n Creates a perspective camera and its projection matrix (which is used by Plane's class objects)\r\n Uses a dirty _shouldUpdate flag used to determine if we should update the matrix\r\n\r\n params:\r\n @fov (float, optional): the perspective field of view. Should be greater than 0 and lower than 180. Default to 50.\r\n @near (float, optional): near plane, the closest point where a mesh vertex is drawn. Default to 0.1.\r\n @far (float, optional): far plane, farthest point where a mesh vertex is drawn. Default to 150.\r\n @width (float, optional): width used to calculate the camera aspect ratio. Default to the renderer container's width.\r\n @height (float, optional): height used to calculate the camera aspect ratio. Default to the renderer container's height.\r\n @pixelRatio (float, optional): pixel ratio used to calculate the camera aspect ratio. Default to the renderer's pixel ratio.\r\n\r\n returns:\r\n @this: our Mesh element\r\n ***/\n\n\nvar Camera = /*#__PURE__*/function () {\n  function Camera() {\n    var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref11$fov = _ref11.fov,\n        fov = _ref11$fov === void 0 ? 50 : _ref11$fov,\n        _ref11$near = _ref11.near,\n        near = _ref11$near === void 0 ? 0.1 : _ref11$near,\n        _ref11$far = _ref11.far,\n        far = _ref11$far === void 0 ? 150 : _ref11$far,\n        width = _ref11.width,\n        height = _ref11.height,\n        _ref11$pixelRatio = _ref11.pixelRatio,\n        pixelRatio = _ref11$pixelRatio === void 0 ? 1 : _ref11$pixelRatio;\n\n    _classCallCheck(this, Camera);\n\n    this.position = new Vec3();\n    this.projectionMatrix = new Mat4();\n    this.worldMatrix = new Mat4();\n    this.viewMatrix = new Mat4();\n    this._shouldUpdate = false;\n    this.setSize();\n    this.setPerspective(fov, near, far, width, height, pixelRatio);\n  }\n  /***\r\n   Sets the camera field of view\r\n   Update the camera projection matrix only if the fov actually changed\r\n     params:\r\n   @fov (float, optional): field of view to use\r\n   ***/\n\n\n  _createClass(Camera, [{\n    key: \"setFov\",\n    value: function setFov(fov) {\n      fov = isNaN(fov) ? this.fov : parseFloat(fov); // clamp between 1 and 179\n\n      fov = Math.max(1, Math.min(fov, 179));\n\n      if (fov !== this.fov) {\n        this.fov = fov;\n        this.setPosition();\n        this._shouldUpdate = true;\n      }\n\n      this.setCSSPerspective();\n    }\n    /***\r\n     Sets the camera near plane value\r\n     Update the camera projection matrix only if the near plane actually changed\r\n       params:\r\n     @near (float, optional): near plane value to use\r\n     ***/\n\n  }, {\n    key: \"setNear\",\n    value: function setNear(near) {\n      near = isNaN(near) ? this.near : parseFloat(near);\n      near = Math.max(near, 0.01);\n\n      if (near !== this.near) {\n        this.near = near;\n        this._shouldUpdate = true;\n      }\n    }\n    /***\r\n     Sets the camera far plane value\r\n     Update the camera projection matrix only if the far plane actually changed\r\n       params:\r\n     @far (float, optional): far plane value to use\r\n     ***/\n\n  }, {\n    key: \"setFar\",\n    value: function setFar(far) {\n      far = isNaN(far) ? this.far : parseFloat(far);\n      far = Math.max(far, 50);\n\n      if (far !== this.far) {\n        this.far = far;\n        this._shouldUpdate = true;\n      }\n    }\n    /***\r\n     Sets the camera pixel ratio value\r\n     Update the camera projection matrix only if the pixel ratio actually changed\r\n       params:\r\n     @pixelRatio (float, optional): pixelRatio value to use\r\n     ***/\n\n  }, {\n    key: \"setPixelRatio\",\n    value: function setPixelRatio(pixelRatio) {\n      if (pixelRatio !== this.pixelRatio) {\n        this._shouldUpdate = true;\n      }\n\n      this.pixelRatio = pixelRatio;\n    }\n    /***\r\n     Sets the camera width and height\r\n     Update the camera projection matrix only if the width or height actually changed\r\n       params:\r\n     @width (float, optional): width value to use\r\n     @height (float, optional): height value to use\r\n     ***/\n\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      if (width !== this.width || height !== this.height) {\n        this._shouldUpdate = true;\n      }\n\n      this.width = width;\n      this.height = height;\n    }\n    /***\r\n     Sets the camera perspective\r\n     Update the camera projection matrix if our _shouldUpdate flag is true\r\n       params:\r\n     @fov (float, optional): field of view to use\r\n     @near (float, optional): near plane value to use\r\n     @far (float, optional): far plane value to use\r\n     @width (float, optional): width value to use\r\n     @height (float, optional): height value to use\r\n     @pixelRatio (float, optional): pixelRatio value to use\r\n     ***/\n\n  }, {\n    key: \"setPerspective\",\n    value: function setPerspective(fov, near, far, width, height, pixelRatio) {\n      this.setPixelRatio(pixelRatio);\n      this.setSize(width, height);\n      this.setFov(fov);\n      this.setNear(near);\n      this.setFar(far);\n\n      if (this._shouldUpdate) {\n        this.updateProjectionMatrix();\n      }\n    }\n    /***\r\n     Sets the camera position based on its fov\r\n     Used by the Plane class objects to scale the planes with the right amount\r\n     ***/\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition() {\n      this.position.set(0, 0, 1); // update matrices\n\n      this.worldMatrix.setFromArray([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, this.position.x, this.position.y, this.position.z, 1]);\n      this.viewMatrix = this.viewMatrix.copy(this.worldMatrix).getInverse();\n    }\n    /***\r\n     Sets a CSSPerspective property based on width, height, pixelRatio and fov\r\n     Used to translate planes along the Z axis using pixel units as CSS would do\r\n     Taken from: https://stackoverflow.com/questions/22421439/convert-field-of-view-value-to-css3d-perspective-value\r\n     ***/\n\n  }, {\n    key: \"setCSSPerspective\",\n    value: function setCSSPerspective() {\n      this.CSSPerspective = Math.pow(Math.pow(this.width / (2 * this.pixelRatio), 2) + Math.pow(this.height / (2 * this.pixelRatio), 2), 0.5) / Math.tan(this.fov * 0.5 * Math.PI / 180);\n    }\n    /***\r\n     Returns visible width / height at a given z-depth from our camera parameters\r\n       Taken from: https://discourse.threejs.org/t/functions-to-calculate-the-visible-width-height-at-a-given-z-depth-from-a-perspective-camera/269\r\n     ***/\n\n  }, {\n    key: \"getScreenRatiosFromFov\",\n    value: function getScreenRatiosFromFov() {\n      var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // compensate for cameras not positioned at z=0\n      var cameraOffset = this.position.z;\n\n      if (depth < cameraOffset) {\n        depth -= cameraOffset;\n      } else {\n        depth += cameraOffset;\n      } // vertical fov in radians\n\n\n      var vFOV = this.fov * Math.PI / 180; // Math.abs to ensure the result is always positive\n\n      var height = 2 * Math.tan(vFOV / 2) * Math.abs(depth);\n      return {\n        width: height * this.width / this.height,\n        height: height\n      };\n    }\n    /***\r\n     Updates the camera projection matrix\r\n     ***/\n\n  }, {\n    key: \"updateProjectionMatrix\",\n    value: function updateProjectionMatrix() {\n      var aspect = this.width / this.height;\n      var top = this.near * Math.tan(Math.PI / 180 * 0.5 * this.fov);\n      var height = 2 * top;\n      var width = aspect * height;\n      var left = -0.5 * width;\n      var right = left + width;\n      var bottom = top - height;\n      var x = 2 * this.near / (right - left);\n      var y = 2 * this.near / (top - bottom);\n      var a = (right + left) / (right - left);\n      var b = (top + bottom) / (top - bottom);\n      var c = -(this.far + this.near) / (this.far - this.near);\n      var d = -2 * this.far * this.near / (this.far - this.near);\n      this.projectionMatrix.setFromArray([x, 0, 0, 0, 0, y, 0, 0, a, b, c, -1, 0, 0, d, 0]);\n    }\n    /***\r\n     Force the projection matrix to update (used in Plane class objects context restoration)\r\n     ***/\n\n  }, {\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      this._shouldUpdate = true;\n    }\n    /***\r\n     Cancel the projection matrix update (used in Plane class objects after the projection matrix has been updated)\r\n     ***/\n\n  }, {\n    key: \"cancelUpdate\",\n    value: function cancelUpdate() {\n      this._shouldUpdate = false;\n    }\n  }]);\n\n  return Camera;\n}();\n/***\r\n Here we create a Quat class object\r\n This is a really basic Quaternion class used for rotation calculations\r\n Highly based on https://github.com/mrdoob/three.js/blob/dev/src/math/Quaternion.js\r\n\r\n params :\r\n @elements (Float32Array of length 4): our quaternion array. Default to identity quaternion.\r\n\r\n returns :\r\n @this: our Quat class object\r\n ***/\n// TODO lot of (unused at the time) methods are missing\n\n\nvar Quat = /*#__PURE__*/function () {\n  function Quat() {\n    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Float32Array([0, 0, 0, 1]);\n    var axisOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"XYZ\";\n\n    _classCallCheck(this, Quat);\n\n    this.type = \"Quat\";\n    this.elements = elements; // rotation axis order\n\n    this.axisOrder = axisOrder;\n  }\n  /***\r\n   Sets the quaternion values from an array\r\n     params:\r\n   @array (array): an array of at least 4 elements\r\n     returns:\r\n   @this (Quat class object): this quaternion after being set\r\n   ***/\n\n\n  _createClass(Quat, [{\n    key: \"setFromArray\",\n    value: function setFromArray(array) {\n      this.elements[0] = array[0];\n      this.elements[1] = array[1];\n      this.elements[2] = array[2];\n      this.elements[3] = array[3];\n      return this;\n    }\n    /***\r\n     Sets the quaternion axis order\r\n       params:\r\n     @axisOrder (string): an array of at least 4 elements\r\n       returns:\r\n     @this (Quat class object): this quaternion after axis order has been set\r\n     ***/\n\n  }, {\n    key: \"setAxisOrder\",\n    value: function setAxisOrder(axisOrder) {\n      // force uppercase for strict equality tests\n      axisOrder = axisOrder.toUpperCase();\n\n      switch (axisOrder) {\n        case \"XYZ\":\n        case \"YXZ\":\n        case \"ZXY\":\n        case \"ZYX\":\n        case \"YZX\":\n        case \"XZY\":\n          this.axisOrder = axisOrder;\n          break;\n\n        default:\n          // apply a default axis order\n          this.axisOrder = \"XYZ\";\n      }\n\n      return this;\n    }\n    /***\r\n     Copy a quaternion into this quaternion\r\n       params:\r\n     @vector (Quat): quaternion to copy\r\n       returns:\r\n     @this (Quat): this quaternion after copy\r\n     ***/\n\n  }, {\n    key: \"copy\",\n    value: function copy(quaternion) {\n      this.elements = quaternion.elements;\n      this.axisOrder = quaternion.axisOrder;\n      return this;\n    }\n    /***\r\n     Clone a quaternion\r\n       returns:\r\n     @clonedQuaternion (Quat): cloned quaternion\r\n     ***/\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Quat().copy(this);\n    }\n    /***\r\n     Checks if 2 quaternions are equal\r\n       returns:\r\n     @isEqual (bool): whether the quaternions are equals or not\r\n     ***/\n\n  }, {\n    key: \"equals\",\n    value: function equals(quaternion) {\n      return this.elements[0] === quaternion.elements[0] && this.elements[1] === quaternion.elements[1] && this.elements[2] === quaternion.elements[2] && this.elements[3] === quaternion.elements[3] && this.axisOrder === quaternion.axisOrder;\n    }\n    /***\r\n     Sets a rotation quaternion using Euler angles and its axis order\r\n       params:\r\n     @vector (Vec3 class object): rotation vector to set our quaternion from\r\n       returns :\r\n     @this (Quat class object): quaternion after having applied the rotation\r\n     ***/\n\n  }, {\n    key: \"setFromVec3\",\n    value: function setFromVec3(vector) {\n      var ax = vector.x * 0.5;\n      var ay = vector.y * 0.5;\n      var az = vector.z * 0.5;\n      var cosx = Math.cos(ax);\n      var cosy = Math.cos(ay);\n      var cosz = Math.cos(az);\n      var sinx = Math.sin(ax);\n      var siny = Math.sin(ay);\n      var sinz = Math.sin(az); // XYZ order\n\n      if (this.axisOrder === \"XYZ\") {\n        this.elements[0] = sinx * cosy * cosz + cosx * siny * sinz;\n        this.elements[1] = cosx * siny * cosz - sinx * cosy * sinz;\n        this.elements[2] = cosx * cosy * sinz + sinx * siny * cosz;\n        this.elements[3] = cosx * cosy * cosz - sinx * siny * sinz;\n      } else if (this.axisOrder === \"YXZ\") {\n        this.elements[0] = sinx * cosy * cosz + cosx * siny * sinz;\n        this.elements[1] = cosx * siny * cosz - sinx * cosy * sinz;\n        this.elements[2] = cosx * cosy * sinz - sinx * siny * cosz;\n        this.elements[3] = cosx * cosy * cosz + sinx * siny * sinz;\n      } else if (this.axisOrder === \"ZXY\") {\n        this.elements[0] = sinx * cosy * cosz - cosx * siny * sinz;\n        this.elements[1] = cosx * siny * cosz + sinx * cosy * sinz;\n        this.elements[2] = cosx * cosy * sinz + sinx * siny * cosz;\n        this.elements[3] = cosx * cosy * cosz - sinx * siny * sinz;\n      } else if (this.axisOrder === \"ZYX\") {\n        this.elements[0] = sinx * cosy * cosz - cosx * siny * sinz;\n        this.elements[1] = cosx * siny * cosz + sinx * cosy * sinz;\n        this.elements[2] = cosx * cosy * sinz - sinx * siny * cosz;\n        this.elements[3] = cosx * cosy * cosz + sinx * siny * sinz;\n      } else if (this.axisOrder === \"YZX\") {\n        this.elements[0] = sinx * cosy * cosz + cosx * siny * sinz;\n        this.elements[1] = cosx * siny * cosz + sinx * cosy * sinz;\n        this.elements[2] = cosx * cosy * sinz - sinx * siny * cosz;\n        this.elements[3] = cosx * cosy * cosz - sinx * siny * sinz;\n      } else if (this.axisOrder === \"XZY\") {\n        this.elements[0] = sinx * cosy * cosz - cosx * siny * sinz;\n        this.elements[1] = cosx * siny * cosz - sinx * cosy * sinz;\n        this.elements[2] = cosx * cosy * sinz + sinx * siny * cosz;\n        this.elements[3] = cosx * cosy * cosz + sinx * siny * sinz;\n      }\n\n      return this;\n    }\n  }]);\n\n  return Quat;\n}();\n/***\r\n Here we create our Plane object\r\n We will extend our DOMMesh class that handles all the WebGL part and basic HTML sizings\r\n\r\n Plane class will add:\r\n - sizing and positioning and everything that relates to the DOM like draw checks (frustum culling) and reenter/leave events\r\n - projection (using Camera class object) and view matrices and everything that is related like perspective, scale, rotation...\r\n\r\n params :\r\n @renderer (Curtains renderer or Renderer class object): our curtains object OR our curtains renderer object\r\n @plane (html element): the html element that we will use for our Plane object\r\n\r\n @Meshparams (object): see Mesh class object\r\n\r\n @alwaysDraw (boolean, optionnal): if the plane should always be drawn or if it should use frustum culling. Default to false.\r\n @visible (boolean, optional): if the plane should be drawn or not. Default to true.\r\n @transparent (boolean, optional): if the plane should handle transparency. Default to false.\r\n @drawCheckMargins (object, optional): defines the margins in pixels to add to the frustum culling check to determine if the plane should be drawn. Default to 0.\r\n @autoloadSources (boolean, optional): if the sources should be loaded on init automatically. Default to true\r\n @watchScroll (boolean, optional): if the plane should auto update its position based on the scroll value. Default to true.\r\n @fov (float, optional): defines the perspective field of view used by the camera. Default to 50.\r\n\r\n returns :\r\n @this: our Plane\r\n ***/\n// avoid reinstancing those during runtime\n\n\nvar tempScale = new Vec2(); // positions\n\nvar tempWorldPos1 = new Vec3();\nvar tempWorldPos2 = new Vec3(); // frustum culling\n\nvar tempCorner1 = new Vec3();\nvar tempCorner2 = new Vec3();\nvar tempCorner3 = new Vec3();\nvar tempCorner4 = new Vec3();\nvar tempCulledCorner1 = new Vec3();\nvar tempCulledCorner2 = new Vec3(); // raycasting\n\nvar identityQuat = new Quat();\nvar defaultTransformOrigin = new Vec3(0.5, 0.5, 0);\nvar tempRayDirection = new Vec3();\nvar tempNormals = new Vec3();\nvar tempRotatedOrigin = new Vec3();\nvar tempRaycast = new Vec3();\nvar castedMouseCoords = new Vec2();\n\nvar Plane = /*#__PURE__*/function (_DOMMesh) {\n  _inherits(Plane, _DOMMesh);\n\n  var _super3 = _createSuper(Plane);\n\n  function Plane(renderer, htmlElement) {\n    var _this31;\n\n    var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        widthSegments = _ref12.widthSegments,\n        heightSegments = _ref12.heightSegments,\n        renderOrder = _ref12.renderOrder,\n        depthTest = _ref12.depthTest,\n        cullFace = _ref12.cullFace,\n        uniforms = _ref12.uniforms,\n        vertexShaderID = _ref12.vertexShaderID,\n        fragmentShaderID = _ref12.fragmentShaderID,\n        vertexShader = _ref12.vertexShader,\n        fragmentShader = _ref12.fragmentShader,\n        texturesOptions = _ref12.texturesOptions,\n        crossOrigin = _ref12.crossOrigin,\n        _ref12$alwaysDraw = _ref12.alwaysDraw,\n        alwaysDraw = _ref12$alwaysDraw === void 0 ? false : _ref12$alwaysDraw,\n        _ref12$visible = _ref12.visible,\n        visible = _ref12$visible === void 0 ? true : _ref12$visible,\n        _ref12$transparent = _ref12.transparent,\n        transparent = _ref12$transparent === void 0 ? false : _ref12$transparent,\n        _ref12$drawCheckMargi = _ref12.drawCheckMargins,\n        drawCheckMargins = _ref12$drawCheckMargi === void 0 ? {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    } : _ref12$drawCheckMargi,\n        _ref12$autoloadSource = _ref12.autoloadSources,\n        autoloadSources = _ref12$autoloadSource === void 0 ? true : _ref12$autoloadSource,\n        _ref12$watchScroll = _ref12.watchScroll,\n        watchScroll = _ref12$watchScroll === void 0 ? true : _ref12$watchScroll,\n        _ref12$fov = _ref12.fov,\n        fov = _ref12$fov === void 0 ? 50 : _ref12$fov;\n\n    _classCallCheck(this, Plane);\n\n    _this31 = _super3.call(this, renderer, htmlElement, \"Plane\", {\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      renderOrder: renderOrder,\n      depthTest: depthTest,\n      cullFace: cullFace,\n      uniforms: uniforms,\n      vertexShaderID: vertexShaderID,\n      fragmentShaderID: fragmentShaderID,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      texturesOptions: texturesOptions,\n      crossOrigin: crossOrigin\n    }); // return if no gl context\n\n    if (!_this31.gl) {\n      return _possibleConstructorReturn(_this31);\n    }\n\n    _this31.index = _this31.renderer.planes.length; // used for FBOs\n\n    _this31.target = null; // use frustum culling or not\n\n    _this31.alwaysDraw = alwaysDraw; // should draw is set to true by default, we'll check it later\n\n    _this31._shouldDraw = true;\n    _this31.visible = visible; // if the plane has transparency\n\n    _this31._transparent = transparent; // draw check margins in pixels\n    // positive numbers means it can be displayed even when outside the viewport\n    // negative numbers means it can be hidden even when inside the viewport\n\n    _this31.drawCheckMargins = drawCheckMargins; // if we decide to load all sources on init or let the user do it manually\n\n    _this31.autoloadSources = autoloadSources; // if we should watch scroll\n\n    _this31.watchScroll = watchScroll; // define if we should update the plane's matrices when called in the draw loop\n\n    _this31._updateMVMatrix = false; // init camera\n\n    _this31.camera = new Camera({\n      fov: fov,\n      width: _this31.renderer._boundingRect.width,\n      height: _this31.renderer._boundingRect.height,\n      pixelRatio: _this31.renderer.pixelRatio\n    }); // if program is valid, go on\n\n    if (_this31._program.compiled) {\n      // init our plane\n      _this31._initPlane(); // add our plane to the scene stack and the renderer array\n\n\n      _this31.renderer.scene.addPlane(_assertThisInitialized(_this31));\n\n      _this31.renderer.planes.push(_assertThisInitialized(_this31));\n    }\n\n    return _this31;\n  }\n  /*** RESTORING CONTEXT ***/\n\n  /***\r\n   Used internally to handle context restoration after the program has been successfully compiled again\r\n   ***/\n\n\n  _createClass(Plane, [{\n    key: \"_programRestored\",\n    value: function _programRestored() {\n      if (this.target) {\n        // reset its render target if needed\n        this.setRenderTarget(this.renderer.renderTargets[this.target.index]);\n      }\n\n      this._initMatrices(); // set our initial perspective matrix\n\n\n      this.setPerspective(this.camera.fov, this.camera.near, this.camera.far);\n\n      this._setWorldSizes();\n\n      this._applyWorldPositions(); // add the plane to our draw stack again as it have been emptied\n\n\n      this.renderer.scene.addPlane(this); // reset textures\n\n      for (var i = 0; i < this.textures.length; i++) {\n        this.textures[i]._parent = this;\n\n        this.textures[i]._restoreContext();\n      }\n\n      this._canDraw = true;\n    }\n    /***\r\n     Init our basic plane values (transformations, positions, camera, sources)\r\n     ***/\n\n  }, {\n    key: \"_initPlane\",\n    value: function _initPlane() {\n      // init transformation values\n      this._initTransformValues(); // init its position values\n\n\n      this._initPositions(); // set camera values\n\n\n      this.setPerspective(this.camera.fov, this.camera.near, this.camera.far); // load sources\n\n      this._initSources();\n    }\n    /*** TRANSFORMATIONS, PROJECTION & MATRICES ***/\n\n    /***\r\n     Set/reset plane's transformation values: rotation, scale, translation, transform origin\r\n     ***/\n\n  }, {\n    key: \"_initTransformValues\",\n    value: function _initTransformValues() {\n      var _this32 = this;\n\n      this.rotation = new Vec3();\n      this.rotation.onChange(function () {\n        return _this32._applyRotation();\n      }); // initial quaternion\n\n      this.quaternion = new Quat(); // translation in viewport coordinates\n\n      this.relativeTranslation = new Vec3();\n      this.relativeTranslation.onChange(function () {\n        return _this32._setTranslation();\n      }); // translation in webgl coordinates\n\n      this._translation = new Vec3(); // scale is a Vec3 with z always equal to 1\n\n      this.scale = new Vec3(1);\n      this.scale.onChange(function () {\n        _this32.scale.z = 1;\n\n        _this32._applyScale();\n      }); // set plane transform origin to center\n\n      this.transformOrigin = new Vec3(0.5, 0.5, 0);\n      this.transformOrigin.onChange(function () {\n        // set transformation origin relative to world space as well\n        _this32._setWorldTransformOrigin();\n\n        _this32._updateMVMatrix = true;\n      });\n    }\n    /***\r\n     Reset our plane transformation values and HTML element if specified (and valid)\r\n       params :\r\n     @htmlElement (HTML element, optional) : if provided, new HTML element to use as a reference for sizes and position syncing.\r\n     ***/\n\n  }, {\n    key: \"resetPlane\",\n    value: function resetPlane(htmlElement) {\n      this._initTransformValues(); // reset transformation origin relative to world space as well\n\n\n      this._setWorldTransformOrigin();\n\n      if (htmlElement !== null && !!htmlElement) {\n        this.htmlElement = htmlElement;\n        this.resize();\n      } else if (!htmlElement && !this.renderer.production) {\n        throwWarning(this.type + \": You are trying to reset a plane with a HTML element that does not exist. The old HTML element will be kept instead.\");\n      }\n    }\n    /***\r\n     This function removes the plane current render target\r\n     ***/\n\n  }, {\n    key: \"removeRenderTarget\",\n    value: function removeRenderTarget() {\n      if (this.target) {\n        // reset our planes stacks\n        this.renderer.scene.removePlane(this);\n        this.target = null;\n        this.renderer.scene.addPlane(this);\n      }\n    }\n    /***\r\n     Init our plane position: set its matrices, its position and perspective\r\n     ***/\n\n  }, {\n    key: \"_initPositions\",\n    value: function _initPositions() {\n      // set its matrices\n      this._initMatrices(); // apply our css positions\n\n\n      this._setWorldSizes();\n\n      this._applyWorldPositions();\n    }\n    /***\r\n     Init our plane model view and projection matrices and set their uniform locations\r\n     ***/\n\n  }, {\n    key: \"_initMatrices\",\n    value: function _initMatrices() {\n      // create our matrices, they will be set after\n      var matrix = new Mat4();\n      this._matrices = {\n        world: {\n          // world matrix (global transformation)\n          matrix: matrix\n        },\n        modelView: {\n          // model view matrix (world matrix multiplied by camera view matrix)\n          name: \"uMVMatrix\",\n          matrix: matrix,\n          location: this.gl.getUniformLocation(this._program.program, \"uMVMatrix\")\n        },\n        projection: {\n          // camera projection matrix\n          name: \"uPMatrix\",\n          matrix: matrix,\n          location: this.gl.getUniformLocation(this._program.program, \"uPMatrix\")\n        },\n        modelViewProjection: {\n          // model view projection matrix (model view matrix multiplied by projection)\n          matrix: matrix\n        }\n      };\n    }\n    /*** PLANES PERSPECTIVES, SCALES AND ROTATIONS ***/\n\n    /***\r\n     This will set our perspective matrix and update our perspective matrix uniform\r\n     used internally at each draw call if needed\r\n     ***/\n\n  }, {\n    key: \"_setPerspectiveMatrix\",\n    value: function _setPerspectiveMatrix() {\n      // update our matrix uniform if we actually have updated its values\n      if (this.camera._shouldUpdate) {\n        this.renderer.useProgram(this._program);\n        this.gl.uniformMatrix4fv(this._matrices.projection.location, false, this._matrices.projection.matrix.elements);\n      } // reset camera shouldUpdate flag\n\n\n      this.camera.cancelUpdate();\n    }\n    /***\r\n     This will set our perspective matrix new parameters (fov, near plane and far plane)\r\n     used internally but can be used externally as well to change fov for example\r\n       params :\r\n     @fov (float): the field of view\r\n     @near (float): the nearest point where object are displayed\r\n     @far (float): the farthest point where object are displayed\r\n     ***/\n\n  }, {\n    key: \"setPerspective\",\n    value: function setPerspective(fov, near, far) {\n      this.camera.setPerspective(fov, near, far, this.renderer._boundingRect.width, this.renderer._boundingRect.height, this.renderer.pixelRatio); // force camera update on context restoration\n\n      if (this.renderer.state.isContextLost) {\n        this.camera.forceUpdate();\n      }\n\n      this._matrices.projection.matrix = this.camera.projectionMatrix;\n\n      if (this.camera._shouldUpdate) {\n        // we changed the fov, update world sizes and world positions\n        this._setWorldSizes();\n\n        this._applyWorldPositions(); // translation along the Z axis is dependant of camera CSSPerspective\n        // we're computing it here because it changes when the fov changes\n\n\n        this._translation.z = this.relativeTranslation.z / this.camera.CSSPerspective;\n      } // if camera settings changed update the mvMatrix as well cause we need to update z translation based on new fov\n\n\n      this._updateMVMatrix = this.camera._shouldUpdate;\n    }\n    /***\r\n     This will set our model view matrix\r\n     used internally at each draw call if needed\r\n     It will calculate our matrix based on its plane translation, rotation and scale\r\n     ***/\n\n  }, {\n    key: \"_setMVMatrix\",\n    value: function _setMVMatrix() {\n      if (this._updateMVMatrix) {\n        // compose our world transformation matrix from custom origin\n        this._matrices.world.matrix = this._matrices.world.matrix.composeFromOrigin(this._translation, this.quaternion, this.scale, this._boundingRect.world.transformOrigin); // we need to scale our planes, from a square to a right sized rectangle\n        // we're doing this after our transformation matrix because this scale transformation always have the same origin\n\n        this._matrices.world.matrix.scale({\n          x: this._boundingRect.world.width,\n          y: this._boundingRect.world.height,\n          z: 1\n        }); // our model view matrix is our world matrix multiplied with our camera view matrix\n        // in our case we're just subtracting the camera Z position to our world matrix\n\n\n        this._matrices.modelView.matrix.copy(this._matrices.world.matrix);\n\n        this._matrices.modelView.matrix.elements[14] -= this.camera.position.z; // our modelViewProjection matrix, useful for bounding box calculations and frustum culling\n        // this is the result of our projection matrix multiplied by our modelView matrix\n\n        this._matrices.modelViewProjection.matrix = this._matrices.projection.matrix.multiply(this._matrices.modelView.matrix); // check if we should draw the plane but only if everything has been initialized\n\n        if (!this.alwaysDraw) {\n          this._shouldDrawCheck();\n        } // update our matrix uniform\n\n\n        this.renderer.useProgram(this._program);\n        this.gl.uniformMatrix4fv(this._matrices.modelView.location, false, this._matrices.modelView.matrix.elements);\n      } // reset our flag\n\n\n      this._updateMVMatrix = false;\n    }\n    /*** SCREEN TO WORLD CALCS ***/\n\n    /***\r\n     Convert our transform origin point from plane space to world space\r\n     ***/\n\n  }, {\n    key: \"_setWorldTransformOrigin\",\n    value: function _setWorldTransformOrigin() {\n      // set transformation origin relative to world space as well\n      this._boundingRect.world.transformOrigin = new Vec3((this.transformOrigin.x * 2 - 1) * // between -1 and 1\n      this._boundingRect.world.width, -(this.transformOrigin.y * 2 - 1) // between -1 and 1\n      * this._boundingRect.world.height, this.transformOrigin.z);\n    }\n    /***\r\n     This function takes pixel values along X and Y axis and convert them to world space coordinates\r\n       params :\r\n     @vector (Vec3): position to convert on X, Y and Z axes\r\n       returns :\r\n     @worldPosition: plane's position in WebGL space\r\n     ***/\n\n  }, {\n    key: \"_documentToWorldSpace\",\n    value: function _documentToWorldSpace(vector) {\n      return tempWorldPos2.set(vector.x * this.renderer.pixelRatio / this.renderer._boundingRect.width * this._boundingRect.world.ratios.width, -(vector.y * this.renderer.pixelRatio / this.renderer._boundingRect.height) * this._boundingRect.world.ratios.height, vector.z);\n    }\n    /***\r\n     Set our plane dimensions relative to clip spaces\r\n     ***/\n\n  }, {\n    key: \"_setWorldSizes\",\n    value: function _setWorldSizes() {\n      var ratios = this.camera.getScreenRatiosFromFov(); // our plane world informations\n      // since our vertices values range from -1 to 1, it is supposed to draw a square\n      // we need to scale them under the hood relatively to our canvas\n      // to display an accurately sized plane\n\n      this._boundingRect.world = {\n        width: this._boundingRect.document.width / this.renderer._boundingRect.width * ratios.width / 2,\n        height: this._boundingRect.document.height / this.renderer._boundingRect.height * ratios.height / 2,\n        ratios: ratios\n      }; // set transformation origin relative to world space as well\n\n      this._setWorldTransformOrigin();\n    }\n    /***\r\n     Set our plane position relative to clip spaces\r\n     ***/\n\n  }, {\n    key: \"_setWorldPosition\",\n    value: function _setWorldPosition() {\n      // dimensions and positions of our plane in the document and clip spaces\n      // don't forget translations in webgl space are referring to the center of our plane and canvas\n      var planeCenter = {\n        x: this._boundingRect.document.width / 2 + this._boundingRect.document.left,\n        y: this._boundingRect.document.height / 2 + this._boundingRect.document.top\n      };\n      var containerCenter = {\n        x: this.renderer._boundingRect.width / 2 + this.renderer._boundingRect.left,\n        y: this.renderer._boundingRect.height / 2 + this.renderer._boundingRect.top\n      };\n      this._boundingRect.world.top = (containerCenter.y - planeCenter.y) / this.renderer._boundingRect.height * this._boundingRect.world.ratios.height;\n      this._boundingRect.world.left = (planeCenter.x - containerCenter.x) / this.renderer._boundingRect.width * this._boundingRect.world.ratios.width;\n    }\n    /*** TRANSFORMATIONS ***/\n\n    /***\r\n     This will set our plane scale\r\n     used internally but can be used externally as well\r\n       params :\r\n     @scale (Vec2 object): scale to apply on X and Y axes\r\n     ***/\n\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      if (!scale.type || scale.type !== \"Vec2\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": Cannot set scale because the parameter passed is not of Vec2 type:\", scale);\n        }\n\n        return;\n      }\n\n      scale.sanitizeNaNValuesWith(this.scale).max(tempScale.set(0.001, 0.001)); // only apply if values changed\n\n      if (scale.x !== this.scale.x || scale.y !== this.scale.y) {\n        this.scale.set(scale.x, scale.y, 1);\n\n        this._applyScale();\n      }\n    }\n    /***\r\n     This will apply our scale and tells our model view matrix to update\r\n     ***/\n\n  }, {\n    key: \"_applyScale\",\n    value: function _applyScale() {\n      // adjust textures size\n      for (var i = 0; i < this.textures.length; i++) {\n        this.textures[i].resize();\n      } // we should update the plane mvMatrix\n\n\n      this._updateMVMatrix = true;\n    }\n    /***\r\n     This will set our plane rotation\r\n     used internally but can be used externally as well\r\n       params :\r\n     @rotation (Vec3 object): rotation to apply on X, Y and Z axes (in radians)\r\n     ***/\n\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(rotation) {\n      if (!rotation.type || rotation.type !== \"Vec3\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": Cannot set rotation because the parameter passed is not of Vec3 type:\", rotation);\n        }\n\n        return;\n      }\n\n      rotation.sanitizeNaNValuesWith(this.rotation); // only apply if values changed\n\n      if (!rotation.equals(this.rotation)) {\n        this.rotation.copy(rotation);\n\n        this._applyRotation();\n      }\n    }\n    /***\r\n     This will apply our rotation and tells our model view matrix to update\r\n     ***/\n\n  }, {\n    key: \"_applyRotation\",\n    value: function _applyRotation() {\n      this.quaternion.setFromVec3(this.rotation); // we should update the plane mvMatrix\n\n      this._updateMVMatrix = true;\n    }\n    /***\r\n     This will set our plane transform origin\r\n     (0, 0, 0) means plane's top left corner\r\n     (1, 1, 0) means plane's bottom right corner\r\n     (0.5, 0.5, -1) means behind plane's center\r\n       params :\r\n     @origin (Vec3 object): coordinate of transformation origin X, Y and Z axes\r\n     ***/\n\n  }, {\n    key: \"setTransformOrigin\",\n    value: function setTransformOrigin(origin) {\n      if (!origin.type || origin.type !== \"Vec3\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": Cannot set transform origin because the parameter passed is not of Vec3 type:\", origin);\n        }\n\n        return;\n      }\n\n      origin.sanitizeNaNValuesWith(this.transformOrigin);\n\n      if (!origin.equals(this.transformOrigin)) {\n        this.transformOrigin.copy(origin); // set transformation origin relative to world space as well\n\n        this._setWorldTransformOrigin();\n\n        this._updateMVMatrix = true;\n      }\n    }\n    /***\r\n     This will set our plane translation by adding plane computed bounding box values and computed relative position values\r\n     ***/\n\n  }, {\n    key: \"_setTranslation\",\n    value: function _setTranslation() {\n      // avoid unnecessary calculations if we don't have a users set relative position\n      var worldPosition = tempWorldPos1.set(0, 0, 0);\n\n      if (!this.relativeTranslation.equals(worldPosition)) {\n        worldPosition = this._documentToWorldSpace(this.relativeTranslation);\n      }\n\n      this._translation.set(this._boundingRect.world.left + worldPosition.x, this._boundingRect.world.top + worldPosition.y, //this._translation.z,\n      this.relativeTranslation.z / this.camera.CSSPerspective); // we should update the plane mvMatrix\n\n\n      this._updateMVMatrix = true;\n    }\n    /***\r\n     This function takes pixel values along X and Y axis and convert them to clip space coordinates, and then apply the corresponding translation\r\n       params :\r\n     @translation (Vec3): translation to apply on X, Y and Z axes\r\n     ***/\n\n  }, {\n    key: \"setRelativeTranslation\",\n    value: function setRelativeTranslation(translation) {\n      if (!translation.type || translation.type !== \"Vec3\") {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": Cannot set translation because the parameter passed is not of Vec3 type:\", translation);\n        }\n\n        return;\n      }\n\n      translation.sanitizeNaNValuesWith(this.relativeTranslation); // only apply if values changed\n\n      if (!translation.equals(this.relativeTranslation)) {\n        this.relativeTranslation.copy(translation);\n\n        this._setTranslation();\n      }\n    }\n    /***\r\n     This function uses our plane HTML Element bounding rectangle values and convert them to the world clip space coordinates, and then apply the corresponding translation\r\n     ***/\n\n  }, {\n    key: \"_applyWorldPositions\",\n    value: function _applyWorldPositions() {\n      // set our plane sizes and positions relative to the world clipspace\n      this._setWorldPosition(); // set the translation values\n\n\n      this._setTranslation();\n    }\n    /***\r\n     This function updates the plane position based on its CSS positions and transformations values.\r\n     Useful if the HTML element has been moved while the container size has not changed.\r\n     ***/\n\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition() {\n      // set the new plane sizes and positions relative to document by triggering getBoundingClientRect()\n      this._setDocumentSizes(); // apply them\n\n\n      this._applyWorldPositions();\n    }\n    /***\r\n     This function updates the plane position based on the Curtains class scroll manager values\r\n       params:\r\n     @lastXDelta (float): last scroll value along X axis\r\n     @lastYDelta (float): last scroll value along Y axis\r\n     ***/\n\n  }, {\n    key: \"updateScrollPosition\",\n    value: function updateScrollPosition(lastXDelta, lastYDelta) {\n      // actually update the plane position only if last X delta or last Y delta is not equal to 0\n      if (lastXDelta || lastYDelta) {\n        // set new positions based on our delta without triggering reflow\n        this._boundingRect.document.top += lastYDelta * this.renderer.pixelRatio;\n        this._boundingRect.document.left += lastXDelta * this.renderer.pixelRatio; // apply them\n\n        this._applyWorldPositions();\n      }\n    }\n    /*** FRUSTUM CULLING (DRAW CHECK) ***/\n\n    /***\r\n     Find the intersection point by adding a vector starting from a corner till we reach the near plane\r\n       params:\r\n     @refPoint (Vec3 class object): corner of the plane from which we start to iterate from\r\n     @secondPoint (Vec3 class object): second point near the refPoint to get a direction to use for iteration\r\n       returns:\r\n     @intersection (Vec3 class object): intersection between our plane and the camera near plane\r\n     ***/\n\n  }, {\n    key: \"_getIntersection\",\n    value: function _getIntersection(refPoint, secondPoint) {\n      // direction vector to add\n      var direction = secondPoint.clone().sub(refPoint); // copy our corner refpoint\n\n      var intersection = refPoint.clone(); // iterate till we reach near plane\n\n      while (intersection.z > -1) {\n        intersection.add(direction);\n      }\n\n      return intersection;\n    }\n    /***\r\n     Get intersection points between a plane and the camera near plane\r\n     When a plane gets clipped by the camera near plane, the clipped corner projected coords returned by _applyMat4() are erronate\r\n     We need to find the intersection points using another approach\r\n     Here I chose to use non clipped corners projected coords and a really small vector parallel to the plane's side\r\n     We're adding that vector again and again to our corner projected coords until the Z coordinate matches the near plane: we got our intersection\r\n       params:\r\n     @corners (array): our original corners vertices coordinates\r\n     @mvpCorners (array): the projected corners of our plane\r\n     @clippedCorners (array): index of the corners that are clipped\r\n       returns:\r\n     @mvpCorners (array): the corrected projected corners of our plane\r\n     ***/\n\n  }, {\n    key: \"_getNearPlaneIntersections\",\n    value: function _getNearPlaneIntersections(corners, mvpCorners, clippedCorners) {\n      // rebuild the clipped corners based on non clipped ones\n      var mVPMatrix = this._matrices.modelViewProjection.matrix;\n\n      if (clippedCorners.length === 1) {\n        // we will have 5 corners to check so we'll need to push a new entry in our mvpCorners array\n        if (clippedCorners[0] === 0) {\n          // top left is culled\n          // get intersection iterating from top right\n          mvpCorners[0] = this._getIntersection(mvpCorners[1], tempCulledCorner1.set(0.95, 1, 0).applyMat4(mVPMatrix)); // get intersection iterating from bottom left\n\n          mvpCorners.push(this._getIntersection(mvpCorners[3], tempCulledCorner2.set(-1, -0.95, 0).applyMat4(mVPMatrix)));\n        } else if (clippedCorners[0] === 1) {\n          // top right is culled\n          // get intersection iterating from top left\n          mvpCorners[1] = this._getIntersection(mvpCorners[0], tempCulledCorner1.set(-0.95, 1, 0).applyMat4(mVPMatrix)); // get intersection iterating from bottom right\n\n          mvpCorners.push(this._getIntersection(mvpCorners[2], tempCulledCorner2.set(1, -0.95, 0).applyMat4(mVPMatrix)));\n        } else if (clippedCorners[0] === 2) {\n          // bottom right is culled\n          // get intersection iterating from bottom left\n          mvpCorners[2] = this._getIntersection(mvpCorners[3], tempCulledCorner1.set(-0.95, -1, 0).applyMat4(mVPMatrix)); // get intersection iterating from top right\n\n          mvpCorners.push(this._getIntersection(mvpCorners[1], tempCulledCorner2.set(1, 0.95, 0).applyMat4(mVPMatrix)));\n        } else if (clippedCorners[0] === 3) {\n          // bottom left is culled\n          // get intersection iterating from bottom right\n          mvpCorners[3] = this._getIntersection(mvpCorners[2], tempCulledCorner1.set(0.95, -1, 0).applyMat4(mVPMatrix)); // get intersection iterating from top left\n\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner2.set(-1, 0.95, 0).applyMat4(mVPMatrix)));\n        }\n      } else if (clippedCorners.length === 2) {\n        if (clippedCorners[0] === 0 && clippedCorners[1] === 1) {\n          // top part of the plane is culled by near plane\n          // find intersection using bottom corners\n          mvpCorners[0] = this._getIntersection(mvpCorners[3], tempCulledCorner1.set(-1, -0.95, 0).applyMat4(mVPMatrix));\n          mvpCorners[1] = this._getIntersection(mvpCorners[2], tempCulledCorner2.set(1, -0.95, 0).applyMat4(mVPMatrix));\n        } else if (clippedCorners[0] === 1 && clippedCorners[1] === 2) {\n          // right part of the plane is culled by near plane\n          // find intersection using left corners\n          mvpCorners[1] = this._getIntersection(mvpCorners[0], tempCulledCorner1.set(-0.95, 1, 0).applyMat4(mVPMatrix));\n          mvpCorners[2] = this._getIntersection(mvpCorners[3], tempCulledCorner2.set(-0.95, -1, 0).applyMat4(mVPMatrix));\n        } else if (clippedCorners[0] === 2 && clippedCorners[1] === 3) {\n          // bottom part of the plane is culled by near plane\n          // find intersection using top corners\n          mvpCorners[2] = this._getIntersection(mvpCorners[1], tempCulledCorner1.set(1, 0.95, 0).applyMat4(mVPMatrix));\n          mvpCorners[3] = this._getIntersection(mvpCorners[0], tempCulledCorner2.set(-1, 0.95, 0).applyMat4(mVPMatrix));\n        } else if (clippedCorners[0] === 0 && clippedCorners[1] === 3) {\n          // left part of the plane is culled by near plane\n          // find intersection using right corners\n          mvpCorners[0] = this._getIntersection(mvpCorners[1], tempCulledCorner1.set(0.95, 1, 0).applyMat4(mVPMatrix));\n          mvpCorners[3] = this._getIntersection(mvpCorners[2], tempCulledCorner2.set(0.95, -1, 0).applyMat4(mVPMatrix));\n        }\n      } else if (clippedCorners.length === 3) {\n        // get the corner that is not clipped\n        var nonClippedCorner = 0;\n\n        for (var i = 0; i < corners.length; i++) {\n          if (!clippedCorners.includes(i)) {\n            nonClippedCorner = i;\n          }\n        } // we will have just 3 corners so reset our mvpCorners array with just the visible corner\n\n\n        mvpCorners = [mvpCorners[nonClippedCorner]];\n\n        if (nonClippedCorner === 0) {\n          // from top left corner to right\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner1.set(-0.95, 1, 0).applyMat4(mVPMatrix))); // from top left corner to bottom\n\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner2.set(-1, 0.95, 0).applyMat4(mVPMatrix)));\n        } else if (nonClippedCorner === 1) {\n          // from top right corner to left\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner1.set(0.95, 1, 0).applyMat4(mVPMatrix))); // from top right corner to bottom\n\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner2.set(1, 0.95, 0).applyMat4(mVPMatrix)));\n        } else if (nonClippedCorner === 2) {\n          // from bottom right corner to left\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner1.set(0.95, -1, 0).applyMat4(mVPMatrix))); // from bottom right corner to top\n\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner2.set(1, -0.95, 0).applyMat4(mVPMatrix)));\n        } else if (nonClippedCorner === 3) {\n          // from bottom left corner to right\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner1.set(-0.95, -1, 0).applyMat4(mVPMatrix))); // from bottom left corner to top\n\n          mvpCorners.push(this._getIntersection(mvpCorners[0], tempCulledCorner2.set(-1 - 0.95, 0).applyMat4(mVPMatrix)));\n        }\n      } else {\n        // all 4 corners are culled! artificially apply wrong coords to force plane culling\n        for (var _i8 = 0; _i8 < corners.length; _i8++) {\n          mvpCorners[_i8][0] = 10000;\n          mvpCorners[_i8][1] = 10000;\n        }\n      }\n\n      return mvpCorners;\n    }\n  }, {\n    key: \"_getWorldCoords\",\n    value:\n    /***\r\n     Useful to get our WebGL plane bounding box in the world space\r\n     Takes all transformations into account\r\n     Used internally for frustum culling\r\n       returns :\r\n     @boundingRectangle (obj): an object containing our plane WebGL element 4 corners coordinates: top left corner is [-1, 1] and bottom right corner is [1, -1]\r\n     ***/\n    function _getWorldCoords() {\n      var corners = [tempCorner1.set(-1, 1, 0), // plane's top left corner\n      tempCorner2.set(1, 1, 0), // plane's top right corner\n      tempCorner3.set(1, -1, 0), // plane's bottom right corner\n      tempCorner4.set(-1, -1, 0) // plane's bottom left corner\n      ]; // corners with model view projection matrix applied\n\n      var mvpCorners = []; // eventual clipped corners\n\n      var clippedCorners = []; // we are going to get our plane's four corners relative to our model view projection matrix\n\n      for (var i = 0; i < corners.length; i++) {\n        var mvpCorner = corners[i].applyMat4(this._matrices.modelViewProjection.matrix);\n        mvpCorners.push(mvpCorner); // Z position is > 1 or < -1 means the corner is clipped\n\n        if (Math.abs(mvpCorner.z) > 1) {\n          clippedCorners.push(i);\n        }\n      } // near plane is clipping, get intersections between plane and near plane\n\n\n      if (clippedCorners.length) {\n        mvpCorners = this._getNearPlaneIntersections(corners, mvpCorners, clippedCorners);\n      } // we need to check for the X and Y min and max values\n      // use arbitrary integers that will be overriden anyway\n\n\n      var minX = Infinity;\n      var maxX = -Infinity;\n      var minY = Infinity;\n      var maxY = -Infinity;\n\n      for (var _i9 = 0; _i9 < mvpCorners.length; _i9++) {\n        var corner = mvpCorners[_i9];\n\n        if (corner.x < minX) {\n          minX = corner.x;\n        }\n\n        if (corner.x > maxX) {\n          maxX = corner.x;\n        }\n\n        if (corner.y < minY) {\n          minY = corner.y;\n        }\n\n        if (corner.y > maxY) {\n          maxY = corner.y;\n        }\n      }\n\n      return {\n        top: maxY,\n        right: maxX,\n        bottom: minY,\n        left: minX\n      };\n    }\n  }, {\n    key: \"_computeWebGLBoundingRect\",\n    value:\n    /***\r\n     Transpose our plane corners coordinates from world space to document space\r\n     Sets an object with the accurate plane WebGL bounding rect relative to document\r\n     ***/\n    function _computeWebGLBoundingRect() {\n      // get our world space bouding rect\n      var worldBBox = this._getWorldCoords(); // normalize worldBBox to (0 -> 1) screen coordinates with [0, 0] being the top left corner and [1, 1] being the bottom right\n\n\n      var screenBBox = {\n        top: 1 - (worldBBox.top + 1) / 2,\n        right: (worldBBox.right + 1) / 2,\n        bottom: 1 - (worldBBox.bottom + 1) / 2,\n        left: (worldBBox.left + 1) / 2\n      };\n      screenBBox.width = screenBBox.right - screenBBox.left;\n      screenBBox.height = screenBBox.bottom - screenBBox.top; // return our values ranging from 0 to 1 multiplied by our canvas sizes + canvas top and left offsets\n\n      this._boundingRect.worldToDocument = {\n        width: screenBBox.width * this.renderer._boundingRect.width,\n        height: screenBBox.height * this.renderer._boundingRect.height,\n        top: screenBBox.top * this.renderer._boundingRect.height + this.renderer._boundingRect.top,\n        left: screenBBox.left * this.renderer._boundingRect.width + this.renderer._boundingRect.left,\n        // add left and width to get right property\n        right: screenBBox.left * this.renderer._boundingRect.width + this.renderer._boundingRect.left + screenBBox.width * this.renderer._boundingRect.width,\n        // add top and height to get bottom property\n        bottom: screenBBox.top * this.renderer._boundingRect.height + this.renderer._boundingRect.top + screenBBox.height * this.renderer._boundingRect.height\n      };\n    }\n    /***\r\n     Returns our plane WebGL bounding rect relative to document\r\n       returns :\r\n     @boundingRectangle (obj): an object containing our plane WebGL element bounding rectangle (width, height, top, bottom, right and left properties)\r\n     ***/\n\n  }, {\n    key: \"getWebGLBoundingRect\",\n    value: function getWebGLBoundingRect() {\n      if (!this._matrices.modelViewProjection) {\n        return this._boundingRect.document;\n      } else if (!this._boundingRect.worldToDocument || this.alwaysDraw) {\n        this._computeWebGLBoundingRect();\n      }\n\n      return this._boundingRect.worldToDocument;\n    }\n    /***\r\n     Returns our plane WebGL bounding rectangle in document coordinates including additional drawCheckMargins\r\n       returns :\r\n     @boundingRectangle (obj): an object containing our plane WebGL element bounding rectangle including the draw check margins (top, bottom, right and left properties)\r\n     ***/\n\n  }, {\n    key: \"_getWebGLDrawRect\",\n    value: function _getWebGLDrawRect() {\n      this._computeWebGLBoundingRect();\n\n      return {\n        top: this._boundingRect.worldToDocument.top - this.drawCheckMargins.top,\n        right: this._boundingRect.worldToDocument.right + this.drawCheckMargins.right,\n        bottom: this._boundingRect.worldToDocument.bottom + this.drawCheckMargins.bottom,\n        left: this._boundingRect.worldToDocument.left - this.drawCheckMargins.left\n      };\n    }\n    /***\r\n     This function checks if the plane is currently visible in the canvas and sets _shouldDraw property according to this test\r\n     This is our real frustum culling check\r\n     ***/\n\n  }, {\n    key: \"_shouldDrawCheck\",\n    value: function _shouldDrawCheck() {\n      var _this33 = this;\n\n      // get plane bounding rect\n      var actualPlaneBounds = this._getWebGLDrawRect(); // if we decide to draw the plane only when visible inside the canvas\n      // we got to check if its actually inside the canvas\n\n\n      if (Math.round(actualPlaneBounds.right) <= this.renderer._boundingRect.left || Math.round(actualPlaneBounds.left) >= this.renderer._boundingRect.left + this.renderer._boundingRect.width || Math.round(actualPlaneBounds.bottom) <= this.renderer._boundingRect.top || Math.round(actualPlaneBounds.top) >= this.renderer._boundingRect.top + this.renderer._boundingRect.height) {\n        if (this._shouldDraw) {\n          this._shouldDraw = false; // callback for leaving view\n\n          this.renderer.nextRender.add(function () {\n            return _this33._onLeaveViewCallback && _this33._onLeaveViewCallback();\n          });\n        }\n      } else {\n        if (!this._shouldDraw) {\n          // callback for entering view\n          this.renderer.nextRender.add(function () {\n            return _this33._onReEnterViewCallback && _this33._onReEnterViewCallback();\n          });\n        }\n\n        this._shouldDraw = true;\n      }\n    }\n    /***\r\n     This function returns if the plane is actually drawn (ie fully initiated, visible property set to true and not culled)\r\n     ***/\n\n  }, {\n    key: \"isDrawn\",\n    value: function isDrawn() {\n      return this._canDraw && this.visible && (this._shouldDraw || this.alwaysDraw);\n    }\n    /*** DEPTH AND RENDER ORDER ***/\n\n    /***\r\n     This function set/unset the depth test for that plane\r\n       params :\r\n     @shouldEnableDepthTest (bool): enable/disable depth test for that plane\r\n     ***/\n\n  }, {\n    key: \"enableDepthTest\",\n    value: function enableDepthTest(shouldEnableDepthTest) {\n      this._depthTest = shouldEnableDepthTest;\n    }\n    /*** SOURCES ***/\n\n    /***\r\n     Load our initial sources if needed and calls onReady callback\r\n     ***/\n\n  }, {\n    key: \"_initSources\",\n    value: function _initSources() {\n      // finally load every sources already in our plane html element\n      // load plane sources\n      var loaderSize = 0;\n\n      if (this.autoloadSources) {\n        // load images\n        var imagesArray = [];\n\n        for (var i = 0; i < this.htmlElement.getElementsByTagName(\"img\").length; i++) {\n          imagesArray.push(this.htmlElement.getElementsByTagName(\"img\")[i]);\n        }\n\n        if (imagesArray.length > 0) {\n          this.loadImages(imagesArray);\n        } // load videos\n\n\n        var videosArray = [];\n\n        for (var _i10 = 0; _i10 < this.htmlElement.getElementsByTagName(\"video\").length; _i10++) {\n          videosArray.push(this.htmlElement.getElementsByTagName(\"video\")[_i10]);\n        }\n\n        if (videosArray.length > 0) {\n          this.loadVideos(videosArray);\n        } // load canvases\n\n\n        var canvasesArray = [];\n\n        for (var _i11 = 0; _i11 < this.htmlElement.getElementsByTagName(\"canvas\").length; _i11++) {\n          canvasesArray.push(this.htmlElement.getElementsByTagName(\"canvas\")[_i11]);\n        }\n\n        if (canvasesArray.length > 0) {\n          this.loadCanvases(canvasesArray);\n        }\n\n        loaderSize = imagesArray.length + videosArray.length + canvasesArray.length;\n      }\n\n      this.loader._setLoaderSize(loaderSize);\n\n      this._canDraw = true;\n    }\n    /*** DRAWING ***/\n\n    /***\r\n     Specific instructions for the Plane class to execute before drawing it\r\n     ***/\n\n  }, {\n    key: \"_startDrawing\",\n    value: function _startDrawing() {\n      // check if our plane is ready to draw\n      if (this._canDraw) {\n        // even if our plane should not be drawn we still execute its onRender callback and update its uniforms\n        if (this._onRenderCallback) {\n          this._onRenderCallback();\n        } // to improve webgl pipeline performace, we might want to update each texture that needs an update here\n        // see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#texImagetexSubImage_uploads_particularly_with_videos_can_cause_pipeline_flushes\n        // if we should render to a render target\n\n\n        if (this.target) {\n          this.renderer.bindFrameBuffer(this.target);\n        } else if (this.renderer.state.scenePassIndex === null) {\n          this.renderer.bindFrameBuffer(null);\n        } // update our perspective matrix\n\n\n        this._setPerspectiveMatrix(); // update our mv matrix\n\n\n        this._setMVMatrix(); // now check if we really need to draw it and its textures\n\n\n        if ((this.alwaysDraw || this._shouldDraw) && this.visible) {\n          this._draw();\n        }\n      }\n    }\n    /*** INTERACTION ***/\n\n    /***\r\n     This function takes the mouse position relative to the document and returns it relative to our plane\r\n     It ranges from -1 to 1 on both axis\r\n       params :\r\n     @mouseCoordinates (Vec2 object): coordinates of the mouse\r\n       returns :\r\n     @mousePosition (Vec2 object): the mouse position relative to our plane in WebGL space coordinates\r\n     ***/\n\n  }, {\n    key: \"mouseToPlaneCoords\",\n    value: function mouseToPlaneCoords(mouseCoordinates) {\n      identityQuat.setAxisOrder(this.quaternion.axisOrder); // plane has no rotation and transform origin is set to default, no need for real raycasting\n\n      if (identityQuat.equals(this.quaternion) && defaultTransformOrigin.equals(this.transformOrigin)) {\n        return _get(_getPrototypeOf(Plane.prototype), \"mouseToPlaneCoords\", this).call(this, mouseCoordinates);\n      } else {\n        // raycasting\n        // based on https://people.cs.clemson.edu/~dhouse/courses/405/notes/raycast.pdf\n        // convert mouse position to 3d normalised device coordinates (from [-1, -1] to [1, 1])\n        var worldMouse = {\n          x: 2 * (mouseCoordinates.x / (this.renderer._boundingRect.width / this.renderer.pixelRatio)) - 1,\n          y: 2 * (1 - mouseCoordinates.y / (this.renderer._boundingRect.height / this.renderer.pixelRatio)) - 1\n        };\n        var rayOrigin = this.camera.position.clone(); // ray direction based on normalised coordinates and plane translation\n\n        var rayDirection = tempRayDirection.set(worldMouse.x, worldMouse.y, -0.5); // unproject ray direction\n\n        rayDirection.unproject(this.camera);\n        rayDirection.sub(rayOrigin).normalize(); // plane normals (could also be [0, 0, 1], makes no difference, raycasting lands the same result for both face)\n\n        var planeNormals = tempNormals.set(0, 0, -1); // apply plane quaternion to plane normals\n\n        planeNormals.applyQuat(this.quaternion).normalize();\n        var result = tempRaycast.set(0, 0, 0);\n        var denominator = planeNormals.dot(rayDirection);\n\n        if (Math.abs(denominator) >= 0.0001) {\n          var inverseViewMatrix = this._matrices.world.matrix.getInverse().multiply(this.camera.viewMatrix); // get the plane's center coordinates\n          // start with our transform origin point\n\n\n          var planeOrigin = this._boundingRect.world.transformOrigin.clone().add(this._translation); // rotate our transform origin about world center\n\n\n          var rotatedOrigin = tempRotatedOrigin.set(this._translation.x - planeOrigin.x, this._translation.y - planeOrigin.y, this._translation.z - planeOrigin.z);\n          rotatedOrigin.applyQuat(this.quaternion); // add it to our plane origin\n\n          planeOrigin.add(rotatedOrigin); // distance from ray origin to plane\n\n          var distance = planeNormals.dot(planeOrigin.clone().sub(rayOrigin)) / denominator;\n          result.copy(rayOrigin.add(rayDirection.multiplyScalar(distance)));\n          result.applyMat4(inverseViewMatrix);\n        } else {\n          // no intersection!\n          result.set(Infinity, Infinity, Infinity);\n        }\n\n        return castedMouseCoords.set(result.x, result.y);\n      }\n    }\n    /*** EVENTS ***/\n\n    /***\r\n     This is called each time a plane is entering again the view bounding box\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onReEnterView\",\n    value: function onReEnterView(callback) {\n      if (callback) {\n        this._onReEnterViewCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called each time a plane is leaving the view bounding box\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onLeaveView\",\n    value: function onLeaveView(callback) {\n      if (callback) {\n        this._onLeaveViewCallback = callback;\n      }\n\n      return this;\n    }\n  }]);\n\n  return Plane;\n}(DOMMesh);\n/***\r\n Here we create a RenderTarget class object\r\n\r\n params :\r\n @renderer (Curtains renderer or Renderer class object): our curtains object OR our curtains renderer object\r\n\r\n @shaderPass (ShaderPass class object): shader pass that will use that render target. Default to null\r\n @depth (bool, optional): whether to create a depth buffer (handle depth inside your render target). Default to false.\r\n @clear (bool, optional): whether the content of the render target should be cleared before being drawn. Should be set to false to handle ping-pong shading. Default to true.\r\n\r\n @minWidth (float, optional): minimum width of the render target\r\n @minHeight (float, optional): minimum height of the render target\r\n\r\n @texturesOptions (object, optional): options and parameters to apply to the render target texture. See the Texture class object.\r\n\r\n returns :\r\n @this: our RenderTarget class object\r\n ***/\n\n\nvar RenderTarget = /*#__PURE__*/function () {\n  function RenderTarget(renderer) {\n    var _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        shaderPass = _ref13.shaderPass,\n        _ref13$depth = _ref13.depth,\n        depth = _ref13$depth === void 0 ? false : _ref13$depth,\n        _ref13$clear = _ref13.clear,\n        clear = _ref13$clear === void 0 ? true : _ref13$clear,\n        _ref13$minWidth = _ref13.minWidth,\n        minWidth = _ref13$minWidth === void 0 ? 1024 : _ref13$minWidth,\n        _ref13$minHeight = _ref13.minHeight,\n        minHeight = _ref13$minHeight === void 0 ? 1024 : _ref13$minHeight,\n        _ref13$texturesOption = _ref13.texturesOptions,\n        texturesOptions = _ref13$texturesOption === void 0 ? {} : _ref13$texturesOption;\n\n    _classCallCheck(this, RenderTarget);\n\n    this.type = \"RenderTarget\"; // we could pass our curtains object OR our curtains renderer object\n\n    renderer = renderer && renderer.renderer || renderer;\n\n    if (!renderer || renderer.type !== \"Renderer\") {\n      throwError(this.type + \": Renderer not passed as first argument\", renderer);\n    } else if (!renderer.gl) {\n      if (!renderer.production) throwError(this.type + \": Unable to create a \" + this.type + \" because the Renderer WebGL context is not defined\"); // return if no gl context\n\n      return;\n    }\n\n    this.renderer = renderer;\n    this.gl = this.renderer.gl;\n    this.index = this.renderer.renderTargets.length;\n    this._shaderPass = shaderPass; // whether to create a render buffer\n\n    this._depth = depth;\n    this._shouldClear = clear;\n    this._minSize = {\n      width: minWidth * this.renderer.pixelRatio,\n      height: minHeight * this.renderer.pixelRatio\n    }; // default textures options depends on the type of Mesh and WebGL context\n\n    texturesOptions = Object.assign({\n      // set default sampler to \"uRenderTexture\" and isFBOTexture to true\n      sampler: \"uRenderTexture\",\n      isFBOTexture: true,\n      premultiplyAlpha: false,\n      anisotropy: 1,\n      generateMipmap: false,\n      floatingPoint: \"none\",\n      wrapS: this.gl.CLAMP_TO_EDGE,\n      wrapT: this.gl.CLAMP_TO_EDGE,\n      minFilter: this.gl.LINEAR,\n      magFilter: this.gl.LINEAR\n    }, texturesOptions);\n    this._texturesOptions = texturesOptions;\n    this.userData = {};\n    this.uuid = generateUUID();\n    this.renderer.renderTargets.push(this); // we've added a new object, keep Curtains class in sync with our renderer\n\n    this.renderer.onSceneChange();\n\n    this._initRenderTarget();\n  }\n  /***\r\n   Init our RenderTarget by setting its size, creating a textures array and then calling _createFrameBuffer()\r\n   ***/\n\n\n  _createClass(RenderTarget, [{\n    key: \"_initRenderTarget\",\n    value: function _initRenderTarget() {\n      this._setSize(); // create our render texture\n\n\n      this.textures = []; // create our frame buffer\n\n      this._createFrameBuffer();\n    }\n    /*** RESTORING CONTEXT ***/\n\n    /***\r\n     Restore a render target\r\n     Basically just re init it\r\n     ***/\n\n  }, {\n    key: \"_restoreContext\",\n    value: function _restoreContext() {\n      // reset size\n      this._setSize(); // re create our frame buffer and restore its texture\n\n\n      this._createFrameBuffer();\n    }\n    /***\r\n     Sets our RenderTarget size based on its parent plane size\r\n     ***/\n\n  }, {\n    key: \"_setSize\",\n    value: function _setSize() {\n      if (this._shaderPass && this._shaderPass._isScenePass) {\n        this._size = {\n          width: this.renderer._boundingRect.width,\n          height: this.renderer._boundingRect.height\n        };\n      } else {\n        this._size = {\n          width: Math.max(this._minSize.width, this.renderer._boundingRect.width),\n          height: Math.max(this._minSize.height, this.renderer._boundingRect.height)\n        };\n      }\n    }\n    /***\r\n     Resizes our RenderTarget (only resize it if it's a ShaderPass scene pass FBO)\r\n     ***/\n\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      // resize render target only if its a child of a shader pass\n      if (this._shaderPass) {\n        this._setSize();\n\n        this.textures[0].resize(); // cancel clear on resize\n\n        this.renderer.bindFrameBuffer(this, true);\n\n        if (this._depth) {\n          this._bindDepthBuffer();\n        }\n\n        this.renderer.bindFrameBuffer(null);\n      }\n    }\n    /***\r\n     Binds our depth buffer\r\n     ***/\n\n  }, {\n    key: \"_bindDepthBuffer\",\n    value: function _bindDepthBuffer() {\n      // render to our target texture by binding the framebuffer\n      if (this._depthBuffer) {\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this._depthBuffer); // allocate renderbuffer\n\n        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this._size.width, this._size.height); // attach renderbuffer\n\n        this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this._depthBuffer);\n      }\n    }\n    /***\r\n     Here we create our frame buffer object\r\n     We're also adding a render buffer object to handle depth if needed\r\n     ***/\n\n  }, {\n    key: \"_createFrameBuffer\",\n    value: function _createFrameBuffer() {\n      this._frameBuffer = this.gl.createFramebuffer(); // cancel clear on init\n\n      this.renderer.bindFrameBuffer(this, true); // if textures array is not empty it means we're restoring the context\n\n      if (this.textures.length) {\n        this.textures[0]._parent = this;\n\n        this.textures[0]._restoreContext();\n      } else {\n        // create a texture\n        var texture = new Texture(this.renderer, this._texturesOptions); // adds the render target as parent and adds the texture to our textures array as well\n\n        texture.addParent(this);\n      } // attach the texture as the first color attachment\n      // this.textures[0]._sampler.texture contains our WebGLTexture object\n\n\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.textures[0]._sampler.texture, 0); // create a depth renderbuffer\n\n      if (this._depth) {\n        this._depthBuffer = this.gl.createRenderbuffer();\n\n        this._bindDepthBuffer();\n      }\n\n      this.renderer.bindFrameBuffer(null);\n    }\n    /*** GET THE RENDER TARGET TEXTURE ***/\n\n    /***\r\n     Returns the render target's texture\r\n       returns :\r\n     @texture (Texture class object): our RenderTarget's texture\r\n     ***/\n\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      return this.textures[0];\n    }\n    /*** DESTROYING ***/\n\n    /***\r\n     Remove an element by calling the appropriate renderer method\r\n     ***/\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      // check if it is attached to a shader pass\n      if (this._shaderPass) {\n        if (!this.renderer.production) {\n          throwWarning(this.type + \": You're trying to remove a RenderTarget attached to a ShaderPass. You should remove that ShaderPass instead:\", this._shaderPass);\n        }\n\n        return;\n      }\n\n      this._dispose();\n\n      this.renderer.removeRenderTarget(this);\n    }\n    /***\r\n     Delete a RenderTarget buffers and its associated texture\r\n     ***/\n\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      if (this._frameBuffer) {\n        this.gl.deleteFramebuffer(this._frameBuffer);\n        this._frameBuffer = null;\n      }\n\n      if (this._depthBuffer) {\n        this.gl.deleteRenderbuffer(this._depthBuffer);\n        this._depthBuffer = null;\n      }\n\n      this.textures[0]._dispose();\n\n      this.textures = [];\n    }\n  }]);\n\n  return RenderTarget;\n}();\n/*** SHADERPASS CLASS ***/\n\n/***\r\n Here we create our ShaderPass object\r\n We will extend our DOMMesh class that handles all the WebGL part and basic HTML sizings\r\n ShaderPass class will add the frame buffer by creating a new RenderTarget class object\r\n\r\n params :\r\n @renderer (Curtains renderer or Renderer class object): our curtains object OR our curtains renderer object\r\n\r\n @Meshparams (object): see Mesh class object\r\n\r\n @depth (boolean, optionnal): whether the shader pass render target should use a depth buffer (see RenderTarget class object). Default to false.\r\n @clear (boolean, optional): whether the shader pass render target content should be cleared before being drawn (see RenderTarget class object). Default to true.\r\n @renderTarget (RenderTarget class object, optional): an already existing render target to use. Default to null.\r\n\r\n returns :\r\n @this: our ShaderPass element\r\n ***/\n\n\nvar ShaderPass = /*#__PURE__*/function (_DOMMesh2) {\n  _inherits(ShaderPass, _DOMMesh2);\n\n  var _super4 = _createSuper(ShaderPass);\n\n  function ShaderPass(renderer) {\n    var _this34;\n\n    var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        widthSegments = _ref14.widthSegments,\n        heightSegments = _ref14.heightSegments,\n        renderOrder = _ref14.renderOrder,\n        depthTest = _ref14.depthTest,\n        cullFace = _ref14.cullFace,\n        uniforms = _ref14.uniforms,\n        vertexShaderID = _ref14.vertexShaderID,\n        fragmentShaderID = _ref14.fragmentShaderID,\n        vertexShader = _ref14.vertexShader,\n        fragmentShader = _ref14.fragmentShader,\n        texturesOptions = _ref14.texturesOptions,\n        crossOrigin = _ref14.crossOrigin,\n        _ref14$depth = _ref14.depth,\n        depth = _ref14$depth === void 0 ? false : _ref14$depth,\n        _ref14$clear = _ref14.clear,\n        clear = _ref14$clear === void 0 ? true : _ref14$clear,\n        renderTarget = _ref14.renderTarget;\n\n    _classCallCheck(this, ShaderPass);\n\n    // force plane defintion to 1x1\n    widthSegments = 1;\n    heightSegments = 1; // always cull back face\n\n    cullFace = \"back\"; // use the renderer container as our HTML element to create a DOMMesh object\n\n    _this34 = _super4.call(this, renderer, renderer.container, \"ShaderPass\", {\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      renderOrder: renderOrder,\n      depthTest: depthTest,\n      cullFace: cullFace,\n      uniforms: uniforms,\n      vertexShaderID: vertexShaderID,\n      fragmentShaderID: fragmentShaderID,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      texturesOptions: texturesOptions,\n      crossOrigin: crossOrigin\n    }); // return if no gl context\n\n    if (!_this34.gl) {\n      return _possibleConstructorReturn(_this34);\n    } // default to scene pass\n\n\n    _this34._isScenePass = true;\n    _this34.index = _this34.renderer.shaderPasses.length;\n    _this34._depth = depth;\n    _this34._shouldClear = clear;\n    _this34.target = renderTarget;\n\n    if (_this34.target) {\n      // if there's a target defined it's not a scene pass\n      _this34._isScenePass = false; // inherit clear param\n\n      _this34._shouldClear = _this34.target._shouldClear;\n    } // if the program is valid, go on\n\n\n    if (_this34._program.compiled) {\n      _this34._initShaderPass(); // add shader pass to our renderer shaderPasses array\n\n\n      _this34.renderer.shaderPasses.push(_assertThisInitialized(_this34)); // wait one tick before adding our shader pass to the scene to avoid flickering black screen for one frame\n\n\n      _this34.renderer.nextRender.add(function () {\n        _this34.renderer.scene.addShaderPass(_assertThisInitialized(_this34));\n      });\n    }\n\n    return _this34;\n  }\n  /*** RESTORING CONTEXT ***/\n\n  /***\r\n   Used internally to handle context restoration after the program has been successfully compiled again\r\n   ***/\n\n\n  _createClass(ShaderPass, [{\n    key: \"_programRestored\",\n    value: function _programRestored() {\n      // we just need to re add the shader pass to the scene stack\n      if (this._isScenePass) {\n        this.renderer.scene.stacks.scenePasses.push(this.index);\n      } else {\n        this.renderer.scene.stacks.renderPasses.push(this.index);\n      } // restore the textures\n\n\n      for (var i = 0; i < this.textures.length; i++) {\n        this.textures[i]._parent = this;\n\n        this.textures[i]._restoreContext();\n      }\n\n      this._canDraw = true;\n    }\n    /***\r\n     Here we init additionnal shader pass planes properties\r\n     This mainly consists in creating our render texture and add a frame buffer object\r\n     ***/\n\n  }, {\n    key: \"_initShaderPass\",\n    value: function _initShaderPass() {\n      // create our frame buffer\n      if (!this.target) {\n        this._createFrameBuffer();\n      } else {\n        // set the render target\n        this.setRenderTarget(this.target);\n        this.target._shaderPass = this;\n      } // create a texture from the render target texture\n\n\n      var texture = new Texture(this.renderer, {\n        sampler: \"uRenderTexture\",\n        isFBOTexture: true,\n        fromTexture: this.target.getTexture()\n      });\n      texture.addParent(this); // onReady callback\n\n      this.loader._setLoaderSize(0);\n\n      this._canDraw = true; // be sure we'll update the scene even if drawing is disabled\n\n      this.renderer.needRender();\n    }\n    /***\r\n     Here we create our frame buffer object\r\n     We're also adding a render buffer object to handle depth inside our shader pass\r\n     ***/\n\n  }, {\n    key: \"_createFrameBuffer\",\n    value: function _createFrameBuffer() {\n      var target = new RenderTarget(this.renderer, {\n        shaderPass: this,\n        clear: this._shouldClear,\n        depth: this._depth,\n        texturesOptions: this._texturesOptions\n      });\n      this.setRenderTarget(target);\n    }\n    /*** DRAWING ***/\n\n    /***\r\n     Specific instructions for the Shader pass class to execute before drawing it\r\n     ***/\n\n  }, {\n    key: \"_startDrawing\",\n    value: function _startDrawing() {\n      // check if our plane is ready to draw\n      if (this._canDraw) {\n        // even if our plane should not be drawn we still execute its onRender callback and update its uniforms\n        if (this._onRenderCallback) {\n          this._onRenderCallback();\n        } // to improve webgl pipeline performance, we might want to update each texture that needs an update here\n        // see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#texImagetexSubImage_uploads_particularly_with_videos_can_cause_pipeline_flushes\n\n\n        if (this._isScenePass) {\n          // if this is a scene pass, check if theres one more coming next and eventually bind it\n          if (this.renderer.state.scenePassIndex + 1 < this.renderer.scene.stacks.scenePasses.length) {\n            this.renderer.bindFrameBuffer(this.renderer.scene.stacks.scenePasses[this.renderer.state.scenePassIndex + 1].target);\n            this.renderer.state.scenePassIndex++;\n          } else {\n            this.renderer.bindFrameBuffer(null);\n          }\n        } else if (this.renderer.state.scenePassIndex === null) {\n          // we are rendering a bunch of planes inside a render target, unbind it\n          this.renderer.bindFrameBuffer(null);\n        } // force attribute buffer bindings update\n\n\n        this.renderer.state.forceBufferUpdate = true; // now check if we really need to draw it and its textures\n\n        this._draw();\n      }\n    }\n  }]);\n\n  return ShaderPass;\n}(DOMMesh);\n/*** FBO PING PONG PLANE CLASS ***/\n\n/***\r\n A little helper to create a plane that will perform FBO ping pong\r\n This plane will use FBOs swapping, using these following steps:\r\n - create two render targets (read and write)\r\n - create a texture onto which we'll draw\r\n - before drawing our plane (onRender callback), apply the write pass as our plane render target\r\n - after drawing our plane (onAfterRender callback), swap the read and write pass and copy the read pass texture again\r\n\r\n params:\r\n @sampler (string): sampler name used to create our texture and that will be used inside your shader\r\n @planeParams: see Plane class object\r\n\r\n returns :\r\n @this: our PingPongPlane element\r\n ***/\n\n\nvar PingPongPlane = /*#__PURE__*/function (_Plane) {\n  _inherits(PingPongPlane, _Plane);\n\n  var _super5 = _createSuper(PingPongPlane);\n\n  function PingPongPlane(curtains, htmlElement) {\n    var _this35;\n\n    var _ref15 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref15$sampler = _ref15.sampler,\n        sampler = _ref15$sampler === void 0 ? \"uPingPongTexture\" : _ref15$sampler,\n        widthSegments = _ref15.widthSegments,\n        heightSegments = _ref15.heightSegments,\n        renderOrder = _ref15.renderOrder,\n        depthTest = _ref15.depthTest,\n        cullFace = _ref15.cullFace,\n        uniforms = _ref15.uniforms,\n        vertexShaderID = _ref15.vertexShaderID,\n        fragmentShaderID = _ref15.fragmentShaderID,\n        vertexShader = _ref15.vertexShader,\n        fragmentShader = _ref15.fragmentShader,\n        texturesOptions = _ref15.texturesOptions,\n        crossOrigin = _ref15.crossOrigin,\n        alwaysDraw = _ref15.alwaysDraw,\n        visible = _ref15.visible,\n        transparent = _ref15.transparent,\n        drawCheckMargins = _ref15.drawCheckMargins,\n        autoloadSources = _ref15.autoloadSources,\n        watchScroll = _ref15.watchScroll,\n        fov = _ref15.fov;\n\n    _classCallCheck(this, PingPongPlane);\n\n    // force depthTest and autoloadSources to false\n    depthTest = false;\n    autoloadSources = false; // create our plane\n\n    _this35 = _super5.call(this, curtains, htmlElement, {\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      renderOrder: renderOrder,\n      depthTest: depthTest,\n      cullFace: cullFace,\n      uniforms: uniforms,\n      vertexShaderID: vertexShaderID,\n      fragmentShaderID: fragmentShaderID,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      texturesOptions: texturesOptions,\n      crossOrigin: crossOrigin,\n      alwaysDraw: alwaysDraw,\n      visible: visible,\n      transparent: transparent,\n      drawCheckMargins: drawCheckMargins,\n      autoloadSources: autoloadSources,\n      watchScroll: watchScroll,\n      fov: fov\n    }); // return if no gl context\n\n    if (!_this35.gl) {\n      return _possibleConstructorReturn(_this35);\n    } // remove from stack, update type to PingPongPlane and then stack again\n\n\n    _this35.renderer.scene.removePlane(_assertThisInitialized(_this35));\n\n    _this35.type = \"PingPongPlane\";\n\n    _this35.renderer.scene.addPlane(_assertThisInitialized(_this35)); // create 2 render targets\n\n\n    _this35.readPass = new RenderTarget(curtains, {\n      depth: false,\n      clear: false,\n      texturesOptions: texturesOptions\n    });\n    _this35.writePass = new RenderTarget(curtains, {\n      depth: false,\n      clear: false,\n      texturesOptions: texturesOptions\n    }); // create a texture where we'll draw\n\n    var texture = _this35.createTexture({\n      sampler: sampler\n    }); // wait for both render targets textures to be ready and force a copy of the current target texture\n    // even if the swap already began\n    // this seems to fix some erratic bugs\n\n\n    var nbPassesReady = 0;\n\n    _this35.readPass.getTexture().onSourceUploaded(function () {\n      nbPassesReady++;\n\n      _this35._checkIfReady(nbPassesReady);\n    });\n\n    _this35.writePass.getTexture().onSourceUploaded(function () {\n      nbPassesReady++;\n\n      _this35._checkIfReady(nbPassesReady);\n    }); // directly assign a render target\n\n\n    _this35.setRenderTarget(_this35.readPass); // override onRender and onAfterRender callbacks\n\n\n    _this35._onRenderCallback = function () {\n      // update the render target\n      if (_this35.readPass && _this35.writePass && _this35.textures[0] && _this35.textures[0]._uploaded) {\n        _this35.setRenderTarget(_this35.writePass);\n      }\n\n      _this35._onPingPongRenderCallback && _this35._onPingPongRenderCallback();\n    };\n\n    _this35._onAfterRenderCallback = function () {\n      // swap FBOs and update texture\n      if (_this35.readPass && _this35.writePass && _this35.textures[0] && _this35.textures[0]._uploaded) {\n        _this35._swapPasses();\n      }\n\n      _this35._onPingPongAfterRenderCallback && _this35._onPingPongAfterRenderCallback();\n    };\n\n    return _this35;\n  }\n  /***\r\n   Copy the current target texture once both render targets textures have been uploaded\r\n   Wait for next tick to be sure our texture is correctly initiated\r\n   ***/\n\n\n  _createClass(PingPongPlane, [{\n    key: \"_checkIfReady\",\n    value: function _checkIfReady(loadedTextures) {\n      var _this36 = this;\n\n      if (loadedTextures === 2) {\n        this.renderer.nextRender.add(function () {\n          _this36.textures[0].copy(_this36.target.getTexture());\n        });\n      }\n    }\n    /***\r\n     After each draw call, we'll swap the 2 render targets and copy the read pass texture again\r\n     ***/\n\n  }, {\n    key: \"_swapPasses\",\n    value: function _swapPasses() {\n      // swap read and write passes\n      var tempFBO = this.readPass;\n      this.readPass = this.writePass;\n      this.writePass = tempFBO; // apply new texture\n\n      this.textures[0].copy(this.readPass.getTexture());\n    }\n    /***\r\n     Returns the created texture where we're writing\r\n     ***/\n\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      return this.textures[0];\n    }\n    /*** OVERRIDE USED EVENTS ***/\n\n    /***\r\n     This is called at each requestAnimationFrame call\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onRender\",\n    value: function onRender(callback) {\n      if (callback) {\n        this._onPingPongRenderCallback = callback;\n      }\n\n      return this;\n    }\n    /***\r\n     This is called at each requestAnimationFrame call\r\n       params :\r\n     @callback (function) : a function to execute\r\n       returns :\r\n     @this: our plane to handle chaining\r\n     ***/\n\n  }, {\n    key: \"onAfterRender\",\n    value: function onAfterRender(callback) {\n      if (callback) {\n        this._onPingPongAfterRenderCallback = callback;\n      }\n\n      return this;\n    }\n    /*** DESTROYING ***/\n\n    /***\r\n     Override the regular remove method to remove the 2 render targets\r\n     ***/\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.target = null; // force unbinding frame buffer\n\n      this.renderer.bindFrameBuffer(null);\n\n      if (this.writePass) {\n        this.writePass.remove();\n        this.writePass = null;\n      }\n\n      if (this.readPass) {\n        this.readPass.remove();\n        this.readPass = null;\n      } // call original remove method\n\n\n      _get(_getPrototypeOf(PingPongPlane.prototype), \"remove\", this).call(this);\n    }\n  }]);\n\n  return PingPongPlane;\n}(Plane);\n/*** FXAAPASS CLASS ***/\n\n/***\r\n Here we create our FXAAPass object\r\n This is just a regular ShaderPass with preset shaders and a resolution uniform\r\n\r\n params: see ShaderPas class object\r\n\r\n returns :\r\n @this: our FXAAPass element\r\n ***/\n\n\nvar FXAAPass = /*#__PURE__*/function (_ShaderPass) {\n  _inherits(FXAAPass, _ShaderPass);\n\n  var _super6 = _createSuper(FXAAPass);\n\n  function FXAAPass(curtains) {\n    var _this37;\n\n    var _ref16 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        renderOrder = _ref16.renderOrder,\n        depthTest = _ref16.depthTest,\n        texturesOptions = _ref16.texturesOptions,\n        crossOrigin = _ref16.crossOrigin,\n        depth = _ref16.depth,\n        clear = _ref16.clear,\n        renderTarget = _ref16.renderTarget;\n\n    _classCallCheck(this, FXAAPass);\n\n    // taken from https://github.com/spite/Wagner/blob/master/fragment-shaders/fxaa-fs.glsl\n    var fragmentShader = \"\\n            precision mediump float;\\n            \\n            varying vec3 vVertexPosition;\\n            varying vec2 vTextureCoord;\\n        \\n            uniform sampler2D uRenderTexture;\\n            \\n            uniform vec2 uResolution;\\n            \\n            #define FXAA_REDUCE_MIN   (1.0/128.0)\\n            #define FXAA_REDUCE_MUL   (1.0/8.0)\\n            #define FXAA_SPAN_MAX     8.0\\n            \\n            void main() {\\n                vec2 res = 1.0 / uResolution;\\n            \\n                vec3 rgbNW = texture2D(uRenderTexture, (vTextureCoord.xy + vec2(-1.0, -1.0) * res)).xyz;\\n                vec3 rgbNE = texture2D(uRenderTexture, (vTextureCoord.xy + vec2(1.0, -1.0) * res)).xyz;\\n                vec3 rgbSW = texture2D(uRenderTexture, (vTextureCoord.xy + vec2(-1.0, 1.0) * res)).xyz;\\n                vec3 rgbSE = texture2D(uRenderTexture, (vTextureCoord.xy + vec2(1.0, 1.0) * res)).xyz;\\n                vec4 rgbaM = texture2D(uRenderTexture, vTextureCoord.xy * res);\\n                vec3 rgbM = rgbaM.xyz;\\n                vec3 luma = vec3(0.299, 0.587, 0.114);\\n            \\n                float lumaNW = dot(rgbNW, luma);\\n                float lumaNE = dot(rgbNE, luma);\\n                float lumaSW = dot(rgbSW, luma);\\n                float lumaSE = dot(rgbSE, luma);\\n                float lumaM  = dot(rgbM,  luma);\\n                float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n                float lumaMax = max(lumaM, max(max(lumaNW, lumaNE) , max(lumaSW, lumaSE)));\\n            \\n                vec2 dir;\\n                dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n                dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n            \\n                float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\\n            \\n                float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\\n                dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\\n                      max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\\n                            dir * rcpDirMin)) * res;\\n                vec4 rgbA = (1.0/2.0) * (\\n                texture2D(uRenderTexture, vTextureCoord.xy + dir * (1.0/3.0 - 0.5)) +\\n                texture2D(uRenderTexture, vTextureCoord.xy + dir * (2.0/3.0 - 0.5)));\\n                vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\\n                texture2D(uRenderTexture, vTextureCoord.xy + dir * (0.0/3.0 - 0.5)) +\\n                texture2D(uRenderTexture, vTextureCoord.xy + dir * (3.0/3.0 - 0.5)));\\n                float lumaB = dot(rgbB, vec4(luma, 0.0));\\n            \\n                if ((lumaB < lumaMin) || (lumaB > lumaMax)) {\\n                    gl_FragColor = rgbA;\\n                } else {\\n                    gl_FragColor = rgbB;\\n                }\\n            }\\n        \";\n    var uniforms = {\n      resolution: {\n        name: \"uResolution\",\n        type: \"2f\",\n        value: [0, 0] // will be updated after having called super()\n\n      }\n    };\n    _this37 = _super6.call(this, curtains, {\n      fragmentShader: fragmentShader,\n      uniforms: uniforms,\n      // Mesh params\n      renderOrder: renderOrder,\n      depthTest: depthTest,\n      texturesOptions: texturesOptions,\n      crossOrigin: crossOrigin,\n      depth: depth,\n      clear: clear,\n      renderTarget: renderTarget\n    }); // return if no gl context\n\n    if (!_this37.gl) {\n      return _possibleConstructorReturn(_this37);\n    } // update the resolution uniform\n\n\n    _this37.uniforms.resolution.value = [_this37.renderer._boundingRect.width, _this37.renderer._boundingRect.height]; // override onAfterResize callback\n\n    _this37._onAfterResizeCallback = function () {\n      // update the resolution uniform\n      _this37.uniforms.resolution.value = [_this37.renderer._boundingRect.width, _this37.renderer._boundingRect.height];\n      _this37._onFXAAPassAfterResizeCallback && _this37._onFXAAPassAfterResizeCallback();\n    };\n\n    return _this37;\n  }\n  /***\r\n   This is called each time the FXAAPass has been resized\r\n     params :\r\n   @callback (function) : a function to execute\r\n     returns :\r\n   @this: our FXAAPass to handle chaining\r\n   ***/\n\n\n  _createClass(FXAAPass, [{\n    key: \"onAfterResize\",\n    value: function onAfterResize(callback) {\n      if (callback) {\n        this._onFXAAPassAfterResizeCallback = callback;\n      }\n\n      return this;\n    }\n  }]);\n\n  return FXAAPass;\n}(ShaderPass);\n\nfunction CurtainsWrapper(props) {\n  var _useContext = useContext(CurtainsContext),\n      state = _useContext.state,\n      dispatch = _useContext.dispatch;\n\n  var container = useRef(null);\n  var curtains = useRef(null);\n\n  var alpha = props.alpha,\n      antialias = props.antialias,\n      premultipliedAlpha = props.premultipliedAlpha,\n      depth = props.depth,\n      preserveDrawingBuffer = props.preserveDrawingBuffer,\n      failIfMajorPerformanceCaveat = props.failIfMajorPerformanceCaveat,\n      stencil = props.stencil,\n      autoRender = props.autoRender,\n      autoResize = props.autoResize,\n      pixelRatio = props.pixelRatio,\n      renderingScale = props.renderingScale,\n      watchScroll = props.watchScroll,\n      production = props.production,\n      onAfterResize = props.onAfterResize,\n      onContextLost = props.onContextLost,\n      onContextRestored = props.onContextRestored,\n      onError = props.onError,\n      onSuccess = props.onSuccess,\n      onRender = props.onRender,\n      onScroll = props.onScroll,\n      validProps = _objectWithoutPropertiesLoose(props, [\"alpha\", \"antialias\", \"premultipliedAlpha\", \"depth\", \"preserveDrawingBuffer\", \"failIfMajorPerformanceCaveat\", \"stencil\", \"autoRender\", \"autoResize\", \"pixelRatio\", \"renderingScale\", \"watchScroll\", \"production\", \"onAfterResize\", \"onContextLost\", \"onContextRestored\", \"onError\", \"onSuccess\", \"onRender\", \"onScroll\"]); // mount\n\n\n  var useMountEffect = function useMountEffect(callback) {\n    return useLayoutEffect(callback, []);\n  };\n\n  useMountEffect(function () {\n    // only init curtains on client side!\n    var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n    if (canUseDOM && !state.curtains && !curtains.current) {\n      curtains.current = new Curtains({\n        container: container.current,\n        production: production ? production : process.env.NODE_ENV === \"production\",\n        alpha: alpha,\n        antialias: antialias,\n        premultipliedAlpha: premultipliedAlpha,\n        depth: depth,\n        preserveDrawingBuffer: preserveDrawingBuffer,\n        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat,\n        stencil: stencil,\n        autoRender: autoRender,\n        autoResize: autoResize,\n        pixelRatio: pixelRatio,\n        renderingScale: renderingScale,\n        watchScroll: watchScroll\n      });\n      dispatch({\n        type: \"SET_CURTAINS\",\n        curtains: curtains.current\n      });\n    }\n\n    var currentCurtains = curtains.current;\n    return function () {\n      if (currentCurtains) {\n        currentCurtains.dispose();\n      }\n    };\n  });\n\n  var useStateEffect = function useStateEffect(callback) {\n    return useLayoutEffect(callback, [state]);\n  };\n\n  useStateEffect(function () {\n    if (curtains.current) {\n      curtains.current.onAfterResize(function () {\n        onAfterResize && onAfterResize(curtains.current); // execute subscriptions hooks\n\n        state.subscriptions.onAfterResize.forEach(function (element) {\n          element.callback && element.callback(curtains.current);\n        });\n      }).onContextLost(function () {\n        onContextLost && onContextLost(curtains.current); // execute subscriptions hooks\n\n        state.subscriptions.onContextLost.forEach(function (element) {\n          element.callback && element.callback(curtains.current);\n        });\n      }).onContextRestored(function () {\n        onContextRestored && onContextRestored(curtains.current); // execute subscriptions hooks\n\n        state.subscriptions.onContextRestored.forEach(function (element) {\n          element.callback && element.callback(curtains.current);\n        });\n      }).onSuccess(function () {\n        onSuccess && onSuccess(curtains.current); // execute subscriptions hooks\n\n        state.subscriptions.onSuccess.forEach(function (element) {\n          element.callback && element.callback(curtains.current);\n        });\n      }).onError(function () {\n        onError && onError(curtains.current); // execute subscriptions hooks\n\n        state.subscriptions.onError.forEach(function (element) {\n          element.callback && element.callback(curtains.current);\n        });\n      }).onRender(function () {\n        onRender && onRender(curtains.current); // execute subscriptions hooks\n\n        state.subscriptions.onRender.forEach(function (element) {\n          element.callback && element.callback(curtains.current);\n        });\n      }).onScroll(function () {\n        onScroll && onScroll(curtains.current); // execute subscriptions hooks\n\n        state.subscriptions.onScroll.forEach(function (element) {\n          element.callback && element.callback(curtains.current);\n        });\n      });\n    }\n  });\n  validProps.className = validProps.className || \"curtains-canvas\"; // avoid passing children to validProps\n\n  validProps.children = null;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, props.children, /*#__PURE__*/React.createElement(\"div\", _extends({}, validProps, {\n    ref: container\n  })));\n}\n\nfunction Curtains$1(props) {\n  return /*#__PURE__*/React.createElement(CurtainsProvider, null, /*#__PURE__*/React.createElement(CurtainsWrapper, props));\n}\n\nvar generateUUID$1 = function generateUUID() {\n  return '_' + Math.random().toString(36).substr(2, 9);\n}; // execute this hook once our curtains webgl context is ready\n// call again each time one of the dependencies change\n\n\nfunction useCurtains(callback, dependencies) {\n  if (dependencies === void 0) {\n    dependencies = [];\n  }\n\n  var _useContext = useContext(CurtainsContext),\n      state = _useContext.state;\n\n  var useCustomEffect = function useCustomEffect(effectCallback) {\n    return useEffect(effectCallback, [state.curtains].concat(dependencies));\n  };\n\n  useCustomEffect(function () {\n    var cleanUp;\n\n    if (state.curtains && !state.curtains.errors && callback) {\n      cleanUp = callback(state.curtains);\n    }\n\n    return function () {\n      // execute cleanUp if it exists\n      if (cleanUp && typeof cleanUp === \"function\") {\n        cleanUp();\n      }\n    };\n  });\n} // execute this hook when the corresponding curtains event is fired\n// call again each time one of the dependencies change\n\n\nfunction useCurtainsEvent(event, callback, dependencies) {\n  if (dependencies === void 0) {\n    dependencies = [];\n  }\n\n  var availableEvents = [\"onAfterResize\", \"onContextLost\", \"onContextRestored\", \"onError\", \"onSuccess\", \"onRender\", \"onScroll\"]; // do not crash if event passed is not allowed\n\n  var validEvent = availableEvents.find(function (availableEvent) {\n    return event === availableEvent;\n  });\n\n  var _useContext2 = useContext(CurtainsContext),\n      dispatch = _useContext2.dispatch;\n\n  var eventCallback = useRef({\n    // curtains class events, see https://www.curtainsjs.com/curtains-class.html#events\n    event: event,\n    callback: callback,\n    id: generateUUID$1()\n  });\n  useCurtains(function () {\n    // allow dependencies to be available inside the callback\n    eventCallback.current.callback = callback.bind(dependencies);\n\n    if (validEvent) {\n      dispatch({\n        type: \"ADD_SUBSCRIPTION\",\n        addSubscription: eventCallback.current\n      });\n    }\n\n    var currentRenderCallback = eventCallback.current;\n    return function () {\n      if (validEvent) {\n        dispatch({\n          type: \"REMOVE_SUBSCRIPTION\",\n          removeSubscription: currentRenderCallback\n        });\n      }\n    };\n  }, [dispatch, validEvent].concat(dependencies));\n}\n\nfunction Plane$1(props) {\n  // extract plane parameters and events from props\n  var vertexShader = props.vertexShader,\n      vertexShaderID = props.vertexShaderID,\n      fragmentShader = props.fragmentShader,\n      fragmentShaderID = props.fragmentShaderID,\n      widthSegments = props.widthSegments,\n      heightSegments = props.heightSegments,\n      renderOrder = props.renderOrder,\n      depthTest = props.depthTest,\n      transparent = props.transparent,\n      cullFace = props.cullFace,\n      alwaysDraw = props.alwaysDraw,\n      visible = props.visible,\n      drawCheckMargins = props.drawCheckMargins,\n      watchScroll = props.watchScroll,\n      autoloadSources = props.autoloadSources,\n      texturesOptions = props.texturesOptions,\n      crossOrigin = props.crossOrigin,\n      fov = props.fov,\n      uniforms = props.uniforms,\n      target = props.target,\n      relativeTranslation = props.relativeTranslation,\n      rotation = props.rotation,\n      scale = props.scale,\n      transformOrigin = props.transformOrigin,\n      onAfterRender = props.onAfterRender,\n      onAfterResize = props.onAfterResize,\n      onError = props.onError,\n      onLeaveView = props.onLeaveView,\n      onLoading = props.onLoading,\n      onReady = props.onReady,\n      onReEnterView = props.onReEnterView,\n      onRender = props.onRender,\n      onBeforeCreate = props.onBeforeCreate,\n      onBeforeRemove = props.onBeforeRemove,\n      validProps = _objectWithoutPropertiesLoose(props, [\"vertexShader\", \"vertexShaderID\", \"fragmentShader\", \"fragmentShaderID\", \"widthSegments\", \"heightSegments\", \"renderOrder\", \"depthTest\", \"transparent\", \"cullFace\", \"alwaysDraw\", \"visible\", \"drawCheckMargins\", \"watchScroll\", \"autoloadSources\", \"texturesOptions\", \"crossOrigin\", \"fov\", \"uniforms\", \"target\", \"relativeTranslation\", \"rotation\", \"scale\", \"transformOrigin\", \"onAfterRender\", \"onAfterResize\", \"onError\", \"onLeaveView\", \"onLoading\", \"onReady\", \"onReEnterView\", \"onRender\", \"onBeforeCreate\", \"onBeforeRemove\"]);\n\n  var planeEl = useRef();\n  var webglPlane = useRef();\n  useCurtains(function (curtains) {\n    if (!webglPlane.current) {\n      onBeforeCreate && onBeforeCreate(); // just add the plane\n\n      webglPlane.current = new Plane(curtains, planeEl.current, {\n        vertexShader: vertexShader,\n        vertexShaderID: vertexShaderID,\n        fragmentShader: fragmentShader,\n        fragmentShaderID: fragmentShaderID,\n        widthSegments: widthSegments,\n        heightSegments: heightSegments,\n        renderOrder: renderOrder,\n        depthTest: depthTest,\n        transparent: transparent,\n        cullFace: cullFace,\n        alwaysDraw: alwaysDraw,\n        visible: visible,\n        drawCheckMargins: drawCheckMargins,\n        watchScroll: watchScroll,\n        autoloadSources: autoloadSources,\n        texturesOptions: texturesOptions,\n        crossOrigin: crossOrigin,\n        fov: fov,\n        uniforms: uniforms\n      }).onAfterRender(function () {\n        onAfterRender && onAfterRender(webglPlane.current);\n      }).onAfterResize(function () {\n        onAfterResize && onAfterResize(webglPlane.current);\n      }).onError(function () {\n        onError && onError(webglPlane.current);\n      }).onLeaveView(function () {\n        onLeaveView && onLeaveView(webglPlane.current);\n      }).onLoading(function (texture) {\n        onLoading && onLoading(webglPlane.current, texture);\n      }).onReady(function () {\n        onReady && onReady(webglPlane.current);\n      }).onReEnterView(function () {\n        onReEnterView && onReEnterView(webglPlane.current);\n      }).onRender(function () {\n        onRender && onRender(webglPlane.current);\n      });\n    }\n\n    var currentPlane = webglPlane.current;\n    return function () {\n      if (currentPlane) {\n        onBeforeRemove && onBeforeRemove(currentPlane);\n        currentPlane.remove();\n      }\n    };\n  }); // handle parameters/properties that could be changed at runtime\n\n  useEffect(function () {\n    if (webglPlane.current) {\n      // simple properties\n      if (alwaysDraw !== undefined) {\n        webglPlane.current.alwaysDraw = alwaysDraw;\n      }\n\n      if (cullFace !== undefined) {\n        webglPlane.current.cullFace = cullFace;\n      }\n\n      if (drawCheckMargins !== undefined) {\n        webglPlane.current.drawCheckMargins = drawCheckMargins;\n      }\n\n      if (visible !== undefined) {\n        webglPlane.current.visible = visible;\n      }\n\n      if (watchScroll !== undefined) {\n        webglPlane.current.watchScroll = watchScroll;\n      } // other properties\n\n\n      if (depthTest !== undefined) {\n        webglPlane.current.enableDepthTest(depthTest);\n      } // render target\n\n\n      if (target !== undefined) {\n        webglPlane.current.setRenderTarget(target);\n      } // render order\n\n\n      if (renderOrder !== undefined) {\n        webglPlane.current.setRenderOrder(renderOrder);\n      } // transformations\n\n\n      if (relativeTranslation) {\n        var newTranslation = new Vec3();\n\n        if (relativeTranslation.length >= 3) {\n          newTranslation.set(relativeTranslation[0], relativeTranslation[1], relativeTranslation[2]);\n        }\n\n        webglPlane.current.setRelativeTranslation(newTranslation);\n      }\n\n      if (rotation) {\n        var newRotation = new Vec3();\n\n        if (rotation.length >= 3) {\n          newRotation.set(rotation[0], rotation[1], rotation[2]);\n        }\n\n        webglPlane.current.setRotation(newRotation);\n      }\n\n      if (scale) {\n        var newScale = new Vec2(1, 1);\n\n        if (scale.length >= 2) {\n          newScale.set(scale[0], scale[1]);\n        }\n\n        webglPlane.current.setScale(newScale);\n      }\n\n      if (transformOrigin) {\n        var newTransformOrigin = new Vec3(0.5, 0.5, 0);\n\n        if (transformOrigin.length >= 3) {\n          newTransformOrigin.set(transformOrigin[0], transformOrigin[1], transformOrigin[2]);\n        }\n\n        webglPlane.current.setTransformOrigin(newTransformOrigin);\n      } // update camera fov only if it actually changed\n\n\n      if (fov !== undefined && fov !== webglPlane.current.camera.fov) {\n        webglPlane.current.setPerspective(fov);\n      }\n    }\n  }, [alwaysDraw, cullFace, drawCheckMargins, visible, watchScroll, renderOrder, depthTest, target, relativeTranslation, rotation, scale, transformOrigin, fov]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: planeEl\n  }, validProps), props.children);\n}\n\nfunction ShaderPass$1(props) {\n  // extract shader pass parameters and events from props\n  var vertexShader = props.vertexShader,\n      vertexShaderID = props.vertexShaderID,\n      fragmentShader = props.fragmentShader,\n      fragmentShaderID = props.fragmentShaderID,\n      renderOrder = props.renderOrder,\n      depthTest = props.depthTest,\n      depth = props.depth,\n      clear = props.clear,\n      renderTarget = props.renderTarget,\n      texturesOptions = props.texturesOptions,\n      crossOrigin = props.crossOrigin,\n      uniforms = props.uniforms,\n      onAfterRender = props.onAfterRender,\n      onAfterResize = props.onAfterResize,\n      onError = props.onError,\n      onLoading = props.onLoading,\n      onReady = props.onReady,\n      onRender = props.onRender,\n      uniqueKey = props.uniqueKey;\n  var webglShaderPass = useRef();\n  useCurtains(function (curtains) {\n    var existingPass = [];\n\n    if (uniqueKey) {\n      existingPass = curtains.shaderPasses.filter(function (pass) {\n        return pass._uniqueKey === uniqueKey;\n      });\n    }\n\n    var currentShaderPass;\n\n    if (!webglShaderPass.current && !existingPass.length) {\n      webglShaderPass.current = new ShaderPass(curtains, {\n        vertexShader: vertexShader,\n        vertexShaderID: vertexShaderID,\n        fragmentShader: fragmentShader,\n        fragmentShaderID: fragmentShaderID,\n        renderOrder: renderOrder,\n        depthTest: depthTest,\n        depth: depth,\n        clear: clear,\n        renderTarget: renderTarget,\n        texturesOptions: texturesOptions,\n        crossOrigin: crossOrigin,\n        uniforms: uniforms\n      }).onAfterRender(function () {\n        onAfterRender && onAfterRender(webglShaderPass.current);\n      }).onAfterResize(function () {\n        onAfterResize && onAfterResize(webglShaderPass.current);\n      }).onError(function () {\n        onError && onError(webglShaderPass.current);\n      }).onLoading(function () {\n        onLoading && onLoading(webglShaderPass.current);\n      }).onReady(function () {\n        onReady && onReady(webglShaderPass.current);\n      }).onRender(function () {\n        onRender && onRender(webglShaderPass.current);\n      });\n\n      if (uniqueKey) {\n        webglShaderPass.current._uniqueKey = uniqueKey;\n      }\n\n      currentShaderPass = webglShaderPass.current;\n    } else if (!webglShaderPass.current) {\n      webglShaderPass.current = existingPass[0];\n    }\n\n    return function () {\n      if (currentShaderPass) {\n        currentShaderPass.remove();\n      }\n    };\n  }); // handle parameters/properties that could be changed at runtime\n\n  useEffect(function () {\n    if (webglShaderPass.current) {\n      if (renderOrder !== undefined) {\n        webglShaderPass.current.setRenderOrder(renderOrder);\n      }\n    }\n  }, [renderOrder]);\n  return props.children || null;\n}\n\nfunction RenderTarget$1(props) {\n  // extract render target parameters from props\n  var depth = props.depth,\n      clear = props.clear,\n      minWidth = props.minWidth,\n      minHeight = props.minHeight,\n      texturesOptions = props.texturesOptions,\n      onReady = props.onReady,\n      _props$autoDetectChil = props.autoDetectChildren,\n      autoDetectChildren = _props$autoDetectChil === void 0 ? true : _props$autoDetectChil,\n      uniqueKey = props.uniqueKey;\n\n  var _useState = useState(null),\n      children = _useState[0],\n      setChildren = _useState[1];\n\n  var _useState2 = useState(null),\n      renderTarget = _useState2[0],\n      setRenderTarget = _useState2[1];\n\n  useCurtains(function (curtains) {\n    var existingRenderTarget = [];\n\n    if (uniqueKey) {\n      existingRenderTarget = curtains.renderTargets.filter(function (target) {\n        return target._uniqueKey === uniqueKey;\n      });\n    }\n\n    if (!renderTarget && !existingRenderTarget.length) {\n      var webglRenderTarget = new RenderTarget(curtains, {\n        depth: depth,\n        clear: clear,\n        minWidth: minWidth,\n        minHeight: minHeight,\n        texturesOptions: texturesOptions\n      });\n\n      if (uniqueKey) {\n        webglRenderTarget._uniqueKey = uniqueKey;\n      }\n\n      setRenderTarget(webglRenderTarget);\n      onReady && onReady(webglRenderTarget);\n    } else if (!renderTarget) {\n      setRenderTarget(existingRenderTarget[0]);\n    }\n  });\n  useEffect(function () {\n    // recursively map through all children and execute a callback on each react element\n    var recursiveMap = function recursiveMap(children, callback) {\n      // return null if the render target does not have any child\n      if (!Children.count(children)) {\n        return null;\n      } else {\n        return Children.map(children, function (child) {\n          if (! /*#__PURE__*/isValidElement(child)) {\n            return child;\n          }\n\n          if (child.props.children) {\n            child = /*#__PURE__*/cloneElement(child, {\n              children: recursiveMap(child.props.children, callback)\n            });\n          }\n\n          return callback(child);\n        });\n      }\n    };\n\n    if (!autoDetectChildren) {\n      setChildren(props.children);\n    } else if (renderTarget) {\n      var compChildren = recursiveMap(props.children, function (child) {\n        // our callback\n        if (child.type === Plane$1) {\n          return /*#__PURE__*/cloneElement(child, _extends({}, child.props, {\n            target: renderTarget\n          }));\n        } else if (child.type === ShaderPass$1) {\n          var augmentedProps = _extends({}, child.props, {\n            renderTarget: renderTarget\n          }); // add uniqueKey if needed and not set\n\n\n          if (uniqueKey && !child.props.uniqueKey) {\n            augmentedProps = _extends({}, augmentedProps, {\n              uniqueKey: uniqueKey\n            });\n          }\n\n          return /*#__PURE__*/cloneElement(child, augmentedProps);\n        } else {\n          return child;\n        }\n      });\n      setChildren(compChildren);\n    }\n\n    return function () {\n      if (renderTarget && !renderTarget._shaderPass && renderTarget.textures.length) {\n        renderTarget.remove();\n      }\n    };\n  }, [renderTarget, autoDetectChildren]);\n  return children;\n}\n\nfunction PingPongPlane$1(props) {\n  // extract plane parameters and events from props\n  var sampler = props.sampler,\n      vertexShader = props.vertexShader,\n      vertexShaderID = props.vertexShaderID,\n      fragmentShader = props.fragmentShader,\n      fragmentShaderID = props.fragmentShaderID,\n      widthSegments = props.widthSegments,\n      heightSegments = props.heightSegments,\n      depthTest = props.depthTest,\n      transparent = props.transparent,\n      cullFace = props.cullFace,\n      shareProgram = props.shareProgram,\n      visible = props.visible,\n      drawCheckMargins = props.drawCheckMargins,\n      watchScroll = props.watchScroll,\n      texturesOptions = props.texturesOptions,\n      crossOrigin = props.crossOrigin,\n      fov = props.fov,\n      uniforms = props.uniforms,\n      target = props.target,\n      relativeTranslation = props.relativeTranslation,\n      rotation = props.rotation,\n      scale = props.scale,\n      transformOrigin = props.transformOrigin,\n      onAfterRender = props.onAfterRender,\n      onAfterResize = props.onAfterResize,\n      onError = props.onError,\n      onLeaveView = props.onLeaveView,\n      onLoading = props.onLoading,\n      onReady = props.onReady,\n      onReEnterView = props.onReEnterView,\n      onRender = props.onRender,\n      onBeforeCreate = props.onBeforeCreate,\n      onBeforeRemove = props.onBeforeRemove,\n      validProps = _objectWithoutPropertiesLoose(props, [\"sampler\", \"vertexShader\", \"vertexShaderID\", \"fragmentShader\", \"fragmentShaderID\", \"widthSegments\", \"heightSegments\", \"depthTest\", \"transparent\", \"cullFace\", \"shareProgram\", \"visible\", \"drawCheckMargins\", \"watchScroll\", \"texturesOptions\", \"crossOrigin\", \"fov\", \"uniforms\", \"target\", \"relativeTranslation\", \"rotation\", \"scale\", \"transformOrigin\", \"onAfterRender\", \"onAfterResize\", \"onError\", \"onLeaveView\", \"onLoading\", \"onReady\", \"onReEnterView\", \"onRender\", \"onBeforeCreate\", \"onBeforeRemove\"]);\n\n  var planeEl = useRef();\n  var webglPlane = useRef();\n  useCurtains(function (curtains) {\n    if (!webglPlane.current) {\n      onBeforeCreate && onBeforeCreate(); // just add the plane\n\n      webglPlane.current = new PingPongPlane(curtains, planeEl.current, {\n        sampler: sampler,\n        vertexShader: vertexShader,\n        vertexShaderID: vertexShaderID,\n        fragmentShader: fragmentShader,\n        fragmentShaderID: fragmentShaderID,\n        widthSegments: widthSegments,\n        heightSegments: heightSegments,\n        depthTest: depthTest,\n        transparent: transparent,\n        cullFace: cullFace,\n        shareProgram: shareProgram,\n        visible: visible,\n        drawCheckMargins: drawCheckMargins,\n        watchScroll: watchScroll,\n        texturesOptions: texturesOptions,\n        crossOrigin: crossOrigin,\n        fov: fov,\n        uniforms: uniforms\n      }).onAfterRender(function () {\n        onAfterRender && onAfterRender(webglPlane.current);\n      }).onAfterResize(function () {\n        onAfterResize && onAfterResize(webglPlane.current);\n      }).onError(function () {\n        onError && onError(webglPlane.current);\n      }).onLeaveView(function () {\n        onLeaveView && onLeaveView(webglPlane.current);\n      }).onLoading(function (texture) {\n        onLoading && onLoading(webglPlane.current, texture);\n      }).onReady(function () {\n        onReady && onReady(webglPlane.current);\n      }).onReEnterView(function () {\n        onReEnterView && onReEnterView(webglPlane.current);\n      }).onRender(function () {\n        onRender && onRender(webglPlane.current);\n      });\n    }\n\n    var currentPlane = webglPlane.current;\n    return function () {\n      if (currentPlane) {\n        onBeforeRemove && onBeforeRemove(currentPlane);\n        currentPlane.remove();\n      }\n    };\n  }); // handle parameters/properties that could be changed at runtime\n\n  useEffect(function () {\n    if (webglPlane.current) {\n      // simple properties\n      if (cullFace !== undefined) {\n        webglPlane.current.cullFace = cullFace;\n      }\n\n      if (drawCheckMargins !== undefined) {\n        webglPlane.current.drawCheckMargins = drawCheckMargins;\n      }\n\n      if (visible !== undefined) {\n        webglPlane.current.visible = visible;\n      }\n\n      if (watchScroll !== undefined) {\n        webglPlane.current.watchScroll = watchScroll;\n      } // other properties\n\n\n      if (depthTest !== undefined) {\n        webglPlane.current.enableDepthTest(depthTest);\n      } // render target\n\n\n      if (target !== undefined) {\n        webglPlane.current.setRenderTarget(target);\n      } // transformations\n\n\n      if (relativeTranslation) {\n        var newTranslation = new Vec3();\n\n        if (rotation.length >= 3) {\n          newTranslation.set(relativeTranslation[0], relativeTranslation[1], relativeTranslation[2]);\n        }\n\n        webglPlane.current.setRelativeTranslation(newTranslation);\n      }\n\n      if (rotation) {\n        var newRotation = new Vec3();\n\n        if (rotation.length >= 3) {\n          newRotation.set(rotation[0], rotation[1], rotation[2]);\n        }\n\n        webglPlane.current.setRotation(newRotation);\n      }\n\n      if (scale) {\n        var newScale = new Vec2(1, 1);\n\n        if (scale.length >= 2) {\n          newScale.set(scale[0], scale[1]);\n        }\n\n        webglPlane.current.setScale(newScale);\n      }\n\n      if (transformOrigin) {\n        var newTransformOrigin = new Vec3(0.5, 0.5, 0);\n\n        if (transformOrigin.length >= 3) {\n          newTransformOrigin.set(transformOrigin[0], transformOrigin[1], transformOrigin[2]);\n        }\n\n        webglPlane.current.setTransformOrigin(newTransformOrigin);\n      } // update camera fov only if it actually changed\n\n\n      if (fov !== undefined && fov !== webglPlane.current.camera.fov) {\n        webglPlane.current.setPerspective(fov);\n      }\n    }\n  }, [cullFace, drawCheckMargins, visible, watchScroll, depthTest, target, relativeTranslation, rotation, scale, transformOrigin, fov]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: planeEl\n  }, validProps), props.children);\n}\n\nfunction FXAAPass$1(props) {\n  // extract fxaa parameters from props\n  var depthTest = props.depthTest,\n      renderOrder = props.renderOrder,\n      depth = props.depth,\n      clear = props.clear,\n      renderTarget = props.renderTarget,\n      texturesOptions = props.texturesOptions,\n      onAfterRender = props.onAfterRender,\n      onAfterResize = props.onAfterResize,\n      onError = props.onError,\n      onLoading = props.onLoading,\n      onReady = props.onReady,\n      onRender = props.onRender,\n      uniqueKey = props.uniqueKey;\n  var webglFXAAPass = useRef();\n  useCurtains(function (curtains) {\n    var existingPass = [];\n\n    if (uniqueKey) {\n      existingPass = curtains.shaderPasses.filter(function (pass) {\n        return pass._uniqueKey === uniqueKey;\n      });\n    }\n\n    var currentFXAAPass;\n\n    if (!webglFXAAPass.current && !existingPass.length) {\n      webglFXAAPass.current = new FXAAPass(curtains, {\n        depthTest: depthTest,\n        renderOrder: renderOrder,\n        depth: depth,\n        clear: clear,\n        renderTarget: renderTarget,\n        texturesOptions: texturesOptions\n      });\n      webglFXAAPass.current.onAfterRender(function () {\n        onAfterRender && onAfterRender(webglFXAAPass.current);\n      }).onAfterResize(function () {\n        onAfterResize && onAfterResize(webglFXAAPass.current);\n      }).onError(function () {\n        onError && onError(webglFXAAPass.current);\n      }).onLoading(function () {\n        onLoading && onLoading(webglFXAAPass.current);\n      }).onReady(function () {\n        onReady && onReady(webglFXAAPass.current);\n      }).onRender(function () {\n        onRender && onRender(webglFXAAPass.current);\n      });\n\n      if (uniqueKey) {\n        webglFXAAPass.current._uniqueKey = uniqueKey;\n      }\n\n      currentFXAAPass = webglFXAAPass.current;\n    } else if (!webglFXAAPass.current) {\n      webglFXAAPass.current = existingPass[0];\n    }\n\n    return function () {\n      if (currentFXAAPass) {\n        currentFXAAPass.remove();\n      }\n    };\n  }); // handle parameters/properties that could be changed at runtime\n\n  useEffect(function () {\n    if (webglFXAAPass.current) {\n      if (renderOrder !== undefined) {\n        webglFXAAPass.current.setRenderOrder(renderOrder);\n      }\n    }\n  }, [renderOrder]);\n  return props.children || null;\n}\n\nexport { Curtains$1 as Curtains, FXAAPass$1 as FXAAPass, PingPongPlane$1 as PingPongPlane, Plane$1 as Plane, RenderTarget$1 as RenderTarget, ShaderPass$1 as ShaderPass, useCurtains, useCurtainsEvent };"],"sourceRoot":""}